<html>

<head>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <link href="style.css" rel="stylesheet" type="text/css" />
  <title>Effective TypeScript</title>
</head>

<body>
  <div data-type="book" class="calibre1" id="calibre_link-753">
    <section class="praise" data-pdf-bookmark="Praise for Effective TypeScript" data-type="dedication"
      type="dedication">
      <div class="praise" id="calibre_link-823">
        <h1 class="calibre2">Praise for <em class="calibre3">Effective TypeScript</em></h1>

        <blockquote class="calibre4 pcalibre1 pcalibre">
          <p class="calibre5">“<em class="calibre3">Effective TypeScript</em> explores the most common questions we see
            when working with TypeScript and provides practical, results-oriented advice. Regardless of your level of
            TypeScript experience, you can learn something from this book.”
          </p>
          <p data-type="attribution" class="calibre6 pcalibre2">Ryan Cavanaugh, Engineering Lead for TypeScript at
            Microsoft</p>
        </blockquote>

        <blockquote class="calibre4 pcalibre1 pcalibre">
          <p class="calibre5">“This book is packed with practical recipes and must be kept on the desk of every
            professional TypeScript developer. Even if you think you know TypeScript already, get this book and you
            won’t regret it.”</p>
          <p data-type="attribution" class="calibre6 pcalibre2">Yakov Fain, Java Champion</p>
        </blockquote>

        <blockquote class="calibre4 pcalibre1 pcalibre">
          <p class="calibre5">“TypeScript is taking over the development world...The deeper understanding of TypeScript
            this book provides will help many developers shine as they take advantage of TypeScript’s powerful
            features.”</p>
          <p data-type="attribution" class="calibre6 pcalibre2">Jason Killian, Cofounder of TypeScript NYC and former
            TSLint maintainer</p>
        </blockquote>

        <blockquote class="calibre4 pcalibre1 pcalibre">
          <p class="calibre5">“This book is not just about what TypeScript can do&mdash;it teaches why each language
            feature is useful, and where to apply patterns to get the greatest effect. The book focuses on practical
            advice that will be useful in day-to-day work, with just enough theory to give the reader a deep
            understanding of how everything works. I consider myself to be an advanced TypeScript user, and I learned a
            number of new things from this book.”</p>
          <p data-type="attribution" class="calibre6 pcalibre2">Jesse Hallett, Senior Software Engineer, Originate, Inc.
          </p>
        </blockquote>



      </div>
    </section>
  </div>

  <div data-type="book" class="calibre1" id="calibre_link-752">
    <section data-pdf-bookmark="Effective TypeScript" data-type="titlepage" type="titlepage" class="pcalibre3 calibre7">
      <div class="praise" id="calibre_link-824">
        <h1 class="calibre8">Effective TypeScript</h1>


        <p class="subtitle">62 Specific Ways to Improve Your TypeScript</p>


        <p class="author">Dan Vanderkam</p>
      </div>
    </section>
  </div>

  <div data-type="book" class="calibre1" id="calibre_link-754">
    <section data-pdf-bookmark="Effective TypeScript" data-type="copyright-page" type="copyright-page" class="praise">
      <div class="praise" id="calibre_link-825">
        <h1 class="calibre2">Effective TypeScript</h1>
        <p class="author1">
          by
          <span class="calibre">Dan </span>
          <span class="calibre">Vanderkam</span>
        </p>
        <p class="author1">Copyright © 2020 Dan Vanderkam. All rights reserved.</p>
        <p class="author1">Printed in the United States of America.</p>
        <p class="author1">
          Published by
          <span class="calibre">O’Reilly Media, Inc.</span>, 1005 Gravenstein Highway North, Sebastopol, CA 95472.
        </p>
        <p class="author1">
          O’Reilly books may be purchased for educational, business, or sales promotional use. Online editions are also
          available for most titles (<a href="http://oreilly.com" class="calibre9">http://oreilly.com</a>). For more
          information, contact our corporate/institutional sales department: 800-998-9938 or <span data-type="email"
            class="calibre"><em class="calibre3">corporate@oreilly.com</em></span>.
        </p>
        <ul class="stafflist">
          <li class="calibre10">
            <span class="calibre">Acquisitions Editor:</span> Jennifer Pollock
          </li>
          <li class="calibre10">
            <span class="calibre">Development Editor:</span> Angela Rufino
          </li>
          <li class="calibre10">
            <span class="calibre">Production Editor:</span> Deborah Baker
          </li>
          <li class="calibre10">
            <span class="calibre">Copyeditor:</span> Jasmine Kwityn
          </li>
          <li class="calibre10">
            <span class="calibre">Proofreader:</span>
            Kim Wimpsett
          </li>
          <li class="calibre10">
            <span class="calibre">Indexer:</span>
            Judith McConville
          </li>
          <li class="calibre10">
            <span class="calibre">Interior Designer:</span>
            David Futato
          </li>
          <li class="calibre10">
            <span class="calibre">Cover Designer:</span>
            Karen Montgomery
          </li>
          <li class="calibre10">
            <span class="calibre">Illustrator:</span>
            Rebecca Demarest
          </li>
        </ul>
        <ul class="printings">
          <li class="calibre11">
            <span class="calibre">November 2019:</span>
            First Edition
          </li>
        </ul>

        <div class="praise">
          <h1 class="calibre2">Revision History for the First Edition</h1>
          <ul class="printings">
            <li class="calibre12">
              <span class="calibre">2019-10-16:</span>
              First Release
            </li>
          </ul>
        </div>
        <p class="author1">
          See
          <a href="http://oreilly.com/catalog/errata.csp?isbn=9781492053743"
            class="calibre9">http://oreilly.com/catalog/errata.csp?isbn=9781492053743</a>
          for release details.
        </p>
        <div class="praise">
          <p class="author1">
            The O’Reilly logo is a registered trademark of O’Reilly Media, Inc.
            <em class="calibre3">Effective TypeScript</em>, the cover image, and related trade dress are
            trademarks of O’Reilly Media, Inc.
          </p>
          <p class="author1">The views expressed in this work are those of the author, and do not represent the
            publisher’s views. While the publisher and the author have used good faith efforts to ensure that the
            information and instructions contained in this work are accurate, the publisher and the author disclaim all
            responsibility for errors or omissions, including without limitation responsibility for damages resulting
            from the use of or reliance on this work. Use of the information and instructions contained in this work is
            at your own risk. If any code samples or other technology this work contains or describes is subject to open
            source licenses or the intellectual property rights of others, it is your responsibility to ensure that your
            use thereof complies with such licenses and/or rights.</p>
        </div>
        <div class="praise">
          <p class="author1">978-1-492-05374-3</p>
          <p class="author1">[LSI]</p>
        </div>
      </div>
    </section>
  </div>

  <div data-type="book" class="calibre1" id="calibre_link-755">
    <section data-pdf-bookmark="Dedication" data-type="dedication" type="dedication" class="praise">
      <div class="praise" id="calibre_link-826">
        <h1 class="calibre2">Dedication</h1>

        <p class="author1">For Alex. <br class="calibre13" />You’re just my type.
        </p>
      </div>
    </section>
  </div>

  <div data-type="book" class="calibre1" id="calibre_link-756">
    <section data-pdf-bookmark="Preface" data-type="preface" type="preface" class="praise">
      <div class="praise" id="calibre_link-827">
        <h1 class="calibre14">Preface</h1>


        <p class="author1">In the spring of 2016, I visited my old coworker Evan Martin at Google’s San Francisco office
          and asked him what he was excited about. I’d asked him this same question many times over the years because
          the answers were wide-ranging and unpredictable but always interesting: C++ build tools, Linux audio drivers,
          online crosswords, emacs plugins. This time, Evan was excited about TypeScript and Visual Studio Code.</p>

        <p class="author1">I was surprised! I’d heard of TypeScript before, but I knew only that it was created by
          Microsoft and that I mistakenly believed it had something to do with .NET. As a lifelong Linux user, I
          couldn’t believe that Evan had hopped on team Microsoft.</p>

        <p class="author1">Then Evan showed me vscode and the TypeScript playground and I was instantly converted.
          Everything was so fast, and the code intelligence made it easy to build a mental model of the type system.
          After years of writing type annotations in JSDoc comments for the Closure Compiler, this felt like typed
          JavaScript that really worked. And Microsoft had built a cross-platform text editor on top of Chromium?
          Perhaps this was a language and toolchain worth learning.</p>

        <p class="author1">I’d recently joined Sidewalk Labs and was writing our first JavaScript. The codebase was
          still small enough that Evan and I were able to convert it all to TypeScript over the next few days.</p>

        <p class="author1">I’ve been hooked ever since. TypeScript is more than just a type system. It also brings a
          whole suite of language services which are fast and easy to use. The cumulative effect is that TypeScript
          doesn’t just make JavaScript development safer: it also makes it more fun!</p>






        <section data-pdf-bookmark="Who This Book Is For" data-type="sect1" class="praise">
          <div class="praise" id="calibre_link-828">
            <div class="calibre15"></div>
            <h1 class="calibre16">Who This Book Is For</h1>

            <p class="author1">The <em class="calibre3">Effective</em> books are intended to be the “standard second
              book” on their topic. You’ll get the most out of <em class="calibre3">Effective TypeScript</em> if you
              have some previous practical experience working with JavaScript and TypeScript. My goal with this book is
              not to teach you TypeScript or JavaScript but to help you advance from a beginning or intermediate user to
              an expert. The items in this book do this by helping you build mental models of how TypeScript and its
              ecosystem work, making you aware of pitfalls and traps to avoid, and by guiding you toward using
              TypeScript’s many capabilities in the most effective ways possible. Whereas a reference book will explain
              the five ways that a language lets you do X, an <em class="calibre3">Effective</em> book will tell you
              which of those five to use and why.</p>

            <p class="author1">TypeScript has evolved rapidly over the past few years, but my hope is that it has
              stabilized enough that the content in this book will remain valid for years to come. This book focuses
              primarily on the language itself, rather than any frameworks or build tools. You won’t find any examples
              of how to use React or Angular with TypeScript, or how to configure TypeScript to work with webpack,
              Babel, or Rollup. The advice in this book should be relevant to all TypeScript users.</p>
          </div>
        </section>













        <section data-pdf-bookmark="Why I Wrote This Book" data-type="sect1" class="praise">
          <div class="praise" id="calibre_link-829">
            <h1 class="calibre16">Why I Wrote This Book</h1>

            <p class="author1">When I first started working at Google, I was given a copy of the third edition of <i
                class="calibre">Effective C++</i>. It was unlike any other programming book I’d read. It made no attempt
              to be accessible to beginners or to be a complete guide to the language. Rather than telling you what the
              different features of C++ did, it told you how you should and should not use them. It did so through
              dozens of short, specific items motivated by concrete examples.</p>

            <p class="author1">The effect of reading all these examples while using the language daily was unmistakable.
              I’d used C++ before, but for the first time I felt comfortable with it and knew how to think about the
              choices it presented me. In later years I would have similar experiences reading <em
                class="calibre3">Effective Java</em> and <em class="calibre3">Effective JavaScript</em>.</p>

            <p class="author1">If you’re already comfortable working in a few different programming languages, then
              diving straight into the odd corners of a new one can be an effective way to challenge your mental models
              and learn what makes it different. I’ve learned an enormous amount about TypeScript from writing this
              book. I hope you’ll have the same experience reading it!</p>
          </div>
        </section>













        <section data-pdf-bookmark="How This Book Is Organized" data-type="sect1" class="praise">
          <div class="praise" id="calibre_link-830">
            <div class="calibre15"></div>
            <h1 class="calibre16">How This Book Is Organized</h1>

            <p class="author1">This book is a collection of “items,” each of which is a short technical essay that gives
              you specific advice about some aspect of TypeScript. The items are grouped thematically into chapters, but
              feel free to jump around and read whichever ones look most interesting to you.</p>

            <p class="author1">Each item’s title conveys the key takeaway. These are the things you should remember as
              you’re using TypeScript, so it’s worth skimming the table of contents to get them in your head. If you’re
              writing documentation, for example, and have a nagging sense that you shouldn’t be writing type
              information, then you’ll know to go read <a data-full-item="1" href="#calibre_link-9"
                class="calibre9">Item 30: Don’t repeat type information in documentation</a>.</p>

            <p class="author1">The text of the item motivates the advice in the title and backs it up with concrete
              examples and technical arguments. Almost every point made in this book is demonstrated through example
              code. I tend to read technical books by looking at the examples and skimming the prose, and I assume you
              do something similar. I hope you’ll read the prose and explanations! But the main points should still come
              across if you skim the examples.</p>

            <p class="author1">After reading the item, you should understand why it will help you use TypeScript more
              effectively. You’ll also know enough to understand if it doesn’t apply to your situation. Scott Meyers,
              the author of <i class="calibre">Effective C++</i>, gives a memorable example of this. He met a team of
              engineers who wrote software that ran on missiles. They knew they could ignore his advice about preventing
              resource leaks, because their programs would always terminate when the missile hit the target and their
              hardware blew up. I’m not aware of any missiles with JavaScript runtimes, but the James Webb Space
              Telescope has one, so you never know!</p>

            <p class="author1">Finally, each item ends with “Things to Remember.” These are a few bullet points that
              summarize the item. If you’re skimming through, you can read these to get a sense for what the item is
              saying and whether you’d like to read more. You should still read the item! But the summary will do in a
              pinch.</p>
          </div>
        </section>













        <section data-pdf-bookmark="Conventions in TypeScript Code Samples" data-type="sect1" class="praise">
          <div class="praise" id="calibre_link-831">
            <h1 class="calibre16">Conventions in TypeScript Code Samples</h1>

            <p class="author1">All<a data-primary="code samples, conventions used in" data-type="indexterm"
                id="calibre_link-165" class="calibre9"></a> code samples are TypeScript except where it’s clear from
              context that they are JSON, GraphQL, or some other language. Much of the experience of using TypeScript
              involves interacting with your editor, which presents some challenges in print. I’ve adopted a few
              conventions to make this work.</p>

            <p class="author1">Most editors surface errors using squiggly underlines. To see the full error message, you
              hover over the underlined text. To indicate an error in a code sample, I put squiggles in a comment line
              under the place where the error occurs:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">let</code> <code class="nx">str</code> <code class="o">=</code> <code class="s">'not a number'</code><code class="p">;</code>
<code class="kd">let</code> <code class="nx">num</code>: <code class="nx">number</code> <code class="o">=</code> <code class="nx">str</code><code class="p">;</code>
 <code class="c">// ~~~ Type 'string' is not assignable to type 'number'</code></pre>

            <p class="author1">I occasionally edit the error messages for clarity and brevity, but I never remove an
              error. If you copy/paste a code sample into your editor, you should get exactly the errors indicated, no
              more no less.</p>

            <p class="author1">To draw attention to the lack of an error, I use <code class="calibre18">// OK</code>:
            </p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">let</code> <code class="nx">str</code> <code class="o">=</code> <code class="s">'not a number'</code><code class="p">;</code>
<code class="kd">let</code> <code class="nx">num</code>: <code class="nx">number</code> <code class="o">=</code> <code class="nx">str</code> <code class="kd">as</code> <code class="nx">any</code><code class="p">;</code>  <code class="c">// OK</code></pre>

            <p class="author1">You should be able to hover over a symbol in your editor to see what TypeScript considers
              its type. To indicate this in text, I use a comment starting with “type is”:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">let</code> <code class="nx">v</code> <code class="o">=</code> <code class="p">{</code><code class="nx">str</code><code class="o">:</code> <code class="s">'hello'</code><code class="p">,</code> <code class="nx">num</code>: <code class="nx">42</code><code class="p">};</code>  <code class="c">// Type is { str: string; num: number; }</code></pre>

            <p class="author1">The type is for the first symbol on the line (<code class="calibre18">v</code> in this
              case) or for the result of a function call:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="s">'four score'</code><code class="p">.</code><code class="nx">split</code><code class="p">(</code><code class="s">' '</code><code class="p">);</code>  <code class="c">// Type is string[]</code></pre>

            <p class="author1">This matches the type you’d see in your editor character for character. In the case of
              function calls you may need to assign to a temporary variable to see the type.</p>

            <p class="author1">I will occasionally introduce no-op statements to indicate the type of a variable on a
              specific line of code:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">foo</code><code class="p">(</code><code class="nx">x</code>: <code class="kd">string</code><code class="o">|</code><code class="kt">string</code><code class="p">[])</code> <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nb">Array</code><code class="p">.</code><code class="nx">isArray</code><code class="p">(</code><code class="nx">x</code><code class="p">))</code> <code class="p">{</code>
    <code class="nx">x</code><code class="p">;</code>  <code class="c">// Type is string[]</code>
  <code class="p">}</code> <code class="kd">else</code> <code class="p">{</code>
    <code class="nx">x</code><code class="p">;</code>  <code class="c">// Type is string</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

            <p class="author1">The <code class="calibre18">x;</code> lines are only there to demonstrate the type in
              each branch of the conditional. You don’t need to (and shouldn’t) include statements like this in your own
              code.</p>

            <p class="author1">Unless it’s otherwise noted or clear from context, code samples are intended to be
              checked with the <code class="calibre18">--strict</code> flag. All samples were verified using TypeScript
              3.7.0-beta.</p>
          </div>
        </section>













        <section data-pdf-bookmark="Typographical Conventions Used in This Book" data-type="sect1" class="praise">
          <div class="praise" id="calibre_link-832">
            <h1 class="calibre16">Typographical Conventions Used in This Book</h1>

            <p class="author1">The following typographical conventions are used in this book:</p>
            <dl class="praise">
              <dt class="calibre19"><em class="calibre3">Italic</em></dt>
              <dd class="calibre20">
                <p class="author1">Indicates new terms, URLs, email addresses, filenames, and file extensions.</p>
              </dd>
              <dt class="calibre19"><code class="calibre18">Constant width</code></dt>
              <dd class="calibre20">
                <p class="author1">Used for program listings, as well as within paragraphs to refer to program elements
                  such as variable or function names, databases, data types, environment variables, statements, and
                  keywords.</p>
              </dd>
              <dt class="calibre19"><strong class="calibre21"><code
                    class="calibre22">Constant width bold</code></strong></dt>
              <dd class="calibre20">
                <p class="author1">Shows commands or other text that should be typed literally by the user.</p>
              </dd>
              <dt class="calibre19"><em class="calibre3"><code class="calibre23">Constant width italic</code></em></dt>
              <dd class="calibre20">
                <p class="author1">Shows text that should be replaced with user-supplied values or by values determined
                  by context.</p>
              </dd>
            </dl>
            <div data-type="tip" class="calibre24">
              <h6 class="calibre25">Tip</h6>
              <p class="author1">This element signifies a tip or suggestion.</p>
            </div>
            <div data-type="note" type="note" class="calibre24">
              <h6 class="calibre25">Note</h6>
              <p class="author1">This element signifies a general note.</p>
            </div>
            <div data-type="warning" type="warning" class="calibre26">
              <h6 class="calibre27">Warning</h6>
              <p class="author1">This element indicates a warning or caution.</p>
            </div>
          </div>
        </section>













        <section data-pdf-bookmark="Using Code Examples" data-type="sect1" class="praise">
          <div class="praise" id="calibre_link-833">
            <h1 class="calibre16">Using Code Examples</h1>

            <p class="author1">Supplemental material (code examples, exercises, etc.) is available for download at <a
                href="https://github.com/danvk/effective-typescript" class="calibre9"><em
                  class="calibre3">https://github.com/danvk/effective-typescript</em></a>.</p>

            <p class="author1">If you have a technical question or a problem using the code examples, please send email
              to <a class="calibre9" href="mailto:bookquestions@oreilly.com"><em
                  class="calibre3">bookquestions@oreilly.com</em></a>.</p>

            <p class="author1">This book is here to help you get your job done. In general, if example code is offered
              with this book, you may use it in your programs and documentation. You do not need to contact us for
              permission unless you’re reproducing a significant portion of the code. For example, writing a program
              that uses several chunks of code from this book does not require permission. Selling or distributing
              examples from O’Reilly books does require permission. Answering a question by citing this book and quoting
              example code does not require permission. Incorporating a significant amount of example code from this
              book into your product’s documentation does require permission.</p>

            <p class="author1">We appreciate, but generally do not require, attribution. An attribution usually includes
              the title, author, publisher, and ISBN. For example: “<em class="calibre3">Effective TypeScript</em> by
              Dan Vanderkam (O’Reilly). Copyright 2020 Dan Vanderkam, 978-1-492-05374-3.”</p>

            <p class="author1">If you feel your use of code examples falls outside fair use or the permission given
              above, feel free to contact us at <a class="calibre9" href="mailto:permissions@oreilly.com"><em
                  class="calibre3">permissions@oreilly.com</em></a>.</p>
          </div>
        </section>













        <section data-pdf-bookmark="O’Reilly Online Learning" data-type="sect1" class="praise">
          <div class="praise" id="calibre_link-834">
            <h1 class="calibre16">O’Reilly Online Learning</h1>
            <div class="calibre24" data-type="note" type="note">
              <h6 class="calibre25">Note</h6>
              <p class="author1">For more than 40 years, <a class="calibre9" href="http://oreilly.com"><em
                    class="calibre3">O’Reilly Media</em></a> has provided technology and business training, knowledge,
                and insight to help companies succeed.</p>
            </div>

            <p class="author1">Our unique network of experts and innovators share their knowledge and expertise through
              books, articles, conferences, and our online learning platform. O’Reilly’s online learning platform gives
              you on-demand access to live training courses, in-depth learning paths, interactive coding environments,
              and a vast collection of text and video from O’Reilly and 200+ other publishers. For more information,
              please visit <a class="calibre9" href="http://oreilly.com"><em
                  class="calibre3">http://oreilly.com</em></a>.</p>
          </div>
        </section>













        <section data-pdf-bookmark="How to Contact Us" data-type="sect1" class="praise">
          <div class="praise" id="calibre_link-835">
            <h1 class="calibre16">How to Contact Us</h1>

            <p class="author1">Please address comments and questions concerning this book to the publisher:</p>
            <ul class="stafflist">
              <li class="calibre10">O’Reilly Media, Inc.</li>
              <li class="calibre10">1005 Gravenstein Highway North</li>
              <li class="calibre10">Sebastopol, CA 95472</li>
              <li class="calibre10">800-998-9938 (in the United States or Canada)</li>
              <li class="calibre10">707-829-0515 (international or local)</li>
              <li class="calibre10">707-829-0104 (fax)</li>
            </ul>

            <p class="author1">You can access the web page for this book, where we list errata, examples, and any
              additional information, at <a href="https://oreil.ly/Effective_TypeScript" class="calibre9"><em
                  class="calibre3">https://oreil.ly/Effective_TypeScript</em></a>.</p>

            <p class="author1">To comment or ask technical questions about this book, send email to <a class="calibre9"
                href="mailto:bookquestions@oreilly.com"><em class="calibre3">bookquestions@oreilly.com</em></a>.</p>

            <p class="author1">For more information about our books, courses, conferences, and news, see our website at
              <a href="http://www.oreilly.com" class="calibre9"><em class="calibre3">http://www.oreilly.com</em></a>.
            </p>

            <p class="author1">Find us on Facebook: <a href="http://facebook.com/oreilly" class="calibre9"><em
                  class="calibre3">http://facebook.com/oreilly</em></a></p>

            <p class="author1">Follow us on Twitter: <a href="http://twitter.com/oreillymedia" class="calibre9"><em
                  class="calibre3">http://twitter.com/oreillymedia</em></a></p>

            <p class="author1">Watch us on YouTube: <a href="http://www.youtube.com/oreillymedia" class="calibre9"><em
                  class="calibre3">http://www.youtube.com/oreillymedia</em></a></p>
          </div>
        </section>













        <section data-pdf-bookmark="Acknowledgments" data-type="sect1" class="praise">
          <div class="praise" id="calibre_link-836">
            <h1 class="calibre16">Acknowledgments</h1>

            <p class="author1">There are many people who helped make this book possible. Thanks to Evan Martin for
              introducing me to TypeScript and showing me how to think about it. To Douwe Osinga for connecting me with
              O’Reilly and being supportive of the project. To Brett Slatkin for advice on structure and for showing me
              that someone I knew could write an <em class="calibre3">Effective</em> book. To Scott Meyers for coming up
              with this format and for his “Effective <em class="calibre3">Effective</em> Books” blog post, which
              provided essential guidance.</p>

            <p class="author1">To my reviewers, Rick Battagline, Ryan Cavanaugh, Boris Cherny, Yakov Fain, Jesse
              Hallett, and Jason Killian. To all my coworkers at Sidewalk who learned TypeScript with me over the years.
              To everyone at O’Reilly who helped make this book happen: Angela Rufino, Jennifer Pollock, Deborah Baker,
              Nick Adams, and Jasmine Kwityn. To the TypeScript NYC crew, Jason, Orta, and Kirill, and to all the
              speakers. Many items were inspired by talks at the Meetup, as described in the following list:</p>

            <ul class="printings">
              <li class="calibre12">
                <p class="author1"><a href="#calibre_link-1" class="calibre9">Item 3</a> was inspired by a blog post of
                  Evan Martin’s that I found particularly enlightening as I was first learning TypeScript.</p>
              </li>
              <li class="calibre12">
                <p class="author1"><a href="#calibre_link-47" class="calibre9">Item 7</a> was inspired by Anders’s talk
                  about structural typing and <code class="calibre18">keyof</code> relationships at TSConf 2018, and by
                  a talk of Jesse Hallett’s at the April 2019 TypeScript NYC Meetup.</p>
              </li>
              <li class="calibre12">
                <p class="author1">Both Basarat’s guide and helpful answers by DeeV and GPicazo on Stack Overflow were
                  essential in writing <a href="#calibre_link-27" class="calibre9">Item 9</a>.</p>
              </li>
              <li class="calibre12">
                <p class="author1"><a href="#calibre_link-757" class="calibre9">Item 10</a> builds on similar advice in
                  Item 4 of <em class="calibre3">Effective JavaScript</em> (Addison-Wesley).</p>
              </li>
              <li class="calibre12">
                <p class="author1">I was inspired to write <a href="#calibre_link-758" class="calibre9">Item 11</a> by
                  mass confusion around this topic at the August 2019 TypeScript NYC Meetup.</p>
              </li>
              <li class="calibre12">
                <p class="author1"><a href="#calibre_link-48" class="calibre9">Item 13</a> was greatly aided by several
                  questions about <code class="calibre18">type</code> vs. <code class="calibre18">interface</code> on
                  Stack Overflow. Jesse Hallett suggested the formulation around extensibility.</p>
              </li>
              <li class="calibre12">
                <p class="author1">Jacob Baskin provided encouragement and early feedback on <a href="#calibre_link-759"
                    class="calibre9">Item 14</a>.</p>
              </li>
              <li class="calibre12">
                <p class="author1"><a href="#calibre_link-11" class="calibre9">Item 19</a> was inspired by several code
                  samples submitted to the r/typescript subreddit.</p>
              </li>
              <li class="calibre12">
                <p class="author1"><a href="#calibre_link-760" class="calibre9">Item 26</a> is based on my own writing
                  on Medium and a talk I gave at the October 2018 TypeScript NYC Meetup.</p>
              </li>
              <li class="calibre12">
                <p class="author1"><a href="#calibre_link-761" class="calibre9">Item 28</a> is based on common advice in
                  Haskell (“make illegal states unrepresentable”). The Air France 447 story is inspired by Jeff Wise’s
                  incredible 2011 article in <em class="calibre3">Popular Mechanics</em>.</p>
              </li>
              <li class="calibre12">
                <p class="author1"><a href="#calibre_link-52" class="calibre9">Item 29</a> is based on an issue I ran
                  into with the Mapbox type declarations. Jason Killian suggested the phrasing in the title.</p>
              </li>
              <li class="calibre12">
                <p class="author1">The advice about naming in <a href="#calibre_link-22" class="calibre9">Item 36</a> is
                  common but this particular formulation was inspired by Dan North’s short article in <em
                    class="calibre3">97 Things Every Programmer Should Know</em> (O’Reilly).</p>
              </li>
              <li class="calibre12">
                <p class="author1"><a href="#calibre_link-762" class="calibre9">Item 37</a> was inspired by Jason
                  Killian’s talk at the very first TypeScript NYC Meetup in September 2017.</p>
              </li>
              <li class="calibre12">
                <p class="author1"><a href="#calibre_link-763" class="calibre9">Item 41</a> is based on the TypeScript
                  2.1 release notes. The term “evolving any” is not widely used outside the TypeScript compiler itself,
                  but I find it useful to have a name for this unusual pattern.</p>
              </li>
              <li class="calibre12">
                <p class="author1"><a href="#calibre_link-40" class="calibre9">Item 42</a> was inspired by a blog post
                  of Jesse Hallett’s. <a href="#calibre_link-764" class="calibre9">Item 43</a> was greatly aided by
                  feedback from Titian Cernicova Dragomir in TypeScript issue #33128.</p>
              </li>
              <li class="calibre12">
                <p class="author1"><a href="#calibre_link-765" class="calibre9">Item 44</a> is based on York Yao’s work
                  on the <code class="calibre18">type-coverage</code> tool. I wanted something like this and it existed!
                </p>
              </li>
              <li class="calibre12">
                <p class="author1"><a href="#calibre_link-766" class="calibre9">Item 46</a> is based on a talk I gave at
                  the December 2017 TypeScript NYC Meetup.</p>
              </li>
              <li class="calibre12">
                <p class="author1"><a href="#calibre_link-767" class="calibre9">Item 50</a> owes a debt of gratitude to
                  David Sheldrick’s post on the <em class="calibre3">Artsy</em> blog on conditional types, which greatly
                  demystified the topic for me.</p>
              </li>
              <li class="calibre12">
                <p class="author1"><a href="#calibre_link-3" class="calibre9">Item 51</a> was inspired by a talk Steve
                  Faulkner aka southpolesteve gave at the February 2019 Meetup.</p>
              </li>
              <li class="calibre12">
                <p class="author1"><a href="#calibre_link-768" class="calibre9">Item 52</a> is based on my own writing
                  on Medium and work on the typings-checker tool, which eventually got folded into dtslint.</p>
              </li>
              <li class="calibre12">
                <p class="author1"><a href="#calibre_link-19" class="calibre9">Item 53</a> was inspired/reinforced by
                  Kat Busch’s Medium post on the various types of enums in TypeScript, as well as Boris Cherny’s
                  writings on this topic in <em class="calibre3">Programming TypeScript</em> (O’Reilly).</p>
              </li>
              <li class="calibre12">
                <p class="author1"><a href="#calibre_link-42" class="calibre9">Item 54</a> was inspired by my own
                  confusion and that of my coworkers on this topic. The definitive explanation is given by Anders on
                  TypeScript PR #12253.</p>
              </li>
              <li class="calibre12">
                <p class="author1">The MDN documentation was essential for writing <a href="#calibre_link-26"
                    class="calibre9">Item 55</a>.</p>
              </li>
              <li class="calibre12">
                <p class="author1"><a href="#calibre_link-769" class="calibre9">Item 56</a> is loosely based on Item 35
                  of <em class="calibre3">Effective JavaScript</em> (Addison-Wesley).</p>
              </li>
              <li class="calibre12">
                <p class="author1"><a href="#calibre_link-39" class="calibre9">Chapter 8</a> is based on my own
                  experience migrating the aging dygraphs library.</p>
              </li>
            </ul>

            <p class="author1">I found many of the blog posts and talks that led to this book through the excellent
              r/typescript subreddit. I’m particularly grateful to developers who provided code samples there which were
              essential for understanding common issues in beginner TypeScript. Thanks to Marius Schulz for the
              TypeScript Weekly newsletter. While it’s only occasionally weekly, it’s always an excellent source of
              material and a great way to keep up with TypeScript. To Anders, Daniel, Ryan, and the whole TypeScript
              team at Microsoft for the talks and all the feedback on issues. Most of my issues were misunderstandings,
              but there is nothing quite so satisfying as filing a bug and immediately seeing Anders Hejlsberg himself
              fix it! Finally, thanks to Alex for being so supportive during this project and so understanding of all
              the working vacations, mornings, evenings, and weekends I needed to complete it.</p>
          </div>
        </section>







      </div>
    </section>
  </div>

  <div data-type="book" class="calibre1" id="calibre_link-770">
    <section class="praise" data-pdf-bookmark="Chapter 1. Getting to Know TypeScript" data-type="chapter"
      type="chapter">
      <div class="praise" id="calibre_link-837">
        <h1 class="calibre14"><span class="calibre">Chapter 1. </span>Getting to Know TypeScript</h1>


        <p class="author1">Before we dive into the details, this chapter helps you understand the big picture of
          TypeScript. What is it and how should you think about it? How does it relate to JavaScript? Are its types
          nullable or are they not? What’s this about <code class="calibre18">any</code>? And ducks?</p>

        <p class="author1">TypeScript<a data-primary="Java" data-secondary="versus TypeScript" data-type="indexterm"
            id="calibre_link-340" class="calibre9"></a> is a bit unusual as a language in that it neither runs in an
          interpreter (as Python and Ruby do) nor<a data-primary="compiling" data-secondary="in TypeScript"
            data-secondary-sortas="TypeScript" data-type="indexterm" id="calibre_link-181" class="calibre9"></a>
          compiles down to a lower-level language (as Java and C do). Instead, it compiles to another high-level
          language, JavaScript. It is this JavaScript that runs, not your TypeScript. So TypeScript’s relationship with
          JavaScript is essential, but it can also be a source of confusion. Understanding this relationship will help
          you be a more effective TypeScript developer.</p>

        <p class="author1">TypeScript’s type system also has some unusual aspects that you should be aware of. Later
          chapters cover the type system in much greater detail, but this one will alert you to some of the surprises
          that it has in store.</p>






        <section data-pdf-bookmark="Item 1: Understand the Relationship Between TypeScript and JavaScript"
          data-type="sect1" class="praise">
          <div class="praise" id="calibre_link-777">
            <h1 class="calibre16">Item 1: Understand the Relationship Between TypeScript and JavaScript</h1>

            <p class="author1">If<a data-primary="TypeScript" data-secondary="relationship to JavaScript"
                data-type="indexterm" id="calibre_link-683" class="calibre9"></a><a data-primary="JavaScript"
                data-secondary="relationship to TypeScript" data-type="indexterm" id="calibre_link-354"
                class="calibre9"></a> you use TypeScript for long, you’ll inevitably hear the phrase “TypeScript is a
              superset of JavaScript” or “TypeScript is a typed superset of JavaScript.” But what does this mean,
              exactly? And what is the relationship between TypeScript and JavaScript? Since these languages are so
              closely linked, a strong understanding of how they relate to each is the foundation for using TypeScript
              well.</p>

            <p class="author1">TypeScript is a superset of JavaScript in a syntactic sense: so long as your JavaScript
              program doesn’t have any syntax errors then it is also a TypeScript program. It’s quite likely that
              TypeScript’s type checker will flag some issues with your code. But this is an independent problem.
              TypeScript will still parse your code and emit JavaScript. (This is another key part of the relationship.
              We’ll explore this more in <a href="#calibre_link-1" class="calibre9">Item 3</a>.)</p>

            <p class="author1">TypeScript<a data-primary=".ts/.tsx extension" data-type="indexterm" id="calibre_link-63"
                class="calibre9"></a><a data-primary=".js/.jsx extension" data-type="indexterm" id="calibre_link-62"
                class="calibre9"></a> files use a <em class="calibre3">.ts</em> (or <em class="calibre3">.tsx</em>)
              extension, rather than the <em class="calibre3">.js</em> (or <em class="calibre3">.jsx</em>) extension of
              a JavaScript file. This doesn’t mean that TypeScript is a completely different language! Since TypeScript
              is a superset of JavaScript, the code in your <em class="calibre3">.js</em> files is already TypeScript.
              Renaming <em class="calibre3">main.js</em> to <em class="calibre3">main.ts</em> doesn’t change that.</p>

            <p class="author1">This<a data-primary="JavaScript" data-secondary="migrating to TypeScript"
                data-type="indexterm" id="calibre_link-348" class="calibre9"></a><a data-primary="TypeScript"
                data-secondary="migrating to" data-type="indexterm" id="calibre_link-679" class="calibre9"></a> is
              enormously helpful if you’re migrating an existing JavaScript codebase to TypeScript. It means that you
              don’t have to rewrite any of your code in another language to start using TypeScript and get the benefits
              it provides. This<a data-primary="Java" data-secondary="rewriting code in" data-type="indexterm"
                id="calibre_link-336" class="calibre9"></a> would not be true if you chose to rewrite your JavaScript in
              a language like Java. This gentle migration path is one of the best features of TypeScript. There will be
              much more to say about this topic in <a data-type="xref" href="#calibre_link-39"
                class="calibre9">Chapter&nbsp;8</a>.</p>

            <p class="author1">All JavaScript programs are TypeScript programs, but the converse is not true: there are
              TypeScript programs which are not JavaScript programs. This is because TypeScript adds additional syntax
              for specifying types. (There are some other bits of syntax it adds, largely for historical reasons. See <a
                href="#calibre_link-19" class="calibre9">Item 53</a>.)</p>

            <p class="author1">For instance, this is a valid TypeScript program:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">greet</code><code class="p">(</code><code class="nx">who</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s">'Hello'</code><code class="p">,</code> <code class="nx">who</code><code class="p">);</code>
<code class="p">}</code></pre>

            <p class="author1">But when you run this through a program like <code class="calibre18">node</code> that
              expects JavaScript, you’ll get an error:</p>

            <pre data-type="programlisting" class="calibre17">function greet(who: string) {
                  ^

SyntaxError: Unexpected token :</pre>

            <p class="author1">The <code class="calibre18">: string</code> is a type annotation that is specific to
              TypeScript. Once you use one, you’ve gone beyond plain JavaScript (see <a data-type="xref"
                href="#calibre_link-771" class="calibre9">Figure&nbsp;1-1</a>).</p>

            <figure class="calibre28">
              <div class="figure" id="calibre_link-771">
                <img alt="efts 0101" src="images/000004.png" class="calibre29" />
                <h6 class="calibre30"><span class="calibre">Figure 1-1. </span>All JavaScript is TypeScript, but not all
                  TypeScript is JavaScript</h6>
              </div>
            </figure>

            <p class="author1">This is not to say that TypeScript doesn’t provide value for plain JavaScript programs.
              It does! For example, this JavaScript program:</p>

            <pre data-code-language="js" data-type="programlisting" id="calibre_link-838"
              class="calibre17"><code class="kd">let</code> <code class="nx">city</code> <code class="o">=</code> <code class="s">'new york city'</code><code class="p">;</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">city</code><code class="p">.</code><code class="nx">toUppercase</code><code class="p">());</code></pre>

            <p class="author1">will throw an error when you run it:</p>

            <pre data-type="programlisting" id="calibre_link-839"
              class="calibre17">TypeError: city.toUppercase is not a function</pre>

            <p class="author1">There are no type annotations in this program, but TypeScript’s type checker is still
              able to spot the problem:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">let</code> <code class="nx">city</code> <code class="o">=</code> <code class="s">'new york city'</code><code class="p">;</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">city</code><code class="p">.</code><code class="nx">toUppercase</code><code class="p">());</code>
              <code class="c">// ~~~~~~~~~~~ Property 'toUppercase' does not exist on type</code>
              <code class="c">//             'string'. Did you mean 'toUpperCase'?</code></pre>

            <p class="author1">You didn’t have to tell TypeScript that the type of <code class="calibre18">city</code>
              was <code class="calibre18">string</code>: it inferred it from the initial value. Type inference is a key
              part of TypeScript and <a data-type="xref" href="#calibre_link-772" class="calibre9">Chapter&nbsp;3</a>
              explores how to use it well.</p>

            <p class="author1">One of the goals of TypeScript’s type system is to detect code that will throw an
              exception at runtime, without having to run your code. When you hear TypeScript described as a “static”
              type system, this is what it refers to. The type checker cannot always spot code that will throw
              exceptions, but it will try.</p>

            <p class="author1">Even if your code doesn’t throw an exception, it still might not do what you intend.
              TypeScript tries to catch some of these issues, too. For example, this JavaScript <span
                class="calibre">program:</span></p>

            <pre data-code-language="js" data-type="programlisting" id="calibre_link-840" class="calibre17"><code class="kd">const</code> <code class="nx">states</code> <code class="o">=</code> <code class="p">[</code>
  <code class="p">{</code><code class="nx">name</code><code class="o">:</code> <code class="s">'Alabama'</code><code class="p">,</code> <code class="nx">capital</code><code class="o">:</code> <code class="s">'Montgomery'</code><code class="p">},</code>
  <code class="p">{</code><code class="nx">name</code><code class="o">:</code> <code class="s">'Alaska'</code><code class="p">,</code>  <code class="nx">capital</code><code class="o">:</code> <code class="s">'Juneau'</code><code class="p">},</code>
  <code class="p">{</code><code class="nx">name</code><code class="o">:</code> <code class="s">'Arizona'</code><code class="p">,</code> <code class="nx">capital</code><code class="o">:</code> <code class="s">'Phoenix'</code><code class="p">},</code>
  <code class="c">// ...</code>
<code class="p">];</code>
<code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="nx">state</code> <code class="kd">of</code> <code class="nx">states</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">state</code><code class="p">.</code><code class="nx">capitol</code><code class="p">);</code>
<code class="p">}</code></pre>

            <p class="author1">will log:</p>

            <pre data-type="programlisting" id="calibre_link-841" class="calibre17">undefined
undefined
undefined</pre>

            <p class="author1">Whoops! What went wrong? This program is valid JavaScript (and hence TypeScript). And it
              ran without throwing any errors. But it clearly didn’t do what you intended. Even without adding type
              annotations, TypeScript’s type checker is able to spot the error (and offer a helpful suggestion):</p>

            <pre data-code-language="ts" data-type="programlisting" id="calibre_link-842" class="calibre17"><code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="nx">state</code> <code class="nx">of</code> <code class="nx">states</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">state</code><code class="p">.</code><code class="nx">capitol</code><code class="p">);</code>
                 <code class="c">// ~~~~~~~ Property 'capitol' does not exist on type</code>
                 <code class="c">//         '{ name: string; capital: string; }'.</code>
                 <code class="c">//         Did you mean 'capital'?</code>
<code class="p">}</code></pre>

            <p class="author1">While TypeScript can catch errors even if you don’t provide type annotations, it’s able
              to do a much more thorough job if you do. This is because type annotations tell TypeScript what your <em
                class="calibre3">intent</em> is, and this lets it spot places where your code’s behavior does not match
              your intent. For example, what if you’d reversed the <code class="calibre18">capital</code>/<code
                class="calibre18">capitol</code> spelling mistake in the previous example?</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">states</code> <code class="o">=</code> <code class="p">[</code>
  <code class="p">{</code><code class="nx">name</code><code class="o">:</code> <code class="s">'Alabama'</code><code class="p">,</code> <code class="nx">capitol</code><code class="o">:</code> <code class="s">'Montgomery'</code><code class="p">},</code>
  <code class="p">{</code><code class="nx">name</code><code class="o">:</code> <code class="s">'Alaska'</code><code class="p">,</code>  <code class="nx">capitol</code><code class="o">:</code> <code class="s">'Juneau'</code><code class="p">},</code>
  <code class="p">{</code><code class="nx">name</code><code class="o">:</code> <code class="s">'Arizona'</code><code class="p">,</code> <code class="nx">capitol</code><code class="o">:</code> <code class="s">'Phoenix'</code><code class="p">},</code>
  <code class="c">// ...</code>
<code class="p">];</code>
<code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="nx">state</code> <code class="nx">of</code> <code class="nx">states</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">state</code><code class="p">.</code><code class="nx">capital</code><code class="p">);</code>
                 <code class="c">// ~~~~~~~ Property 'capital' does not exist on type</code>
                 <code class="c">//         '{ name: string; capitol: string; }'.</code>
                 <code class="c">//         Did you mean 'capitol'?</code>
<code class="p">}</code></pre>

            <p class="author1">The error that was so helpful before now gets it exactly wrong! The problem is that
              you’ve spelled the same property two different ways, and TypeScript doesn’t know which one is right. It
              can guess, but it may not always be correct. The solution is to clarify your intent by explicitly
              declaring the type of <code class="calibre18">states</code>:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">State</code> <code class="p">{</code>
  <code class="nx">name</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">capital</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">const</code> <code class="nx">states</code>: <code class="nx">State</code><code class="p">[]</code> <code class="o">=</code> <code class="p">[</code>
  <code class="p">{</code><code class="nx">name</code><code class="o">:</code> <code class="s">'Alabama'</code><code class="p">,</code> <code class="nx">capitol</code><code class="o">:</code> <code class="s">'Montgomery'</code><code class="p">},</code>
                 <code class="c">// ~~~~~~~~~~~~~~~~~~~~~</code>
  <code class="p">{</code><code class="nx">name</code><code class="o">:</code> <code class="s">'Alaska'</code><code class="p">,</code>  <code class="nx">capitol</code><code class="o">:</code> <code class="s">'Juneau'</code><code class="p">},</code>
                 <code class="c">// ~~~~~~~~~~~~~~~~~</code>
  <code class="p">{</code><code class="nx">name</code><code class="o">:</code> <code class="s">'Arizona'</code><code class="p">,</code> <code class="nx">capitol</code><code class="o">:</code> <code class="s">'Phoenix'</code><code class="p">},</code>
                 <code class="c">// ~~~~~~~~~~~~~~~~~~ Object literal may only specify known</code>
                 <code class="c">//         properties, but 'capitol' does not exist in type</code>
                 <code class="c">//         'State'.  Did you mean to write 'capital'?</code>
  <code class="c">// ...</code>
<code class="p">];</code>
<code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="nx">state</code> <code class="nx">of</code> <code class="nx">states</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">state</code><code class="p">.</code><code class="nx">capital</code><code class="p">);</code>
<code class="p">}</code></pre>

            <p class="author1">Now the errors match the problem and the suggested fix is correct. By spelling out our
              intent, you’ve also helped TypeScript spot other potential problems. For instance, had you only misspelled
              <code class="calibre18">capitol</code> once in the array, there wouldn’t have been an error before. But
              with the type annotation, there is:
            </p>

            <pre data-code-language="ts" data-type="programlisting" id="calibre_link-843" class="calibre17"><code class="kd">const</code> <code class="nx">states</code>: <code class="nx">State</code><code class="p">[]</code> <code class="o">=</code> <code class="p">[</code>
  <code class="p">{</code><code class="nx">name</code><code class="o">:</code> <code class="s">'Alabama'</code><code class="p">,</code> <code class="nx">capital</code><code class="o">:</code> <code class="s">'Montgomery'</code><code class="p">},</code>
  <code class="p">{</code><code class="nx">name</code><code class="o">:</code> <code class="s">'Alaska'</code><code class="p">,</code>  <code class="nx">capitol</code><code class="o">:</code> <code class="s">'Juneau'</code><code class="p">},</code>
                 <code class="c">// ~~~~~~~~~~~~~~~~~ Did you mean to write 'capital'?</code>
  <code class="p">{</code><code class="nx">name</code><code class="o">:</code> <code class="s">'Arizona'</code><code class="p">,</code> <code class="nx">capital</code><code class="o">:</code> <code class="s">'Phoenix'</code><code class="p">},</code>
  <code class="c">// ...</code>
<code class="p">];</code></pre>

            <p class="author1">In terms of the Venn diagram, we can add in a new group of programs: TypeScript programs
              which pass the type checker (see <a data-type="xref" href="#calibre_link-773"
                class="calibre9">Figure&nbsp;1-2</a>).</p>

            <figure class="calibre28">
              <div class="figure" id="calibre_link-773">
                <img alt="efts 0102" src="images/000034.png" class="calibre29" />
                <h6 class="calibre30"><span class="calibre">Figure 1-2. </span>All JavaScript programs are TypeScript
                  programs. But only some JavaScript (and TypeScript) programs pass the type checker.</h6>
              </div>
            </figure>

            <p class="author1">If the statement that “TypeScript is a superset of JavaScript” feels wrong to you, it may
              be because you’re thinking of this third set of programs in the diagram. In practice, this is the most
              relevant one to the day-to-day experience of using TypeScript. Generally when you use TypeScript, you try
              to keep your code passing all the type checks.</p>

            <p class="author1">TypeScript’s type system <em class="calibre3">models</em> the runtime behavior of
              JavaScript. This may result in some surprises if you’re coming from a language with stricter runtime
              checks. For example:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">const</code> <code class="nx">x</code> <code class="o">=</code> <code class="mi">2</code> <code class="o">+</code> <code class="s">'3'</code><code class="p">;</code>  <code class="c">// OK, type is string</code>
<code class="kd">const</code> <code class="nx">y</code> <code class="o">=</code> <code class="s">'2'</code> <code class="o">+</code> <code class="mi">3</code><code class="p">;</code>  <code class="c">// OK, type is string</code></pre>

            <p class="author1">These statements both pass the type checker, even though they are questionable and do
              produce runtime errors in many other languages. But this does model the runtime behavior of JavaScript,
              where both expressions result in the string <code class="calibre18">"23"</code>.</p>

            <p class="author1">TypeScript does draw the line somewhere, though. The type checker flags issues in all of
              these statements, even though they do not throw exceptions at runtime:</p>

            <pre data-code-language="ts" data-type="programlisting" id="calibre_link-844" class="calibre17"><code class="kd">const</code> <code class="nx">a</code> <code class="o">=</code> <code class="kd">null</code> <code class="o">+</code> <code class="mi">7</code><code class="p">;</code>  <code class="c">// Evaluates to 7 in JS</code>
       <code class="c">// ~~~~ Operator '+' cannot be applied to types ...</code>
<code class="kd">const</code> <code class="nx">b</code> <code class="o">=</code> <code class="p">[]</code> <code class="o">+</code> <code class="mi">12</code><code class="p">;</code>  <code class="c">// Evaluates to '12' in JS</code>
       <code class="c">// ~~~~~~~ Operator '+' cannot be applied to types ...</code>
<code class="nx">alert</code><code class="p">(</code><code class="s">'Hello'</code><code class="p">,</code> <code class="s">'TypeScript'</code><code class="p">);</code>  <code class="c">// alerts "Hello"</code>
            <code class="c">// ~~~~~~~~~~~~ Expected 0-1 arguments, but got 2</code></pre>

            <p class="author1">The guiding principle of TypeScript’s type system is that it should model JavaScript’s
              runtime behavior. But in all of these cases, TypeScript considers it more likely that the odd usage is the
              result of an error than the developer’s intent, so it goes beyond simply modeling the runtime behavior. We
              saw another example of this in the <code class="calibre18">capital</code>/<code
                class="calibre18">capitol</code> example, where the program didn’t throw (it logged <code
                class="calibre18">undefined</code>) but the type checker still flagged an error.</p>

            <p class="author1">How does TypeScript decide when to model JavaScript’s runtime behavior and when to go
              beyond it? Ultimately this is a matter of taste. By adopting TypeScript you’re trusting the judgment of
              the team that builds it. If you enjoy adding <code class="calibre18">null</code> and <code
                class="calibre18">7</code> or <code class="calibre18">[]</code> and <code class="calibre18">12</code>,
              or calling functions with superfluous arguments, then TypeScript might not be for you!</p>

            <p class="author1">If your program type checks, could it still throw an error at runtime? The answer is
              “yes.” Here’s an example:</p>

            <pre data-code-language="ts" data-type="programlisting" id="calibre_link-845"
              class="calibre17"><code class="kd">const</code> <code class="nx">names</code> <code class="o">=</code> <code class="p">[</code><code class="s">'Alice'</code><code class="p">,</code> <code class="s">'Bob'</code><code class="p">];</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">names</code><code class="p">[</code><code class="mi">2</code><code class="p">].</code><code class="nx">toUpperCase</code><code class="p">());</code></pre>

            <p class="author1">When you run this, it throws:</p>

            <pre data-type="programlisting" id="calibre_link-846"
              class="calibre17">TypeError: Cannot read property 'toUpperCase' of undefined</pre>

            <p class="author1">TypeScript assumed the array access would be within bounds, but it was not. The result
              was an exception.</p>

            <p class="author1">Uncaught errors also frequently come up when you use the <code
                class="calibre18">any</code> type, which we’ll discuss in <a href="#calibre_link-51"
                class="calibre9">Item 5</a> and in more detail in <a data-type="xref" href="#calibre_link-774"
                class="calibre9">Chapter&nbsp;5</a>.</p>

            <p class="author1">The root cause of these exceptions is that TypeScript’s understanding of a value’s type
              and reality have diverged. A type system which can guarantee the accuracy of its static types is said to
              be <em class="calibre3">sound</em>. TypeScript’s type system is very much not sound, nor was it ever
              intended to be. If soundness is important to you, you may want to look at other languages like Reason or
              Elm. While these do offer more guarantees of runtime safety, this comes at a cost: neither is a superset
              of JavaScript, so migration will be more complicated.</p>








            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-847">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">TypeScript is a superset of JavaScript. In other words, all JavaScript programs
                      are already TypeScript programs. TypeScript has some syntax of its own, so TypeScript programs are
                      not, in general, valid JavaScript programs.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">TypeScript adds a type system that models JavaScript’s runtime behavior and tries
                      to spot code which will throw exceptions at runtime. But you shouldn’t expect it to flag every
                      exception. It is possible for code to pass the type checker but still throw at runtime.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">While TypeScript’s type system largely models JavaScript behavior, there are some
                      constructs that JavaScript allows but TypeScript chooses to bar, such as calling functions with
                      the wrong number of arguments. This is largely a matter of taste.<a data-primary=""
                        data-startref="TSjava01" data-type="indexterm" id="calibre_link-684" class="calibre9"></a><a
                        data-primary="" data-startref="JStype01" data-type="indexterm" id="calibre_link-355"
                        class="calibre9"></a></p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>













        <section data-pdf-bookmark="Item 2: Know Which TypeScript Options You’re Using" data-type="sect1"
          class="praise">
          <div class="praise" id="calibre_link-25">
            <h1 class="calibre16">Item 2: Know Which TypeScript Options You’re Using</h1>

            <p class="author1">Does<a data-primary="TypeScript" data-secondary="configuration settings"
                data-type="indexterm" id="calibre_link-673" class="calibre9"></a><a
                data-primary="configuration settings" data-type="indexterm" id="calibre_link-183"
                class="calibre9"></a><a data-primary="tsconfig.json" data-secondary="knowing which options you’re using"
                data-type="indexterm" id="calibre_link-545" class="calibre9"></a><a data-primary="noImplicitAny"
                data-type="indexterm" id="calibre_link-419" class="calibre9"></a><a data-primary="strictNullChecks"
                data-type="indexterm" id="calibre_link-508" class="calibre9"></a> this code pass the type checker?</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">function</code> <code class="nx">add</code><code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code><code class="p">;</code>
<code class="p">}</code>
<code class="nx">add</code><code class="p">(</code><code class="mi">10</code><code class="p">,</code> <code class="kd">null</code><code class="p">);</code></pre>

            <p class="author1">Without knowing which options you’re using, it’s impossible to say! The TypeScript
              compiler has an enormous set of these, nearly 100 at the time of this writing.</p>

            <p class="author1">They can be set via the command line:</p>
            <pre data-type="programlisting"
              class="calibre17">$ <strong class="calibre32">tsc --noImplicitAny program.ts</strong></pre>

            <p class="author1">or via a configuration file, <em class="calibre3">tsconfig.json</em>:</p>

            <pre data-code-language="json" data-type="programlisting" class="calibre17"><code class="p">{</code>
  <code class="nt">"compilerOptions"</code><code class="p">:</code> <code class="p">{</code>
    <code class="nt">"noImplicitAny"</code><code class="p">:</code> <code class="kd">true</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

            <p class="author1">You should prefer the configuration file. It ensures that your coworkers and tools all
              know exactly how you plan to use TypeScript. You can create one by running <code
                class="calibre18">tsc --init</code>.</p>

            <p class="author1">Many of TypeScript’s configuration settings control where it looks for source files and
              what sort of output it generates. But a few control core aspects of the language itself. These are
              high-level design choices that most languages do not leave to their users. TypeScript can feel like a very
              different language depending on how it is configured. To use it effectively, you should understand the
              most important of these settings: <span class="calibre"><code
                  class="calibre18">noImplicitAny</code></span> and <code class="calibre18">strictNullChecks</code>.</p>

            <p class="author1"><code class="calibre18">noImplicitAny</code> controls whether variables must have known
              types. This code is valid when <code class="calibre18">noImplicitAny</code> is off:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">add</code><code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">If you mouse over the <code class="calibre18">add</code> symbol in your editor, it will
              reveal what TypeScript has inferred about the type of that function:</p>

            <pre data-type="programlisting" class="calibre17">function add(a: any, b: any): any</pre>

            <p class="author1">The <code class="calibre18">any</code> types effectively disable the type checker for
              code involving these parameters. <code class="calibre18">any</code> is a useful tool, but it should be
              used with caution. For much more on <code class="calibre18">any</code>, see <a href="#calibre_link-51"
                class="calibre9">Item 5</a> and <a data-type="xref" href="#calibre_link-772"
                class="calibre9">Chapter&nbsp;3</a>.</p>

            <p class="author1">These<a data-primary="implicit anys" data-type="indexterm" id="calibre_link-307"
                class="calibre9"></a> are called <em class="calibre3">implicit <code class="calibre23">any</code>s</em>
              because you never wrote the word “any” but still wound up with dangerous <code
                class="calibre18">any</code> types. This becomes an error if you set the <code
                class="calibre18">noImplicitAny</code> option:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">add</code><code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">)</code> <code class="p">{</code>
          <code class="c">// ~    Parameter 'a' implicitly has an 'any' type</code>
          <code class="c">//    ~ Parameter 'b' implicitly has an 'any' type</code>
  <code class="kd">return</code> <code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">These errors can be fixed by explicitly writing type declarations, either <code
                class="calibre18">: any</code> or a more specific type:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">add</code><code class="p">(</code><code class="nx">a</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">b</code>: <code class="nx">number</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">TypeScript is the most helpful when it has type information, so you should be sure to set
              <code class="calibre18">noImplicitAny</code> whenever possible. Once you grow accustomed to all variables
              having types, TypeScript without <code class="calibre18">noImplicitAny</code> feels almost like a
              different <span class="calibre">language.</span>
            </p>

            <p class="author1">For new projects, you should start with <code class="calibre18">noImplicitAny</code> on,
              so that you write the types as you write your code. This will help TypeScript spot problems, improve the
              readability of your code, and enhance your development experience (see <a href="#calibre_link-775"
                class="calibre9">Item 6</a>). Leaving <code class="calibre18">noImplicitAny</code> off is only
              appropriate if you’re transitioning a project from JavaScript to TypeScript (see <a data-type="xref"
                href="#calibre_link-39" class="calibre9">Chapter&nbsp;8</a>).</p>

            <p class="author1"><code class="calibre18">strictNullChecks</code> controls whether <code
                class="calibre18">null</code> and <code class="calibre18">undefined</code> are permissible values in
              every type.</p>

            <p class="author1">This code is valid when <code class="calibre18">strictNullChecks</code> is off:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">const</code> <code class="nx">x</code>: <code class="nx">number</code> <code class="o">=</code> <code class="kd">null</code><code class="p">;</code>  <code class="c">// OK, null is a valid number</code></pre>

            <p class="author1">but triggers an error when you turn <code class="calibre18">strictNullChecks</code> on:
            </p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">x</code>: <code class="nx">number</code> <code class="o">=</code> <code class="kd">null</code><code class="p">;</code>
<code class="c">//    ~ Type 'null' is not assignable to type 'number'</code></pre>

            <p class="author1">A similar error would have occurred had you used <code class="calibre18">undefined</code>
              instead of <code class="calibre18">null</code>.</p>

            <p class="author1">If you mean to allow <code class="calibre18">null</code>, you can fix the error by making
              your intent explicit:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">const</code> <code class="nx">x</code>: <code class="nx">number</code> <code class="o">|</code> <code class="nx">null</code><code class="o"> = </code><code class="kd">null</code><code class="p">;</code></pre>

            <p class="author1">If you do not wish to permit <code class="calibre18">null</code>, you’ll need to track
              down where it came from and add either a check or an assertion:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17">   <code class="kd">const</code> <code class="nx">el</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s">'status'</code><code class="p">);</code>
   <code class="nx">el</code><code class="p">.</code><code class="nx">textContent</code> <code class="o">=</code> <code class="s">'Ready'</code><code class="p">;</code>
<code class="c">// ~~ Object is possibly 'null'</code>

   <code class="kd">if</code> <code class="p">(</code><code class="nx">el</code><code class="p">)</code> <code class="p">{</code>
     <code class="nx">el</code><code class="p">.</code><code class="nx">textContent</code> <code class="o">=</code> <code class="s">'Ready'</code><code class="p">;</code>  <code class="c">// OK, null has been excluded</code>
   <code class="p">}</code>
   <code class="nx">el</code><code class="o">!</code><code class="p">.</code><code class="nx">textContent</code> <code class="o">=</code> <code class="s">'Ready'</code><code class="p">;</code>  <code class="c">// OK, we've asserted that el is non-null</code></pre>

            <p class="author1"><code class="calibre18">strictNullChecks</code> is tremendously helpful for catching
              errors involving <code class="calibre18">null</code> and <code class="calibre18">undefined</code> values,
              but it does increase the difficulty of using the language. If you’re starting a new project, try setting
              <code class="calibre18">strictNullChecks</code>. But if you’re new to the language or migrating a
              JavaScript codebase, you may elect to leave it off. You should certainly set <code
                class="calibre18">noImplicitAny</code> before you set <code class="calibre18">strictNullChecks</code>.
            </p>

            <p class="author1">If you choose to work without <code class="calibre18">strictNullChecks</code>, keep an
              eye out for the dreaded “undefined is not an object” runtime error. Every one of these is a reminder that
              you should consider enabling stricter checking. Changing this setting will only get harder as your project
              grows, so try not to wait too long before enabling it.</p>

            <p class="author1">There<a data-primary="noImplicitThis" data-type="indexterm" id="calibre_link-423"
                class="calibre9"></a> are many other settings that affect language semantics (e.g., <code
                class="calibre18">noImplicitThis</code> and <code class="calibre18">strictFunctionTypes</code>), but
              these are minor compared to <code class="calibre18">noImplicitAny</code> and <code
                class="calibre18">strictNullChecks</code>. To enable all of these checks, turn on the <code
                class="calibre18">strict</code> setting. TypeScript is able to catch the most errors with <code
                class="calibre18">strict</code>, so this is where you eventually want to wind up.</p>

            <p class="author1">Know<a data-primary="compiling" data-secondary="compiler options" data-type="indexterm"
                id="calibre_link-175" class="calibre9"></a> which options you’re using! If a coworker shares a
              TypeScript example and you’re unable to reproduce their errors, make sure your compiler options are the
              same.</p>








            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-848">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">The TypeScript compiler includes several settings which affect core aspects of
                      the language.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Configure TypeScript using <em class="calibre3">tsconfig.json</em> rather than
                      command-line options.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Turn on <code class="calibre18">noImplicitAny</code> unless you are transitioning
                      a JavaScript project to <span class="calibre">TypeScript.</span></p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Use <code class="calibre18">strictNullChecks</code> to prevent “undefined is not
                      an object”-style runtime errors.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Aim to enable <code class="calibre18">strict</code> to get the most thorough
                      checking that TypeScript can offer.<a data-primary="" data-startref="strict01"
                        data-type="indexterm" id="calibre_link-509" class="calibre9"></a><a data-primary=""
                        data-startref="noimp01" data-type="indexterm" id="calibre_link-420" class="calibre9"></a><a
                        data-primary="" data-startref="config01" data-type="indexterm" id="calibre_link-184"
                        class="calibre9"></a><a data-primary="" data-startref="TSconfig01" data-type="indexterm"
                        id="calibre_link-674" class="calibre9"></a></p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>













        <section data-pdf-bookmark="Item 3: Understand That Code Generation Is Independent of Types" data-type="sect1"
          class="praise">
          <div class="praise" id="calibre_link-1">
            <h1 class="calibre16">Item 3: Understand That Code Generation Is Independent of Types</h1>

            <p class="author1">At<a data-primary="TypeScript compiler (tsc)" data-secondary="functions of"
                data-type="indexterm" id="calibre_link-699" class="calibre9"></a><a
                data-primary="code generation, independent of types" data-type="indexterm" id="calibre_link-163"
                class="calibre9"></a><a data-primary="transpiling" data-seealso="compiling" data-type="indexterm"
                id="calibre_link-540" class="calibre9"></a> a high level, <code class="calibre18">tsc</code> (the
              TypeScript compiler) does two things:</p>

            <ul class="printings">
              <li class="calibre12">
                <p class="author1">It converts next-generation TypeScript/JavaScript to an older version of JavaScript
                  that works in browsers (“transpiling”).</p>
              </li>
              <li class="calibre12">
                <p class="author1">It checks your code for type errors.</p>
              </li>
            </ul>

            <p class="author1">What’s surprising is that these two behaviors are entirely independent of one another.
              Put another way, the types in your code cannot affect the JavaScript that TypeScript emits. Since it’s
              this JavaScript that gets executed, this means that your types can’t affect the way your code runs.</p>

            <p class="author1">This has some surprising implications and should inform your expectations about what
              TypeScript can and cannot do for you.</p>








            <section class="praise" data-pdf-bookmark="Code with Type Errors Can Produce Output" data-type="sect2">
              <div class="praise" id="calibre_link-849">
                <h2 class="calibre31">Code with Type Errors Can Produce Output</h2>

                <p class="author1">Because<a data-primary="compiling" data-secondary="compiling versus type checking"
                    data-type="indexterm" id="calibre_link-179" class="calibre9"></a><a
                    data-primary="TypeScript compiler (tsc)" data-secondary="code generation and type checking"
                    data-type="indexterm" id="calibre_link-697" class="calibre9"></a> code output is independent of type
                  checking, it follows that code with type errors can produce output!</p>
                <pre data-type="programlisting" class="calibre17">$ <strong class="calibre32">cat test.ts</strong>
let x = 'hello';
x = 1234;
$ <strong class="calibre32">tsc test.ts</strong>
test.ts:2:1 - error TS2322: Type '1234' is not assignable to type 'string'

2 x = 1234;
  ~

$ <strong class="calibre32">cat test.js</strong>
var x = 'hello';
x = 1234;</pre>

                <p class="author1">This can be quite surprising if you’re coming from a language like C or<a
                    data-primary="Java" data-secondary="type checking and output in" data-type="indexterm"
                    id="calibre_link-339" class="calibre9"></a> Java where type checking and output go hand in hand. You
                  can think of all TypeScript errors as being similar to warnings in those languages: it’s likely that
                  they indicate a problem and are worth investigating, but they won’t stop the build.</p>
                <aside class="less_space" data-type="sidebar" type="sidebar">
                  <div class="sidebar" id="calibre_link-850">
                    <h5 class="calibre33">Compiling and Type Checking</h5>
                    <p class="author1">This is likely the source of some sloppy language that is common around
                      TypeScript. You’ll often hear people say that their TypeScript “doesn’t compile” as a way of
                      saying that it has errors. But this isn’t technically correct! Only the code generation is
                      “compiling.” So long as your TypeScript is valid JavaScript (and often even if it isn’t), the
                      TypeScript compiler will produce output. It’s better to say that your code has errors, or that it
                      “doesn’t type check.”</p>
                  </div>
                </aside>

                <p class="author1">Code emission in the presence of errors is helpful in practice. If you’re building a
                  web application, you may know that there are problems with a particular part of it. But because
                  TypeScript will still generate code in the presence of errors, you can test the other parts of your
                  application before you fix them.</p>

                <p class="author1">You should aim for zero errors when you commit code, lest you fall into the trap of
                  having to remember what is an expected or unexpected error. If you want to disable output on errors,
                  you can use the <code class="calibre18">noEmitOnError</code> option in <em
                    class="calibre3">tsconfig.json</em>, or the equivalent in your build tool.<a data-primary=""
                    data-startref="tsconfig01" data-type="indexterm" id="calibre_link-546" class="calibre9"></a></p>
              </div>
            </section>













            <section class="praise" data-pdf-bookmark="You Cannot Check TypeScript Types at Runtime" data-type="sect2">
              <div class="praise" id="calibre_link-851">
                <h2 class="calibre31">You Cannot Check TypeScript Types at Runtime</h2>

                <p class="author1">You<a data-primary="runtime" data-secondary="inability to check TypeScript at"
                    data-type="indexterm" id="calibre_link-499" class="calibre9"></a> may be tempted to write code like
                  this:</p>

                <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Square</code> <code class="p">{</code>
  <code class="nx">width</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">interface</code> <code class="nx">Rectangle</code> <code class="kd">extends</code> <code class="nx">Square</code> <code class="p">{</code>
  <code class="nx">height</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">type</code> <code class="nx">Shape</code> <code class="o">=</code> <code class="nx">Square</code> <code class="o">|</code> <code class="nx">Rectangle</code><code class="p">;</code>

<code class="kd">function</code> <code class="nx">calculateArea</code><code class="p">(</code><code class="nx">shape</code>: <code class="nx">Shape</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">shape</code> <code class="kd">instanceof</code> <code class="nx">Rectangle</code><code class="p">)</code> <code class="p">{</code>
                    <code class="c">// ~~~~~~~~~ 'Rectangle' only refers to a type,</code>
                    <code class="c">//           but is being used as a value here</code>
    <code class="kd">return</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">width</code> <code class="o">*</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">height</code><code class="p">;</code>
                    <code class="c">//         ~~~~~~ Property 'height' does not exist</code>
                    <code class="c">//                on type 'Shape'</code>
  <code class="p">}</code> <code class="kd">else</code> <code class="p">{</code>
    <code class="kd">return</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">width</code> <code class="o">*</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">width</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

                <p class="author1">The <code class="calibre18">instanceof</code> check happens at runtime, but <code
                    class="calibre18">Rectangle</code> is a type and so it cannot affect the runtime behavior of the
                  code. TypeScript types are “erasable”: part of compilation to JavaScript is simply removing all the
                  <code class="calibre18">interface</code>s, <code class="calibre18">type</code>s, and type annotations
                  from your code.
                </p>

                <p class="author1">To ascertain the type of shape you’re dealing with, you’ll need some way to
                  reconstruct its type at runtime. In this case you can check for the presence of a <code
                    class="calibre18">height</code> property:</p>

                <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">calculateArea</code><code class="p">(</code><code class="nx">shape</code>: <code class="nx">Shape</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="s">'height'</code> <code class="kd">in</code> <code class="nx">shape</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">shape</code><code class="p">;</code>  <code class="c">// Type is Rectangle</code>
    <code class="kd">return</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">width</code> <code class="o">*</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">height</code><code class="p">;</code>
  <code class="p">}</code> <code class="kd">else</code> <code class="p">{</code>
    <code class="nx">shape</code><code class="p">;</code>  <code class="c">// Type is Square</code>
    <code class="kd">return</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">width</code> <code class="o">*</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">width</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

                <p class="author1">This works because the property check only involves values available at runtime, but
                  still allows the type checker to refine <code class="calibre18">shape</code>’s type to <code
                    class="calibre18">Rectangle</code>.</p>

                <p class="author1">Another way would have been to introduce a “tag” to explicitly store the type in a
                  way that’s available at runtime:</p>

                <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Square</code> <code class="p">{</code>
  <code class="nx">kind</code><code class="o">:</code> <code class="s">'square'</code><code class="p">;</code>
  <code class="nx">width</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">interface</code> <code class="nx">Rectangle</code> <code class="p">{</code>
  <code class="nx">kind</code><code class="o">:</code> <code class="s">'rectangle'</code><code class="p">;</code>
  <code class="nx">height</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">width</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">type</code> <code class="nx">Shape</code> <code class="o">=</code> <code class="nx">Square</code> <code class="o">|</code> <code class="nx">Rectangle</code><code class="p">;</code>

<code class="kd">function</code> <code class="nx">calculateArea</code><code class="p">(</code><code class="nx">shape</code>: <code class="nx">Shape</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">shape</code><code class="p">.</code><code class="nx">kind</code> <code class="o">===</code> <code class="s">'rectangle'</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">shape</code><code class="p">;</code>  <code class="c">// Type is Rectangle</code>
    <code class="kd">return</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">width</code> <code class="o">*</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">height</code><code class="p">;</code>
  <code class="p">}</code> <code class="kd">else</code> <code class="p">{</code>
    <code class="nx">shape</code><code class="p">;</code>  <code class="c">// Type is Square</code>
    <code class="kd">return</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">width</code> <code class="o">*</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">width</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

                <p class="author1">The<a data-primary="tagged unions" data-secondary="example of" data-type="indexterm"
                    id="calibre_link-527" class="calibre9"></a> <code class="calibre18">Shape</code> type here is an
                  example of a “tagged union.” Because they make it so easy to recover type information at runtime,
                  tagged unions are ubiquitous in TypeScript.</p>

                <p class="author1">Some constructs introduce both a type (which is not available at runtime) and a value
                  (which is). The <code class="calibre18">class</code> keyword is one of these. Making <code
                    class="calibre18">Square</code> and <code class="calibre18">Rectangle</code> classes would have been
                  another way to fix the error:</p>

                <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">class</code> <code class="nx">Square</code> <code class="p">{</code>
  <code class="kd">constructor</code><code class="p">(</code><code class="kd">public</code> <code class="nx">width</code>: <code class="nx">number</code><code class="p">)</code> <code class="p">{}</code>
<code class="p">}</code>
<code class="kd">class</code> <code class="nx">Rectangle</code> <code class="kd">extends</code> <code class="nx">Square</code> <code class="p">{</code>
  <code class="kd">constructor</code><code class="p">(</code><code class="kd">public</code> <code class="nx">width</code>: <code class="nx">number</code><code class="p">,</code> <code class="kd">public</code> <code class="nx">height</code>: <code class="nx">number</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">super</code><code class="p">(</code><code class="nx">width</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code>
<code class="kd">type</code> <code class="nx">Shape</code> <code class="o">=</code> <code class="nx">Square</code> <code class="o">|</code> <code class="nx">Rectangle</code><code class="p">;</code>

<code class="kd">function</code> <code class="nx">calculateArea</code><code class="p">(</code><code class="nx">shape</code>: <code class="nx">Shape</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">shape</code> <code class="kd">instanceof</code> <code class="nx">Rectangle</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">shape</code><code class="p">;</code>  <code class="c">// Type is Rectangle</code>
    <code class="kd">return</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">width</code> <code class="o">*</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">height</code><code class="p">;</code>
  <code class="p">}</code> <code class="kd">else</code> <code class="p">{</code>
    <code class="nx">shape</code><code class="p">;</code>  <code class="c">// Type is Square</code>
    <code class="kd">return</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">width</code> <code class="o">*</code> <code class="nx">shape</code><code class="p">.</code><code class="nx">width</code><code class="p">;</code>  <code class="c">// OK</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

                <p class="author1">This works because <code class="calibre18">class Rectangle</code> introduces both a
                  type and a value, whereas <code class="calibre18">interface</code> only introduced a type.</p>

                <p class="author1">The <code class="calibre18">Rectangle</code> in <code
                    class="calibre18">type Shape = Square | Rectangle</code> refers to the <em
                    class="calibre3">type</em>, but the <code class="calibre18">Rectangle</code> in <code
                    class="calibre18">shape instanceof Rectangle</code> refers to the <em class="calibre3">value</em>.
                  This distinction is important to understand but can be quite subtle. See <a href="#calibre_link-776"
                    class="calibre9">Item 8</a>.</p>
              </div>
            </section>













            <section class="praise" data-pdf-bookmark="Type Operations Cannot Affect Runtime Values" data-type="sect2">
              <div class="praise" id="calibre_link-852">
                <h2 class="calibre31">Type Operations Cannot Affect Runtime Values</h2>

                <p class="author1">Suppose<a data-primary="runtime" data-secondary="type operations and runtime values"
                    data-type="indexterm" id="calibre_link-501" class="calibre9"></a> you have a value that could be a
                  string or a number and you’d like to normalize it so that it’s always a number. Here’s a misguided
                  attempt that the type checker accepts:</p>

                <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">asNumber</code><code class="p">(</code><code class="nx">val</code>: <code class="nx">number</code> <code class="o">|</code> <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="kt">number</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">val</code> <code class="kd">as</code> <code class="kt">number</code><code class="p">;</code>
<code class="p">}</code></pre>

                <p class="author1">Looking at the generated JavaScript makes it clear what this function really does:
                </p>

                <pre data-code-language="js" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">asNumber</code><code class="p">(</code><code class="nx">val</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">val</code><code class="p">;</code>
<code class="p">}</code></pre>

                <p class="author1">There is no conversion going on whatsoever. The <code
                    class="calibre18">as number</code> is a type operation, so it cannot affect the runtime behavior of
                  your code. To normalize the value you’ll need to check its runtime type and do the conversion using
                  JavaScript constructs:</p>

                <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">asNumber</code><code class="p">(</code><code class="nx">val</code>: <code class="nx">number</code> <code class="o">|</code> <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="kt">number</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="kd">typeof</code><code class="p">(</code><code class="nx">val</code><code class="p">)</code> <code class="o">===</code> <code class="s">'string'</code> <code class="o">?</code> <code class="nb">Number</code><code class="p">(</code><code class="nx">val</code><code class="p">)</code> <code class="o">:</code> <code class="nx">val</code><code class="p">;</code>
<code class="p">}</code></pre>

                <p class="author1">(<code class="calibre18">as number</code> is<a data-primary="type assertion"
                    data-secondary="example of" data-type="indexterm" id="calibre_link-564" class="calibre9"></a> a <em
                    class="calibre3">type assertion</em>. For more on when it’s appropriate to use these, see <a
                    href="#calibre_link-27" class="calibre9">Item 9</a>.)</p>
              </div>
            </section>













            <section class="praise" data-pdf-bookmark="Runtime Types May Not Be the Same as Declared Types"
              data-type="sect2">
              <div class="praise" id="calibre_link-853">
                <h2 class="calibre31">Runtime Types May Not Be the Same as Declared Types</h2>

                <p class="author1">Could<a data-primary="runtime" data-secondary="runtime types versus declared types"
                    data-type="indexterm" id="calibre_link-500" class="calibre9"></a> this function ever hit the final
                  <code class="calibre18">console.log</code>?
                </p>

                <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">setLightSwitch</code><code class="p">(</code><code class="nx">value</code>: <code class="nx">boolean</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">switch</code> <code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">case</code> <code class="kd">true</code><code class="o">:</code>
      <code class="nx">turnLightOn</code><code class="p">();</code>
      <code class="kd">break</code><code class="p">;</code>
    <code class="kd">case</code> <code class="kd">false</code><code class="o">:</code>
      <code class="nx">turnLightOff</code><code class="p">();</code>
      <code class="kd">break</code><code class="p">;</code>
    <code class="kd">default</code><code class="o">:</code>
      <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s">`I'm afraid I can't do that.`</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

                <p class="author1">TypeScript usually flags dead code, but it does not complain about this, even with
                  the <code class="calibre18">strict</code> option. How could you hit this branch?</p>

                <p class="author1">The<a data-primary="declared types" data-type="indexterm" id="calibre_link-208"
                    class="calibre9"></a> key is to remember that <code class="calibre18">boolean</code> is the <em
                    class="calibre3">declared</em> type. Because it is a TypeScript type, it goes away at runtime. In
                  JavaScript code, a user might inadvertently call <code class="calibre18">setLightSwitch</code> with a
                  value like <code class="calibre18">"ON"</code>.</p>

                <p class="author1">There are ways to trigger this code path in pure TypeScript, too. Perhaps the
                  function is called with a value which comes from a network call:</p>

                <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">LightApiResponse</code> <code class="p">{</code>
  <code class="nx">lightSwitchValue</code>: <code class="nx">boolean</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">async</code> <code class="kd">function</code> <code class="nx">setLight() {</code>
  <code class="kd">const</code> <code class="nx">response</code> <code class="o">=</code> <code class="kd">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="s">'/light'</code><code class="p">);</code>
  <code class="kd">const</code> <code class="nx">result</code>: <code class="nx">LightApiResponse</code> <code class="o">=</code> <code class="kd">await</code> <code class="nx">response</code><code class="p">.</code><code class="nx">json</code><code class="p">();</code>
  <code class="nx">setLightSwitch</code><code class="p">(</code><code class="nx">result</code><code class="p">.</code><code class="nx">lightSwitchValue</code><code class="p">);</code>
<code class="p">}</code></pre>

                <p class="author1">You’ve declared that the result of the <code class="calibre18">/light</code> request
                  is <code class="calibre18">LightApiResponse</code>, but nothing enforces this. If you misunderstood
                  the API and <code class="calibre18">lightSwitchValue</code> is really a <code
                    class="calibre18">string</code>, then a string will be passed to <code
                    class="calibre18">setLightSwitch</code> at runtime. Or perhaps the API changed after you deployed.
                </p>

                <p class="author1">TypeScript can get quite confusing when your runtime types don’t match the declared
                  types, and this is a situation you should avoid whenever you can. But be aware that it’s possible for
                  a value to have types other than the ones you’ve declared.</p>
              </div>
            </section>













            <section class="praise" data-pdf-bookmark="You Cannot Overload a Function Based on TypeScript Types"
              data-type="sect2">
              <div class="praise" id="calibre_link-854">
                <h2 class="calibre31">You Cannot Overload a Function Based on TypeScript Types</h2>

                <p class="author1">Languages<a data-primary="C++" data-type="indexterm" id="calibre_link-140"
                    class="calibre9"></a><a data-primary="functions" data-secondary="overloading" data-type="indexterm"
                    id="calibre_link-285" class="calibre9"></a><a data-primary="overloading functions"
                    data-type="indexterm" id="calibre_link-453" class="calibre9"></a> like C++ allow you to define
                  multiple versions of a function that differ only in the types of their parameters. This is called
                  “function overloading.” Because the runtime behavior of your code is independent of its TypeScript
                  types, this construct isn’t possible in TypeScript:</p>

                <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">add</code><code class="p">(</code><code class="nx">a</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">b</code>: <code class="nx">number</code><code class="p">)</code> <code class="p">{</code> <code class="kd">return</code> <code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code><code class="p">;</code> <code class="p">}</code>
      <code class="c">// ~~~ Duplicate function implementation</code>
<code class="kd">function</code> <code class="nx">add</code><code class="p">(</code><code class="nx">a</code>: <code class="kd">string</code><code class="p">,</code> <code class="nx">b</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{</code> <code class="kd">return</code> <code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code><code class="p">;</code> <code class="p">}</code>
      <code class="c">// ~~~ Duplicate function implementation</code></pre>

                <p class="author1">TypeScript <em class="calibre3">does</em> provide a facility for overloading
                  functions, but it operates entirely at the type level. You can provide multiple declarations for a
                  function, but only a single implementation:</p>

                <pre data-code-language="ts" data-type="programlisting"
                  class="calibre17"><code class="kd">function</code> <code class="nx">add</code><code class="p">(</code><code class="nx">a</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">b</code>: <code class="nx">number</code><code class="p">)</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>
<code class="kd">function</code> <code class="nx">add</code><code class="p">(</code><code class="nx">a</code>: <code class="kd">string</code><code class="p">,</code> <code class="nx">b</code>: <code class="kd">string</code><code class="p">)</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>

<code class="kd">function</code> <code class="nx">add</code><code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">const</code> <code class="nx">three</code> <code class="o">=</code> <code class="nx">add</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">);</code>  <code class="c">// Type is number</code>
<code class="kd">const</code> <code class="nx">twelve</code> <code class="o">=</code> <code class="nx">add</code><code class="p">(</code><code class="s">'1'</code><code class="p">,</code> <code class="s">'2'</code><code class="p">);</code>  <code class="c">// Type is string</code></pre>

                <p class="author1">The first two declarations of <code class="calibre18">add</code> only provide type
                  information. When TypeScript produces JavaScript output, they are removed, and only the implementation
                  remains. (If you use this style of overloading, take a look at <a href="#calibre_link-767"
                    class="calibre9">Item 50</a> first. There are some subtleties to be aware of.)</p>
              </div>
            </section>













            <section class="praise" data-pdf-bookmark="TypeScript Types Have No Effect on Runtime Performance"
              data-type="sect2">
              <div class="praise" id="calibre_link-855">
                <h2 class="calibre31">TypeScript Types Have No Effect on Runtime Performance</h2>

                <p class="author1">Because<a data-primary="runtime"
                    data-secondary="effect of TypeScript types on performance" data-type="indexterm"
                    id="calibre_link-498" class="calibre9"></a> types and type operations are erased when you generate
                  JavaScript, they cannot have an effect on runtime performance. TypeScript’s static types are truly
                  zero cost. The next time someone offers runtime overhead as a reason to not use TypeScript, you’ll
                  know exactly how well they’ve tested this claim!</p>

                <p class="author1">There are two caveats to this:</p>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">While there is no <em class="calibre3">runtime</em> overhead, the TypeScript
                      compiler will introduce <em class="calibre3">build time</em> overhead. The TypeScript team takes
                      compiler performance seriously and compilation is usually quite fast, especially for incremental
                      builds. If the overhead becomes significant, your build tool may have a “transpile only” option to
                      skip the type checking.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">The code that TypeScript emits to support older runtimes <em
                        class="calibre3">may</em> incur a performance overhead vs. native implementations. For example,
                      if you use generator functions and<a data-primary="ES5" data-secondary="generator functions"
                        data-type="indexterm" id="calibre_link-252" class="calibre9"></a> target ES5, which predates
                      generators, then <code class="calibre18">tsc</code> will emit some helper code to make things
                      work. This may have some overhead vs. a native implementation of generators. In any case, this has
                      to do with the emit target and language levels and is still independent of the <em
                        class="calibre3">types</em>.</p>
                  </li>
                </ul>
              </div>
            </section>













            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-856">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">Code generation is independent of the type system. This means that TypeScript
                      types cannot affect the runtime behavior or performance of your code.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">It is possible for a program with type errors to produce code (“compile”).</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">TypeScript types are not available at runtime. To query a type at runtime, you
                      need some way to reconstruct it. Tagged unions<a data-primary="tagged unions"
                        data-secondary="querying at runtime using" data-type="indexterm" id="calibre_link-529"
                        class="calibre9"></a><a data-primary="property checking" data-type="indexterm"
                        id="calibre_link-472" class="calibre9"></a> and property checking are common ways to do this.
                      Some constructs, such as <code class="calibre18">class</code>, introduce both a TypeScript type
                      and a value that is available at runtime.<a data-primary="" data-startref="TSCcode01"
                        data-type="indexterm" id="calibre_link-698" class="calibre9"></a><a data-primary=""
                        data-startref="DGtype01" data-type="indexterm" id="calibre_link-164" class="calibre9"></a><a
                        data-primary="" data-startref="CCcheck01" data-type="indexterm" id="calibre_link-180"
                        class="calibre9"></a></p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>













        <section data-pdf-bookmark="Item 4: Get Comfortable with Structural Typing" data-type="sect1" class="praise">
          <div class="praise" id="calibre_link-10">
            <h1 class="calibre16">Item 4: Get Comfortable with Structural Typing</h1>

            <p class="author1">JavaScript<a data-primary="TypeScript" data-secondary="structural typing"
                data-type="indexterm" id="calibre_link-687" class="calibre9"></a><a data-primary="structural typing"
                data-type="indexterm" id="calibre_link-516" class="calibre9"></a><a data-primary="JavaScript"
                data-secondary="duck typing" data-type="indexterm" id="calibre_link-342" class="calibre9"></a><a
                data-primary="duck typing" data-type="indexterm" id="calibre_link-226" class="calibre9"></a> is
              inherently duck typed: if you pass a function a value with all the right properties, it won’t care how you
              made the value. It will just use it. (“If it walks like a duck and talks like a duck…”) TypeScript models
              this behavior, and it can sometimes lead to surprising results because the type checker’s understanding of
              a type may be broader than what you had in mind. Having a good grasp of structural typing will help you
              make sense of errors and non-errors and help you write more robust code.</p>

            <p class="author1">Say you’re working on a physics library and have a 2D vector type:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Vector2D</code> <code class="p">{</code>
  <code class="nx">x</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">y</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">You write a function to calculate its length:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">calculateLength</code><code class="p">(</code><code class="nx">v</code>: <code class="nx">Vector2D</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">sqrt</code><code class="p">(</code><code class="nx">v</code><code class="p">.</code><code class="nx">x</code> <code class="o">*</code> <code class="nx">v</code><code class="p">.</code><code class="nx">x</code> <code class="o">+</code> <code class="nx">v</code><code class="p">.</code><code class="nx">y</code> <code class="o">*</code> <code class="nx">v</code><code class="p">.</code><code class="nx">y</code><code class="p">);</code>
<code class="p">}</code></pre>

            <p class="author1">Now you introduce the notion of a named vector:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">NamedVector</code> <code class="p">{</code>
  <code class="nx">name</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">x</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">y</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">The <code class="calibre18">calculateLength</code> function will work with <code
                class="calibre18">NamedVector</code>s because they have <code class="calibre18">x</code> and <code
                class="calibre18">y</code> properties, which are <code class="calibre18">number</code>s. TypeScript is
              smart enough to figure this out:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">const</code> <code class="nx">v</code>: <code class="nx">NamedVector</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">x</code>: <code class="nx">3</code><code class="p">,</code> <code class="nx">y</code>: <code class="nx">4</code><code class="p">,</code> <code class="nx">name</code><code class="o">:</code> <code class="s">'Zee'</code> <code class="p">};</code>
<code class="nx">calculateLength</code><code class="p">(</code><code class="nx">v</code><code class="p">);</code>  <code class="c">// OK, result is 5</code></pre>

            <p class="author1">What is interesting is that you never declared the relationship between <code
                class="calibre18">Vector2D</code> and <code class="calibre18">NamedVector</code>. And you did not have
              to write an alternative implementation of <span class="calibre"><code
                  class="calibre18">calculateLength</code></span> calculateLength for <code
                class="calibre18">NamedVector</code>s. TypeScript’s type system is modeling JavaScript’s runtime
              behavior (<a href="#calibre_link-777" class="calibre9">Item 1</a>). It allowed <code
                class="calibre18">calculateLength</code> to be called with a <code class="calibre18">NamedVector</code>
              because its <em class="calibre3">structure</em> was compatible with <code
                class="calibre18">Vector2D</code>. This is where the term “structural typing” comes from.</p>

            <p class="author1">But this can also lead to trouble. Say you add a 3D vector type:</p>

            <pre data-code-language="ts" data-type="programlisting" id="calibre_link-857" class="calibre17"><code class="kd">interface</code> <code class="nx">Vector3D</code> <code class="p">{</code>
  <code class="nx">x</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">y</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">z</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">and write a function to normalize them (make their length 1):</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">normalize</code><code class="p">(</code><code class="nx">v</code>: <code class="nx">Vector3D</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">length</code> <code class="o">=</code> <code class="nx">calculateLength</code><code class="p">(</code><code class="nx">v</code><code class="p">);</code>
  <code class="kd">return</code> <code class="p">{</code>
    <code class="nx">x</code>: <code class="nx">v.x</code> <code class="o">/</code> <code class="nx">length</code><code class="p">,</code>
    <code class="nx">y</code>: <code class="nx">v.y</code> <code class="o">/</code> <code class="nx">length</code><code class="p">,</code>
    <code class="nx">z</code>: <code class="nx">v.z</code> <code class="o">/</code> <code class="nx">length</code><code class="p">,</code>
  <code class="p">};</code>
<code class="p">}</code></pre>

            <p class="author1">If you call this function, you’re likely to get something longer than unit length:</p>
            <pre data-type="programlisting" class="calibre17">&gt; <strong class="calibre32">normalize({x: 3, y: 4, z: 5})</strong>
{ x: 0.6, y: 0.8, z: 1 }</pre>

            <p class="author1">So what went wrong and why didn’t TypeScript catch the error?</p>

            <p class="author1">The bug is that <code class="calibre18">calculateLength</code> operates on 2D vectors but
              <code class="calibre18">normalize</code> operates on 3D vectors. So the <code class="calibre18">z</code>
              component is ignored in the normalization.
            </p>

            <p class="author1">What’s perhaps more surprising is that the type checker does not catch this issue. Why
              are you allowed to call <code class="calibre18">calculateLength</code> with a 3D vector, despite its type
              declaration saying that it takes 2D vectors?</p>

            <p class="author1">What worked so well with named vectors has backfired here. Calling <code
                class="calibre18">calculateLength</code> with an <code class="calibre18">{x, y, z}</code> object doesn’t
              throw an error. So the type checker doesn’t complain, either, and this behavior has led to a bug. (If you
              want this to be an error, you have some options. We’ll return to this example in <a
                href="#calibre_link-762" class="calibre9">Item 37</a>.)</p>

            <p class="author1">As you write functions, it’s easy to imagine that they will be called with arguments
              having the properties you’ve declared <em class="calibre3">and no others</em>. This is known as a “sealed”
              or “precise” type, and it cannot be expressed in TypeScript’s type system. Like it or not, your types are
              “open.”</p>

            <p class="author1">This<a data-primary="Object.keys" data-type="indexterm" id="calibre_link-442"
                class="calibre9"></a> can sometimes lead to surprises:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">calculateLengthL1</code><code class="p">(</code><code class="nx">v</code>: <code class="nx">Vector3D</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">length</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
  <code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="nx">axis</code> <code class="nx">of</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">keys</code><code class="p">(</code><code class="nx">v</code><code class="p">))</code> <code class="p">{</code>
    <code class="kd">const</code> <code class="nx">coord</code> <code class="o">=</code> <code class="nx">v</code><code class="p">[</code><code class="nx">axis</code><code class="p">];</code>
               <code class="c">// ~~~~~~~ Element implicitly has an 'any' type because ...</code>
               <code class="c">//         'string' can't be used to index type 'Vector3D'</code>
    <code class="nx">length</code> <code class="o">+=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">abs</code><code class="p">(</code><code class="nx">coord</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="kd">return</code> <code class="nx">length</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">Why is this an error? Since <code class="calibre18">axis</code> is one of the keys of
              <code class="calibre18">v</code>, which is a <code class="calibre18">Vector3D</code>, it should be either
              <code class="calibre18">"x"</code>, <code class="calibre18">"y"</code>, or <code
                class="calibre18">"z"</code>. And according to the declaration of <code
                class="calibre18">Vector3D</code>, these are all <code class="calibre18">number</code>s, so shouldn’t
              the type of <code class="calibre18">coord</code> be <code class="calibre18">number</code>?
            </p>

            <p class="author1">Is this error a false positive? No! TypeScript is correct to complain. The logic in the
              previous paragraph assumes that <code class="calibre18">Vector3D</code> is sealed and does not have other
              properties. But it could:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">const</code> <code class="nx">vec3D</code> <code class="o">=</code> <code class="p">{</code><code class="nx">x</code>: <code class="nx">3</code><code class="p">,</code> <code class="nx">y</code>: <code class="nx">4</code><code class="p">,</code> <code class="nx">z</code>: <code class="nx">1</code><code class="p">,</code> <code class="nx">address</code><code class="o">:</code> <code class="s">'123 Broadway'</code><code class="p">};</code>
<code class="nx">calculateLengthL1</code><code class="p">(</code><code class="nx">vec3D</code><code class="p">);</code>  <code class="c">// OK, returns NaN</code></pre>

            <p class="author1">Since <code class="calibre18">v</code> could conceivably have any properties, the type of
              <code class="calibre18">axis</code> is <code class="calibre18">string</code>. TypeScript has no reason to
              believe that <code class="calibre18">v[axis]</code> is a number because, as you just saw, it might not be.
              Iterating over objects can be tricky to type correctly. We’ll return to this topic in <a
                href="#calibre_link-42" class="calibre9">Item 54</a>, but in this case an implementation without loops
              would be better:
            </p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">calculateLengthL1</code><code class="p">(</code><code class="nx">v</code>: <code class="nx">Vector3D</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">abs</code><code class="p">(</code><code class="nx">v</code><code class="p">.</code><code class="nx">x</code><code class="p">)</code> <code class="o">+</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">abs</code><code class="p">(</code><code class="nx">v</code><code class="p">.</code><code class="nx">y</code><code class="p">)</code> <code class="o">+</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">abs</code><code class="p">(</code><code class="nx">v</code><code class="p">.</code><code class="nx">z</code><code class="p">);</code>
<code class="p">}</code></pre>

            <p class="author1">Structural typing can also lead to surprises with <code class="calibre18">class</code>es,
              which are compared structurally for assignability:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">class</code> <code class="nx">C</code> <code class="p">{</code>
  <code class="nx">foo</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="kd">constructor</code><code class="p">(</code><code class="nx">foo</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">this</code><code class="p">.</code><code class="nx">foo</code> <code class="o">=</code> <code class="nx">foo</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kd">const</code> <code class="nx">c</code> <code class="o">=</code> <code class="kd">new</code> <code class="nx">C</code><code class="p">(</code><code class="s">'instance of C'</code><code class="p">);</code>
<code class="kd">const</code> <code class="nx">d</code>: <code class="nx">C</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">foo</code><code class="o">:</code> <code class="s">'object literal'</code> <code class="p">};</code>  <code class="c">// OK!</code></pre>

            <p class="author1">Why is <code class="calibre18">d</code> assignable to <code class="calibre18">C</code>?
              It has a <code class="calibre18">foo</code> property that is a <code class="calibre18">string</code>. In
              addition, it has a <code class="calibre18">constructor</code> (from <code
                class="calibre18">Object.prototype</code>) that can be called with one argument (though it is usually
              called with zero). So the structures match. This<a data-primary="C++" data-type="indexterm"
                id="calibre_link-141" class="calibre9"></a> might lead to surprises if you have logic in <code
                class="calibre18">C</code>’s constructor and write a function that assumes it’s run. This is quite
              different from languages like C++ or Java, where<a data-primary="Java"
                data-secondary="declaring parameters in" data-type="indexterm" id="calibre_link-334"
                class="calibre9"></a> declaring a parameter of type <code class="calibre18">C</code> guarantees that it
              will be either <code class="calibre18">C</code> or a subclass of it.</p>

            <p class="author1">Structural typing is beneficial when you’re writing tests. Say you have a function that
              runs a query on a database and processes the results:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Author</code> <code class="p">{</code>
  <code class="nx">first</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">last</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">function</code> <code class="nx">getAuthors</code><code class="p">(</code><code class="nx">database</code>: <code class="nx">PostgresDB</code><code class="p">)</code><code class="o">:</code> <code class="nx">Author</code><code class="p">[]</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">authorRows</code> <code class="o">=</code> <code class="nx">database</code><code class="p">.</code><code class="nx">runQuery</code><code class="p">(</code><code class="s">`SELECT FIRST, LAST FROM AUTHORS`</code><code class="p">);</code>
  <code class="kd">return</code> <code class="nx">authorRows</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">row</code> <code class="o">=&gt;</code> <code class="p">({</code><code class="nx">first</code>: <code class="nx">row</code><code class="p">[</code><code class="mi">0</code><code class="p">],</code> <code class="nx">last</code>: <code class="nx">row</code><code class="p">[</code><code class="mi">1</code><code class="p">]}));</code>
<code class="p">}</code></pre>

            <p class="author1">To test this, you could create a mock <code class="calibre18">PostgresDB</code>. But a
              better approach is to use structural typing and define a narrower interface:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">DB</code> <code class="p">{</code>
  <code class="nx">runQuery</code><code class="o">:</code> <code class="p">(</code><code class="nx">sql</code>: <code class="kd">string</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">any</code><code class="p">[];</code>
<code class="p">}</code>
<code class="kd">function</code> <code class="nx">getAuthors</code><code class="p">(</code><code class="nx">database</code>: <code class="nx">DB</code><code class="p">)</code><code class="o">:</code> <code class="nx">Author</code><code class="p">[]</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">authorRows</code> <code class="o">=</code> <code class="nx">database</code><code class="p">.</code><code class="nx">runQuery</code><code class="p">(</code><code class="s">`SELECT FIRST, LAST FROM AUTHORS`</code><code class="p">);</code>
  <code class="kd">return</code> <code class="nx">authorRows</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">row</code> <code class="o">=&gt;</code> <code class="p">({</code><code class="nx">first</code>: <code class="nx">row</code><code class="p">[</code><code class="mi">0</code><code class="p">],</code> <code class="nx">last</code>: <code class="nx">row</code><code class="p">[</code><code class="mi">1</code><code class="p">]}));</code>
<code class="p">}</code></pre>

            <p class="author1">You can still pass <code class="calibre18">getAuthors</code> a <code
                class="calibre18">PostgresDB</code> in production since it has a <code class="calibre18">runQuery</code>
              method. Because of structural typing, the <code class="calibre18">PostgresDB</code> doesn’t need to say
              that it implements <code class="calibre18">DB</code>. TypeScript will figure out that it does.</p>

            <p class="author1">When you write your tests, you can pass in a simpler object instead:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="nx">test</code><code class="p">(</code><code class="s">'getAuthors'</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">authors</code> <code class="o">=</code> <code class="nx">getAuthors</code><code class="p">({</code>
    <code class="nx">runQuery</code><code class="p">(</code><code class="nx">sql</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{</code>
      <code class="kd">return</code> <code class="p">[[</code><code class="s">'Toni'</code><code class="p">,</code> <code class="s">'Morrison'</code><code class="p">],</code> <code class="p">[</code><code class="s">'Maya'</code><code class="p">,</code> <code class="s">'Angelou'</code><code class="p">]];</code>
    <code class="p">}</code>
  <code class="p">});</code>
  <code class="nx">expect</code><code class="p">(</code><code class="nx">authors</code><code class="p">).</code><code class="nx">toEqual</code><code class="p">([</code>
    <code class="p">{</code><code class="nx">first</code><code class="o">:</code> <code class="s">'Toni'</code><code class="p">,</code> <code class="nx">last</code><code class="o">:</code> <code class="s">'Morrison'</code><code class="p">},</code>
    <code class="p">{</code><code class="nx">first</code><code class="o">:</code> <code class="s">'Maya'</code><code class="p">,</code> <code class="nx">last</code><code class="o">:</code> <code class="s">'Angelou'</code><code class="p">}</code>
  <code class="p">]);</code>
<code class="p">});</code></pre>

            <p class="author1">TypeScript will verify that our test <code class="calibre18">DB</code> conforms to the
              interface. And your tests don’t need to know anything about your production database: no mocking libraries
              necessary! By introducing an abstraction (<code class="calibre18">DB</code>), we’ve freed our logic (and
              tests) from the details of a specific implementation (<code class="calibre18">PostgresDB</code>).</p>

            <p class="author1">Another advantage of structural typing is that it can cleanly sever dependencies between
              libraries. For more on this, see <a href="#calibre_link-3" class="calibre9">Item 51</a>.</p>








            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-858">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">Understand that JavaScript is duck typed and TypeScript uses structural typing to
                      model this: values assignable to your interfaces might have properties beyond those explicitly
                      listed in your type declarations. Types are not “sealed.”</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Be aware that classes also follow structural typing rules. You may not have an
                      instance of the class you expect!</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Use structural typing to facilitate unit testing.<a data-primary=""
                        data-startref="duck01" data-type="indexterm" id="calibre_link-227" class="calibre9"></a><a
                        data-primary="" data-startref="JSduck01" data-type="indexterm" id="calibre_link-343"
                        class="calibre9"></a><a data-primary="" data-startref="struc01" data-type="indexterm"
                        id="calibre_link-517" class="calibre9"></a><a data-primary="" data-startref="TSstruct01"
                        data-type="indexterm" id="calibre_link-688" class="calibre9"></a></p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>













        <section data-pdf-bookmark="Item 5: Limit Use of the any Type" data-type="sect1" class="praise">
          <div class="praise" id="calibre_link-51">
            <h1 class="calibre16">Item 5: Limit Use of the any Type</h1>

            <p class="author1">TypeScript’s<a data-primary="TypeScript" data-secondary="any type drawbacks"
                data-type="indexterm" id="calibre_link-671" class="calibre9"></a><a data-primary="any types"
                data-secondary="drawbacks of" data-type="indexterm" id="calibre_link-86" class="calibre9"></a> type
              system is <em class="calibre3">gradual</em> and <em class="calibre3">optional</em>: <em
                class="calibre3">gradual</em> because you can add types to your code bit by bit and <em
                class="calibre3">optional</em> because you can disable the type checker whenever you like. The key to
              these features is the <code class="calibre18">any</code> type:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17">   <code class="kd">let</code> <code class="nx">age</code>: <code class="nx">number</code><code class="p">;</code>
   <code class="nx">age</code> <code class="o">=</code> <code class="s">'12'</code><code class="p">;</code>
<code class="c">// ~~~ Type '"12"' is not assignable to type 'number'</code>
   <code class="nx">age</code> <code class="o">=</code> <code class="s">'12'</code> <code class="kd">as</code> <code class="nx">any</code><code class="p">;</code>  <code class="c">// OK</code></pre>

            <p class="author1">The type checker is right to complain here, but you can silence it just by typing <code
                class="calibre18">as any</code>. As you start using TypeScript, it’s tempting to use <code
                class="calibre18">any</code> types and<a data-primary="type assertion" data-secondary="misuse of"
                data-type="indexterm" id="calibre_link-566" class="calibre9"></a> type assertions (<code
                class="calibre18">as any</code>) when you don’t understand an error, think the type checker is
              incorrect, or simply don’t want to take the time to write out type declarations. In some cases this may be
              OK, but be aware that <code class="calibre18">any</code> eliminates many of the advantages of using
              TypeScript. You should at least understand its dangers before you use it.</p>








            <section class="praise" data-pdf-bookmark="There’s No Type Safety with any Types" data-type="sect2">
              <div class="praise" id="calibre_link-859">
                <h2 class="calibre31">There’s No Type Safety with any Types</h2>

                <p class="author1">In<a data-primary="type safety" data-secondary="lack of with any types"
                    data-type="indexterm" id="calibre_link-632" class="calibre9"></a> the preceding example, the type
                  declaration says that <code class="calibre18">age</code> is a <code class="calibre18">number</code>.
                  But <code class="calibre18">any</code> lets you assign a <code class="calibre18">string</code> to it.
                  The type checker will believe that it’s a <code class="calibre18">number</code> (that’s what you said,
                  after all), and the chaos will go uncaught:</p>

                <pre data-code-language="ts" data-type="programlisting"
                  class="calibre17"><code class="nx">age</code> <code class="o">+=</code> <code class="mi">1</code><code class="p">;</code>  <code class="c">// OK; at runtime, age is now "121"</code></pre>
              </div>
            </section>













            <section class="praise" data-pdf-bookmark="any Lets You Break Contracts" data-type="sect2">
              <div class="praise" id="calibre_link-860">
                <h2 class="calibre31">any Lets You Break Contracts</h2>

                <p class="author1">When<a data-primary="contracts, breaking with any type" data-type="indexterm"
                    id="calibre_link-195" class="calibre9"></a> you write a function, you are specifying a contract: if
                  the caller gives you a certain type of input, you’ll produce a certain type of output. But with an
                  <code class="calibre18">any</code> type you can break these contracts:
                </p>

                <pre data-code-language="ts" data-type="programlisting" id="calibre_link-861"
                  class="calibre17"><code class="kd">function</code> <code class="nx">calculateAge</code><code class="p">(</code><code class="nx">birthDate</code>: <code class="nx">Date</code><code class="p">)</code><code class="o">:</code> <code class="kt">number</code> <code class="p">{</code>
  <code class="c">// ...</code>
<code class="p">}</code>

<code class="kd">let</code> <code class="nx">birthDate</code>: <code class="nx">any</code> <code class="o">=</code> <code class="s">'1990-01-19'</code><code class="p">;</code>
<code class="nx">calculateAge</code><code class="p">(</code><code class="nx">birthDate</code><code class="p">);</code>  <code class="c">// OK</code></pre>

                <p class="author1">The birth date parameter should be a <code class="calibre18">Date</code>, not a <code
                    class="calibre18">string</code>. The <code class="calibre18">any</code> type has let you break the
                  contract of <code class="calibre18">calculateAge</code>. This can be particularly problematic because
                  JavaScript is often willing to implicitly convert between types. A <code
                    class="calibre18">string</code> will sometimes work where a <code class="calibre18">number</code> is
                  expected, only to break in other circumstances.</p>
              </div>
            </section>













            <section class="praise" data-pdf-bookmark="There Are No Language Services for any Types" data-type="sect2">
              <div class="praise" id="calibre_link-862">
                <h2 class="calibre31">There Are No Language Services for any Types</h2>

                <p class="author1">When<a data-primary="language services" data-secondary="drawbacks of any types"
                    data-type="indexterm" id="calibre_link-377" class="calibre9"></a> a symbol has a type, the
                  TypeScript language services are able to provide intelligent autocomplete and contextual documentation
                  (as shown in <a data-type="xref" href="#calibre_link-778" class="calibre9">Figure&nbsp;1-3</a>).</p>

                <figure class="calibre28">
                  <div class="figure" id="calibre_link-778">
                    <img alt="efts 01in01" src="images/000020.png" class="calibre29" />
                    <h6 class="calibre30"><span class="calibre">Figure 1-3. </span>The TypeScript Language Service is
                      able to provide contextual autocomplete for symbols with types.</h6>
                  </div>
                </figure>

                <p class="author1">but for symbols with an <code class="calibre18">any</code> type, you’re on your own
                  (<a data-type="xref" href="#calibre_link-779" class="calibre9">Figure&nbsp;1-4</a>).</p>

                <figure class="calibre28">
                  <div class="figure" id="calibre_link-779">
                    <img alt="efts 01in02" src="images/000022.png" class="calibre29" />
                    <h6 class="calibre30"><span class="calibre">Figure 1-4. </span>There is no autocomplete for
                      properties on symbols with any types.</h6>
                  </div>
                </figure>

                <p class="author1">Renaming is another such service. If you have a Person type and functions to format a
                  person’s name:</p>

                <pre data-code-language="ts" data-type="programlisting"
                  class="calibre17"><code class="kd">interface</code> <code class="nx">Person</code> <code class="p">{</code>
  <code class="nx">first</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">last</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">const</code> <code class="nx">formatName</code> <code class="o">=</code> <code class="p">(</code><code class="nx">p</code>: <code class="kd">Person</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="s">`</code><code class="si">${</code><code class="nx">p</code><code class="p">.</code><code class="nx">first</code><code class="si">}</code><code class="s"> </code><code class="si">${</code><code class="nx">p</code><code class="p">.</code><code class="nx">last</code><code class="si">}</code><code class="s">`</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">formatNameAny</code> <code class="o">=</code> <code class="p">(</code><code class="nx">p</code>: <code class="nx">any</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="s">`</code><code class="si">${</code><code class="nx">p</code><code class="p">.</code><code class="nx">first</code><code class="si">}</code><code class="s"> </code><code class="si">${</code><code class="nx">p</code><code class="p">.</code><code class="nx">last</code><code class="si">}</code><code class="s">`</code><code class="p">;</code></pre>

                <p class="author1">then you can select <code class="calibre18">first</code> in your editor, choose
                  “Rename Symbol,” and change it to <code class="calibre18">firstName</code> (see Figures <a
                    data-type="xref" data-xrefstyle="select:labelnumber" href="#calibre_link-780"
                    class="calibre9">1-5</a> and <a data-type="xref" data-xrefstyle="select:labelnumber"
                    href="#calibre_link-781" class="calibre9">1-6</a>).</p>

                <figure class="calibre28">
                  <div class="figure" id="calibre_link-780">
                    <img alt="efts 01in03" src="images/000024.png" class="calibre29" />
                    <h6 class="calibre30"><span class="calibre">Figure 1-5. </span>Renaming a symbol in vscode.</h6>
                  </div>
                </figure>

                <figure class="calibre28">
                  <div class="figure" id="calibre_link-781">
                    <img alt="img { width: 50% !important; }" src="images/000023.png" class="calibre29" />
                    <h6 class="calibre30"><span class="calibre">Figure 1-6. </span>Choosing the new name. The TypeScript
                      language service ensures that all uses of the symbol in the project are also renamed.</h6>
                  </div>
                </figure>

                <p class="author1">This changes the <code class="calibre18">formatName</code> function but not the <code
                    class="calibre18">any</code> version:</p>

                <pre data-code-language="ts" data-type="programlisting"
                  class="calibre17"><code class="kd">interface</code> <code class="nx">Person</code> <code class="p">{</code>
  <code class="nx">firstName</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">last</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">const</code> <code class="nx">formatName</code> <code class="o">=</code> <code class="p">(</code><code class="nx">p</code>: <code class="kd">Person</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="s">`</code><code class="si">${</code><code class="nx">p</code><code class="p">.</code><code class="nx">firstName</code><code class="si">}</code><code class="s"> </code><code class="si">${</code><code class="nx">p</code><code class="p">.</code><code class="nx">last</code><code class="si">}</code><code class="s">`</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">formatNameAny</code> <code class="o">=</code> <code class="p">(</code><code class="nx">p</code>: <code class="nx">any</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="s">`</code><code class="si">${</code><code class="nx">p</code><code class="p">.</code><code class="nx">first</code><code class="si">}</code><code class="s"> </code><code class="si">${</code><code class="nx">p</code><code class="p">.</code><code class="nx">last</code><code class="si">}</code><code class="s">`</code><code class="p">;</code></pre>

                <p class="author1">TypeScript’s motto is “JavaScript that scales.” A key part of “scales” is the
                  language services, which are a core part of the TypeScript experience (see <a href="#calibre_link-775"
                    class="calibre9">Item 6</a>). Losing them will lead to a loss in productivity, not just for you but
                  for everyone else working with your code.</p>
              </div>
            </section>













            <section class="praise" data-pdf-bookmark="any Types Mask Bugs When You Refactor Code" data-type="sect2">
              <div class="praise" id="calibre_link-863">
                <h2 class="calibre31">any Types Mask Bugs When You Refactor Code</h2>

                <p class="author1">Suppose<a data-primary="debugging" data-secondary="any type drawbacks"
                    data-type="indexterm" id="calibre_link-203" class="calibre9"></a> you’re building a web application
                  in which users can select some sort of item. One of your components might have an <code
                    class="calibre18">onSelectItem</code> callback. Writing a type for an Item seems like a hassle, so
                  you just use <code class="calibre18">any</code> as a stand-in:</p>

                <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">ComponentProps</code> <code class="p">{</code>
  <code class="nx">onSelectItem</code><code class="o">:</code> <code class="p">(</code><code class="nx">item</code>: <code class="nx">any</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kd">void</code><code class="p">;</code>
<code class="p">}</code></pre>

                <p class="author1">Here’s code that manages that component:</p>

                <pre data-code-language="ts" data-type="programlisting"
                  class="calibre17"><code class="kd">function</code> <code class="nx">renderSelector</code><code class="p">(</code><code class="nx">props</code>: <code class="nx">ComponentProps</code><code class="p">)</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">}</code>

<code class="kd">let</code> <code class="nx">selectedId</code>: <code class="nx">number</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
<code class="kd">function</code> <code class="nx">handleSelectItem</code><code class="p">(</code><code class="nx">item</code>: <code class="nx">any</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">selectedId</code> <code class="o">=</code> <code class="nx">item</code><code class="p">.</code><code class="nx">id</code><code class="p">;</code>
<code class="p">}</code>

<code class="nx">renderSelector</code><code class="p">({</code><code class="nx">onSelectItem</code>: <code class="nx">handleSelectItem</code><code class="p">});</code></pre>

                <p class="author1">Later you rework the selector in a way that makes it harder to pass the whole <code
                    class="calibre18">item</code> object through to <code class="calibre18">onSelectItem</code>. But
                  that’s no big deal since you just need the ID. You change the signature in <code
                    class="calibre18">ComponentProps</code>:</p>

                <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">ComponentProps</code> <code class="p">{</code>
  <code class="nx">onSelectItem</code><code class="o">:</code> <code class="p">(</code><code class="nx">id</code>: <code class="nx">number</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kd">void</code><code class="p">;</code>
<code class="p">}</code></pre>

                <p class="author1">You update the component and everything passes the type checker. Victory!</p>

                <p class="author1">…or is it? <code class="calibre18">handleSelectItem</code> takes an <code
                    class="calibre18">any</code> parameter, so it’s just as happy with an Item as it is with an ID. It
                  produces a runtime exception, despite passing the type checker. Had you used a more specific type,
                  this would have been caught by the type checker.</p>
              </div>
            </section>













            <section class="praise" data-pdf-bookmark="any Hides Your Type Design" data-type="sect2">
              <div class="praise" id="calibre_link-864">
                <h2 class="calibre31">any Hides Your Type Design</h2>

                <p class="author1">The<a data-primary="type design" data-secondary="any type drawbacks"
                    data-type="indexterm" id="calibre_link-587" class="calibre9"></a> type definition for complex
                  objects like your application state can get quite long. Rather than writing out types for the dozens
                  of properties in your page’s state, you may be tempted to just use an <code
                    class="calibre18">any</code> type and be done with it.</p>

                <p class="author1">This is problematic for all the reasons listed in this item. But it’s also
                  problematic because it hides the design of your state. As <a data-type="xref" href="#calibre_link-782"
                    class="calibre9">Chapter&nbsp;4</a> explains, good type design is essential for writing clean,
                  correct, and understandable code. With an <code class="calibre18">any</code> type, your type design is
                  implicit. This makes it hard to know whether the design is a good one, or even what the design is at
                  all. If you ask a coworker to review a change, they’ll have to reconstruct whether and how you changed
                  the application state. Better to write it out for everyone to see.</p>
              </div>
            </section>













            <section class="praise" data-pdf-bookmark="any Undermines Confidence in the Type System" data-type="sect2">
              <div class="praise" id="calibre_link-865">
                <h2 class="calibre31">any Undermines Confidence in the Type System</h2>

                <p class="author1">Every time you make a mistake and the type checker catches it, it boosts your
                  confidence in the type system. But when you see a type error at runtime, that confidence takes a hit.
                  If you’re introducing TypeScript on a larger team, this might make your coworkers question whether
                  TypeScript is worth the effort. <code class="calibre18">any</code> types are often the source of these
                  uncaught errors.</p>

                <p class="author1">TypeScript aims to make your life easier, but TypeScript with lots of <code
                    class="calibre18">any</code> types can be harder to work with than untyped JavaScript because you
                  have to fix type errors <em class="calibre3">and</em> still keep track of the real types in your head.
                  When your types match reality, it frees you from the burden of having to keep type information in your
                  head. TypeScript will keep track of it for you.</p>

                <p class="author1">For the times when you must use <code class="calibre18">any</code>, there are better
                  and worse ways to do it. For much more on how to limit the downsides of <code
                    class="calibre18">any</code>, see <a data-type="xref" href="#calibre_link-774"
                    class="calibre9">Chapter&nbsp;5</a>.</p>
              </div>
            </section>













            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-866">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">The <code class="calibre18">any</code> type effectively silences the type checker
                      and TypeScript language services. It can mask real problems, harm developer experience, and
                      undermine confidence in the type system. Avoid using it when you can!<a data-primary=""
                        data-startref="TSany01" data-type="indexterm" id="calibre_link-672" class="calibre9"></a><a
                        data-primary="" data-startref="ATdraw01" data-type="indexterm" id="calibre_link-87"
                        class="calibre9"></a></p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>







      </div>
    </section>
  </div>

  <div data-type="book" class="calibre1" id="calibre_link-783">
    <section data-pdf-bookmark="Chapter 2. TypeScript’s Type System" data-type="chapter" type="chapter" class="praise">
      <div class="praise" id="calibre_link-867">
        <h1 class="calibre14"><span class="calibre">Chapter 2. </span>TypeScript’s Type System</h1>


        <p class="author1">TypeScript generates code (<a href="#calibre_link-1" class="calibre9">Item 3</a>), but the
          type system is the main event. This is why you’re using the language!</p>

        <p class="author1">This chapter walks you through the nuts and bolts of TypeScript’s type system: how to think
          about it, how to use it, choices you’ll need to make, and features you should avoid. TypeScript’s type system
          is surprisingly powerful and able to express things you might not expect a type system to be able to. The
          items in this chapter will give you a solid foundation to build upon as you write TypeScript and read the rest
          of this book.</p>






        <section data-pdf-bookmark="Item 6: Use Your Editor to Interrogate and Explore the Type System"
          data-type="sect1" class="praise">
          <div class="praise" id="calibre_link-775">
            <h1 class="calibre16">Item 6: Use Your Editor to Interrogate and Explore the Type System</h1>

            <p class="author1">When<a data-primary="type system"
                data-secondary="using editors to interrogate and explore" data-type="indexterm" id="calibre_link-663"
                class="calibre9"></a><a data-primary="editors, using to interrogate and explore type system"
                data-type="indexterm" id="calibre_link-236" class="calibre9"></a> you install TypeScript, you get two
              executables:</p>

            <ul class="printings">
              <li class="calibre12">
                <p class="author1"><code class="calibre18">tsc</code>, the TypeScript compiler</p>
              </li>
              <li class="calibre12">
                <p class="author1"><code class="calibre18">tsserver</code>, the TypeScript standalone server</p>
              </li>
            </ul>

            <p class="author1">You’re<a data-primary="language services" data-secondary="components of"
                data-type="indexterm" id="calibre_link-376" class="calibre9"></a> much more likely to run the TypeScript
              compiler directly, but the server is every bit as important because it provides <em
                class="calibre3">language services</em>. These include autocomplete, inspection, navigation, and
              refactoring. You typically use these services through your editor. If yours isn’t configured to provide
              them, then you’re missing out! Services like autocomplete are one of the things that make TypeScript such
              a joy to use. But beyond convenience, your editor is the best place to build and test your knowledge of
              the type system. This will help you build an intuition for when TypeScript is able to infer types, which
              is key to writing compact, idiomatic code (see <a href="#calibre_link-11" class="calibre9">Item 19</a>).
            </p>

            <p class="author1">The details will vary from editor to editor, but you can generally mouse over a symbol to
              see what TypeScript considers its type (see <a data-type="xref" href="#calibre_link-784"
                class="calibre9">Figure&nbsp;2-1</a>).</p>

            <figure class="calibre28">
              <div class="figure" id="calibre_link-784">
                <img alt="efts 02in01" src="images/000003.png" class="calibre29" />
                <h6 class="calibre30"><span class="calibre">Figure 2-1. </span>An editor (vscode) showing that the
                  inferred type of the num symbol is <span class="calibre">number</span></h6>
              </div>
            </figure>

            <p class="author1">You didn’t write <code class="calibre18">number</code> here, but TypeScript was able to
              figure it out based on the value 10.</p>

            <p class="author1">You<a data-primary="functions" data-secondary="inspecting with editors"
                data-type="indexterm" id="calibre_link-284" class="calibre9"></a> can also inspect functions, as shown
              in <a data-type="xref" href="#calibre_link-785" class="calibre9">Figure&nbsp;2-2</a>.</p>

            <figure class="calibre28">
              <div class="figure" id="calibre_link-785">
                <img alt="efts 0201" src="images/000021.png" class="calibre29" />
                <h6 class="calibre30"><span class="calibre">Figure 2-2. </span>Using an editor to reveal the inferred
                  type for a function</h6>
              </div>
            </figure>

            <p class="author1">The noteworthy bit of information is the inferred value for the return type, <code
                class="calibre18">number</code>. If this does not match your expectation, you should add a type
              declaration and track down the discrepancy (see <a href="#calibre_link-27" class="calibre9">Item 9</a>).
            </p>

            <p class="author1">Seeing TypeScript’s understanding of a variable’s type at any given point is essential
              for building an intuition around widening (<a href="#calibre_link-786" class="calibre9">Item 21</a>) and
              narrowing (<a href="#calibre_link-43" class="calibre9">Item 22</a>). Seeing the type of a variable change
              in the branch of a conditional is a tremendous way to build confidence in the type system (see <a
                data-type="xref" href="#calibre_link-787" class="calibre9">Figure&nbsp;2-3</a>).</p>

            <figure class="calibre28">
              <div class="figure" id="calibre_link-787">
                <img alt="efts 0202" src="images/000002.png" class="calibre29" />
                <h6 class="calibre30"><span class="calibre">Figure 2-3. </span>The type of message is string | null
                  outside the branch but string inside.</h6>
              </div>
            </figure>

            <p class="author1">You can inspect individual properties in a larger object to see what TypeScript has
              inferred about them (see <a data-type="xref" href="#calibre_link-788"
                class="calibre9">Figure&nbsp;2-4</a>).</p>

            <figure class="calibre28">
              <div class="figure" id="calibre_link-788">
                <img alt="efts 0203" src="images/000005.png" class="calibre29" />
                <h6 class="calibre30"><span class="calibre">Figure 2-4. </span>Inspecting how TypeScript has inferred
                  types in an object</h6>
              </div>
            </figure>

            <p class="author1">If your intention was for <code class="calibre18">x</code> to be a tuple type (<code
                class="calibre18">[number, number, number]</code>), then a type annotation will be required.</p>

            <p class="author1">To see inferred generic types in the middle of a chain of operations, inspect the method
              name (as shown in <a data-type="xref" href="#calibre_link-789" class="calibre9">Figure&nbsp;2-5</a>).</p>

            <figure class="calibre28">
              <div class="figure" id="calibre_link-789">
                <img alt="efts 0204" src="images/000008.png" class="calibre29" />
                <h6 class="calibre30"><span class="calibre">Figure 2-5. </span>Revealing inferred generic types in a
                  chain of method calls</h6>
              </div>
            </figure>

            <p class="author1">The <code class="calibre18">Array&lt;string&gt;</code> indicates that TypeScript
              understands that <code class="calibre18">split</code> produced an array of strings. While there was little
              ambiguity in this case, this information can prove essential in writing and debugging long chains of
              function calls.</p>

            <p class="author1">Seeing type errors in your editor can also be a great way to learn the nuances of the
              type system. For example, this function tries to get an <code class="calibre18">HTMLElement</code> by its
              ID, or return a default one. TypeScript flags two errors:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">getElement</code><code class="p">(</code><code class="nx">elOrId</code>: <code class="kd">string</code><code class="o">|</code><code class="nx">HTMLElement</code><code class="o">|</code><code class="nx">null</code><code class="p">)</code><code class="o">:</code> <code class="nx">HTMLElement</code> <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="kd">typeof</code> <code class="nx">elOrId</code> <code class="o">===</code> <code class="s">'object'</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">return</code> <code class="nx">elOrId</code><code class="p">;</code>
 <code class="c">// ~~~~~~~~~~~~~~ 'HTMLElement | null' is not assignable to 'HTMLElement'</code>
  <code class="p">}</code> <code class="kd">else</code> <code class="kd">if</code> <code class="p">(</code><code class="nx">elOrId</code> <code class="o">===</code> <code class="kd">null</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">return</code> <code class="nb">document</code><code class="p">.</code><code class="nx">body</code><code class="p">;</code>
  <code class="p">}</code> <code class="kd">else</code> <code class="p">{</code>
    <code class="kd">const</code> <code class="nx">el</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="nx">elOrId</code><code class="p">);</code>
    <code class="kd">return</code> <code class="nx">el</code><code class="p">;</code>
 <code class="c">// ~~~~~~~~~~ 'HTMLElement | null' is not assignable to 'HTMLElement'</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

            <p class="author1">The intent in the first branch of the <code class="calibre18">if</code> statement was to
              filter down to just the objects, namely, the <code class="calibre18">HTMLElement</code>s. But oddly
              enough, in JavaScript <code class="calibre18">typeof null</code> is <code
                class="calibre18">"object"</code>, so <code class="calibre18">elOrId</code> could still be <code
                class="calibre18">null</code> in that branch. You can fix this by putting the <code
                class="calibre18">null</code> check first. The second error is because <code
                class="calibre18">document.getElementById</code> can return <code class="calibre18">null</code>, so you
              need to handle that case as well, perhaps by throwing an exception.</p>

            <p class="author1">Language services<a data-primary="libraries"
                data-secondary="navigating libraries and type declarations" data-type="indexterm" id="calibre_link-381"
                class="calibre9"></a><a data-primary="language services"
                data-secondary="navigating libraries and type declarations" data-type="indexterm" id="calibre_link-378"
                class="calibre9"></a><a data-primary="type declaration"
                data-secondary="navigating with language services" data-type="indexterm" id="calibre_link-574"
                class="calibre9"></a> can also help you navigate through libraries and type declarations. Suppose you
              see a call to the <code class="calibre18">fetch</code> function in code and want to learn more about it.
              Your editor should provide a “Go to Definition” option. In mine it looks like it does in <a
                data-type="xref" href="#calibre_link-790" class="calibre9">Figure&nbsp;2-6</a>.</p>

            <figure class="calibre28">
              <div class="figure" id="calibre_link-790">
                <img alt="efts 02in02" src="images/000010.png" class="calibre29" />
                <h6 class="calibre30"><span class="calibre">Figure 2-6. </span>The TypeScript language service provides
                  a “Go to Definition” feature that should be surfaced in your editor.</h6>
              </div>
            </figure>

            <p class="author1">Selecting this option takes you into <code class="calibre18">lib.dom.d.ts</code>, the
              type declarations which TypeScript includes for the DOM:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">declare</code> <code class="kd">function</code> <code class="nx">fetch</code><code class="p">(</code>
  <code class="nx">input</code>: <code class="nx">RequestInfo</code><code class="p">,</code> <code class="nx">init?</code>: <code class="nx">RequestInit</code>
<code class="p">)</code><code class="o">:</code> <code class="nx">Promise</code><code class="o">&lt;</code><code class="nx">Response</code><code class="o">&gt;</code><code class="p">;</code></pre>

            <p class="author1">You can see that <code class="calibre18">fetch</code> returns a <code
                class="calibre18">Promise</code> and takes two arguments. Clicking through on <code
                class="calibre18">RequestInfo</code> brings you here:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">type</code> <code class="nx">RequestInfo</code> <code class="o">=</code> <code class="nx">Request</code> <code class="o">|</code> <code class="kt">string</code><code class="p">;</code></pre>

            <p class="author1">from which you can go to <code class="calibre18">Request</code>:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">declare</code> <code class="kd">var</code> <code class="nx">Request</code><code class="o">:</code> <code class="p">{</code>
    <code class="nx">prototype</code>: <code class="nx">Request</code><code class="p">;</code>
    <code class="kd">new</code><code class="p">(</code><code class="nx">input</code>: <code class="nx">RequestInfo</code><code class="p">,</code> <code class="nx">init?</code>: <code class="nx">RequestInit</code><code class="p">)</code><code class="o">:</code> <code class="nx">Request</code><code class="p">;</code>
<code class="p">};</code></pre>

            <p class="author1">Here you can see that the <code class="calibre18">Request</code> type and value are being
              modeled separately (see <a href="#calibre_link-776" class="calibre9">Item 8</a>). You’ve seen <code
                class="calibre18">RequestInfo</code> already. Clicking through on <code
                class="calibre18">RequestInit</code> shows everything you can use to construct a <code
                class="calibre18">Request</code>:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">RequestInit</code> <code class="p">{</code>
    <code class="nx">body?</code>: <code class="nx">BodyInit</code> <code class="o">|</code> <code class="kd">null</code><code class="p">;</code>
    <code class="nx">cache?</code>: <code class="nx">RequestCache</code><code class="p">;</code>
    <code class="nx">credentials?</code>: <code class="nx">RequestCredentials</code><code class="p">;</code>
    <code class="nx">headers?</code>: <code class="nx">HeadersInit</code><code class="p">;</code>
    <code class="c">// ...</code>
<code class="p">}</code></pre>

            <p class="author1">There are many more types you could follow here, but you get the idea. Type declarations
              can be challenging to read at first, but they’re an excellent way to see what can be done with TypeScript,
              how the library you’re using is modeled, and how you might debug errors. For much more on type
              declarations, see <a data-type="xref" href="#calibre_link-791" class="calibre9">Chapter&nbsp;6</a>.</p>








            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-868">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">Take advantage of the TypeScript language services by using an editor that can
                      use them.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Use your editor to build an intuition for how the type system works and how
                      TypeScript infers types.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Know how to jump into type declaration files to see how they model behavior.<a
                        data-primary="" data-startref="TSeditor02" data-type="indexterm" id="calibre_link-664"
                        class="calibre9"></a><a data-primary="" data-startref="Einterr02" data-type="indexterm"
                        id="calibre_link-237" class="calibre9"></a></p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>













        <section data-pdf-bookmark="Item 7: Think of Types as Sets of Values" data-type="sect1" class="praise">
          <div class="praise" id="calibre_link-47">
            <h1 class="calibre16">Item 7: Think of Types as Sets of Values</h1>

            <p class="author1">At<a data-primary="type system" data-secondary="types as set values"
                data-type="indexterm" id="calibre_link-661" class="calibre9"></a><a data-primary="values"
                data-secondary="types as set values" data-type="indexterm" id="calibre_link-731" class="calibre9"></a><a
                data-primary="domain of a type" data-type="indexterm" id="calibre_link-219" class="calibre9"></a><a
                data-primary="type domains" data-type="indexterm" id="calibre_link-605" class="calibre9"></a> runtime,
              every variable has a single value chosen from JavaScript’s universe of values. There are many possible
              values, including:</p>

            <ul class="printings">
              <li class="calibre12">
                <p class="author1"><code class="calibre18">42</code></p>
              </li>
              <li class="calibre12">
                <p class="author1"><code class="calibre18">null</code></p>
              </li>
              <li class="calibre12">
                <p class="author1"><code class="calibre18">undefined</code></p>
              </li>
              <li class="calibre12">
                <p class="author1"><code class="calibre18">'Canada'</code></p>
              </li>
              <li class="calibre12">
                <p class="author1"><code class="calibre18">{animal: 'Whale', weight_lbs: 40_000}</code></p>
              </li>
              <li class="calibre12">
                <p class="author1"><code class="calibre18">/regex/</code></p>
              </li>
              <li class="calibre12">
                <p class="author1"><code class="calibre18">new HTMLButtonElement</code></p>
              </li>
              <li class="calibre12">
                <p class="author1"><code class="calibre18">(x, y) =&gt; x + y</code></p>
              </li>
            </ul>

            <p class="author1">But before your code runs, when TypeScript is checking it for errors, it just has a <em
                class="calibre3">type</em>. This is best thought of as a <em class="calibre3">set of possible
                values</em>. This set is known as the <em class="calibre3">domain</em> of the type. For instance, you
              can think of the <code class="calibre18">number</code> type as the set of all number values. <code
                class="calibre18">42</code> and <code class="calibre18">-37.25</code> are in it, but <code
                class="calibre18">'Canada'</code> is not. Depending on <code class="calibre18">strictNullChecks</code>,
              <code class="calibre18">null</code> and <code class="calibre18">undefined</code> may or may not be part of
              the set.
            </p>

            <p class="author1">The smallest set is the empty set, which contains no values. It corresponds to the <code
                class="calibre18">never</code> type in TypeScript. Because its domain is empty, no values are assignable
              to a variable with a <code class="calibre18">never</code> type:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">x</code>: <code class="nx">never</code> <code class="o">=</code> <code class="mi">12</code><code class="p">;</code>
   <code class="c">// ~ Type '12' is not assignable to type 'never'</code></pre>

            <p class="author1">The next smallest sets are those which contain single values. These correspond to literal
              types in TypeScript, also known as unit types:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">type</code> <code class="nx">A</code> <code class="o">=</code> <code class="s">'A'</code><code class="p">;</code>
<code class="kd">type</code> <code class="nx">B</code> <code class="o">=</code> <code class="s">'B'</code><code class="p">;</code>
<code class="kd">type</code> <code class="nx">Twelve</code> <code class="o">=</code> <code class="mi">12</code><code class="p">;</code></pre>

            <p class="author1">To form types with two or three values, you can union unit types:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">type</code> <code class="nx">AB</code> <code class="o">=</code> <code class="s">'A'</code> <code class="o">|</code> <code class="s">'B'</code><code class="p">;</code>
<code class="kd">type</code> <code class="nx">AB12</code> <code class="o">=</code> <code class="s">'A'</code> <code class="o">|</code> <code class="s">'B'</code> <code class="o">|</code> <code class="mi">12</code><code class="p">;</code></pre>

            <p class="author1">and so on. Union types correspond to unions of sets of values.</p>

            <p class="author1">The<a data-primary="assignable to" data-type="indexterm" id="calibre_link-114"
                class="calibre9"></a> word “assignable” appears in many TypeScript errors. In the context of sets of
              values, it means either “member of” (for a relationship between a value and a type) or “subset of” (for a
              relationship between two types):</p>

            <pre data-code-language="ts" data-type="programlisting" id="calibre_link-869" class="calibre17"><code class="kd">const</code> <code class="nx">a</code>: <code class="nx">AB</code> <code class="o">=</code> <code class="s">'A'</code><code class="p">;</code>  <code class="c">// OK, value 'A' is a member of the set {'A', 'B'}</code>
<code class="kd">const</code> <code class="nx">c</code>: <code class="nx">AB</code> <code class="o">=</code> <code class="s">'C'</code><code class="p">;</code>
   <code class="c">// ~ Type '"C"' is not assignable to type 'AB'</code></pre>

            <p class="author1">The type <code class="calibre18">"C"</code> is a unit type. Its domain consists of the
              single value <code class="calibre18">"C"</code>. This is not a subset of the domain of <code
                class="calibre18">AB</code> (which consists of the values <code class="calibre18">"A"</code> and <code
                class="calibre18">"B"</code>), so this is an error. At the end of the day, almost all the type checker
              is doing is testing whether one set is a subset of another:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="c">// OK, {"A", "B"} is a subset of {"A", "B"}:</code>
<code class="kd">const</code> <code class="nx">ab</code>: <code class="nx">AB</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">&lt;</code> <code class="mi">0.5</code> <code class="o">?</code> <code class="s">'A'</code> <code class="o">:</code> <code class="s">'B'</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">ab12</code>: <code class="nx">AB12</code> <code class="o">=</code> <code class="nx">ab</code><code class="p">;</code>  <code class="c">// OK, {"A", "B"} is a subset of {"A", "B", 12}</code>

<code class="kd">declare</code> <code class="kd">let</code> <code class="nx">twelve</code>: <code class="nx">AB12</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">back</code>: <code class="nx">AB</code> <code class="o">=</code> <code class="nx">twelve</code><code class="p">;</code>
   <code class="c">// ~~~~ Type 'AB12' is not assignable to type 'AB'</code>
   <code class="c">//        Type '12' is not assignable to type 'AB'</code></pre>

            <p class="author1">The sets for these types are easy to reason about because they are finite. But most types
              that you work with in practice have infinite domains. Reasoning about these can be harder. You can think
              of them as either being built constructively:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">type</code> <code class="nx">Int</code> <code class="o">=</code> <code class="mi">1</code> <code class="o">|</code> <code class="mi">2</code> <code class="o">|</code> <code class="mi">3</code> <code class="o">|</code> <code class="mi">4</code> <code class="o">|</code> <code class="mi">5</code> <code class="c">// | ...</code></pre>

            <p class="author1">or by describing their members:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Identified</code> <code class="p">{</code>
  <code class="nx">id</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">Think of this interface as a description of the values in the domain of its type. Does
              the value have an <code class="calibre18">id</code> property whose value is assignable to (a member of)
              <code class="calibre18">string</code>? Then it’s an <code class="calibre18">Identifiable</code>.
            </p>

            <p class="author1">That’s <em class="calibre3">all</em> it says. As <a href="#calibre_link-10"
                class="calibre9">Item 4</a> explained, TypeScript’s structural typing rules mean that the value could
              have other properties, too. It could even be callable! This fact can sometimes be obscured by excess
              property checking (see <a href="#calibre_link-758" class="calibre9">Item 11</a>).</p>

            <p class="author1">Thinking of types as sets of values helps you reason about operations on them. For
              example:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">interface</code> <code class="nx">Person</code> <code class="p">{</code>
  <code class="nx">name</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">interface</code> <code class="nx">Lifespan</code> <code class="p">{</code>
  <code class="nx">birth</code>: <code class="nx">Date</code><code class="p">;</code>
  <code class="nx">death?</code>: <code class="nx">Date</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">type</code> <code class="nx">PersonSpan</code> <code class="o">=</code> <code class="nx">Person</code> <code class="o">&amp;</code> <code class="nx">Lifespan</code><code class="p">;</code></pre>

            <p class="author1">The<a data-primary="&amp; operator" data-type="indexterm" id="calibre_link-58"
                class="calibre9"></a> <code class="calibre18">&amp;</code> operator computes the intersection of two
              types. What sorts of values belong to the <code class="calibre18">PersonSpan</code> type? On first glance
              the <code class="calibre18">Person</code> and <code class="calibre18">Lifespan</code> interfaces have no
              properties in common, so you might expect it to be the empty set (i.e., the <code
                class="calibre18">never</code> type). But type operations apply to the sets of values (the domain of the
              type), not to the properties in the interface. And remember that values with additional properties still
              belong to a type. So a value that has the properties of <em class="calibre3">both</em> <code
                class="calibre18">Person</code> <em class="calibre3">and</em> <code class="calibre18">Lifespan</code>
              will<a data-primary="Turing, Alan" data-type="indexterm" id="calibre_link-553" class="calibre9"></a>
              belong to the intersection type:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">ps</code>: <code class="kd">Person</code><code class="nx">Span</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">name</code><code class="o">:</code> <code class="s">'Alan Turing'</code><code class="p">,</code>
  <code class="nx">birth</code>: <code class="nx">new</code> <code class="nb">Date</code><code class="p">(</code><code class="s">'1912/06/23'</code><code class="p">),</code>
  <code class="nx">death</code>: <code class="nx">new</code> <code class="nb">Date</code><code class="p">(</code><code class="s">'1954/06/07'</code><code class="p">),</code>
<code class="p">};</code>  <code class="c">// OK</code></pre>

            <p class="author1">Of course, a value could have more than those three properties and still belong to the
              type! The general rule is that values in an intersection type contain the union of properties in each of
              its constituents.</p>

            <p class="author1">The intuition about intersecting properties is correct, but for the <em
                class="calibre3">union</em> of two interfaces, rather than their intersection:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">type</code> <code class="nx">K</code> <code class="o">=</code> <code class="nx">keyof</code> <code class="p">(</code><code class="nx">Person</code> <code class="o">|</code> <code class="nx">Lifespan</code><code class="p">);</code>  <code class="c">// Type is never</code></pre>

            <p class="author1">There are no keys that TypeScript can guarantee belong to a value in the union type, so
              <code class="calibre18">keyof</code> for the union must be the empty set (<code
                class="calibre18">never</code>). Or, more formally:
            </p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="nx">keyof</code> <code class="p">(</code><code class="nx">A</code><code class="o">&amp;</code><code class="nx">B</code><code class="p">)</code> <code class="o">=</code> <code class="p">(</code><code class="nx">keyof</code> <code class="nx">A</code><code class="p">)</code> <code class="o">|</code> <code class="p">(</code><code class="nx">keyof</code> <code class="nx">B</code><code class="p">)</code>
<code class="nx">keyof</code> <code class="p">(</code><code class="nx">A</code><code class="o">|</code><code class="nx">B</code><code class="p">)</code> <code class="o">=</code> <code class="p">(</code><code class="nx">keyof</code> <code class="nx">A</code><code class="p">)</code> <code class="o">&amp;</code> <code class="p">(</code><code class="nx">keyof</code> <code class="nx">B</code><code class="p">)</code></pre>

            <p class="author1">If you can build an intuition for why these equations hold, you’ll have come a long way
              toward understanding TypeScript’s type system!</p>

            <p class="author1">Another perhaps more common way to write the <code class="calibre18">PersonSpan</code>
              type would be with <code class="calibre18">extends</code>:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Person</code> <code class="p">{</code>
  <code class="nx">name</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">interface</code> <code class="nx">PersonSpan</code> <code class="kd">extends</code> <code class="nx">Person</code> <code class="p">{</code>
  <code class="nx">birth</code>: <code class="nx">Date</code><code class="p">;</code>
  <code class="nx">death?</code>: <code class="nx">Date</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">Thinking<a data-primary="extends" data-type="indexterm" id="calibre_link-265"
                class="calibre9"></a> of types as sets of values, what does <code class="calibre18">extends</code> mean?
              Just like “assignable to,” you can read it as “subset of.” Every value in <code
                class="calibre18">PersonSpan</code> must have a <code class="calibre18">name</code> property which is a
              <code class="calibre18">string</code>. And every value must also have a <code
                class="calibre18">birth</code> property, so it’s a proper subset.
            </p>

            <p class="author1">You<a data-primary="subtypes" data-type="indexterm" id="calibre_link-522"
                class="calibre9"></a><a data-primary="subsets" data-type="indexterm" id="calibre_link-521"
                class="calibre9"></a> might hear the term “subtype.” This is another way of saying that one set’s domain
              is a subset of the others. Thinking in terms of one-, two-, and three-dimensional vectors:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">interface</code> <code class="nx">Vector1D</code> <code class="p">{</code> <code class="nx">x</code>: <code class="nx">number</code><code class="p">;</code> <code class="p">}</code>
<code class="kd">interface</code> <code class="nx">Vector2D</code> <code class="kd">extends</code> <code class="nx">Vector1D</code> <code class="p">{</code> <code class="nx">y</code>: <code class="nx">number</code><code class="p">;</code> <code class="p">}</code>
<code class="kd">interface</code> <code class="nx">Vector3D</code> <code class="kd">extends</code> <code class="nx">Vector2D</code> <code class="p">{</code> <code class="nx">z</code>: <code class="nx">number</code><code class="p">;</code> <code class="p">}</code></pre>

            <p class="author1">You’d say that a <code class="calibre18">Vector3D</code> is a subtype of <code
                class="calibre18">Vector2D</code>, which is a subtype of <code class="calibre18">Vector1D</code> (in the
              context of classes you’d say “subclass”). This relationship is usually drawn as a hierarchy, but thinking
              in terms of sets of values, a Venn diagram is more appropriate (see <a data-type="xref"
                href="#calibre_link-792" class="calibre9">Figure&nbsp;2-7</a>).</p>

            <figure class="calibre28">
              <div class="figure" id="calibre_link-792">
                <img alt="efts 0205" src="images/000011.png" class="calibre29" />
                <h6 class="calibre30"><span class="calibre">Figure 2-7. </span>Two ways of thinking of type
                  relationships: as a hierarchy or as overlapping sets</h6>
              </div>
            </figure>

            <p class="author1">With the Venn diagram, it’s clear that the subset/subtype/assignability relationships are
              unchanged if you rewrite the interfaces without <code class="calibre18">extends</code>:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">interface</code> <code class="nx">Vector1D</code> <code class="p">{</code> <code class="nx">x</code>: <code class="nx">number</code><code class="p">;</code> <code class="p">}</code>
<code class="kd">interface</code> <code class="nx">Vector2D</code> <code class="p">{</code> <code class="nx">x</code>: <code class="nx">number</code><code class="p">;</code> <code class="nx">y</code>: <code class="nx">number</code><code class="p">;</code> <code class="p">}</code>
<code class="kd">interface</code> <code class="nx">Vector3D</code> <code class="p">{</code> <code class="nx">x</code>: <code class="nx">number</code><code class="p">;</code> <code class="nx">y</code>: <code class="nx">number</code><code class="p">;</code> <code class="nx">z</code>: <code class="nx">number</code><code class="p">;</code> <code class="p">}</code></pre>

            <p class="author1">The sets haven’t changed, so neither has the Venn diagram.</p>

            <p class="author1">While both interpretations are workable for object types, the set interpretation becomes
              much more intuitive when you start thinking about literal types and union types. <code
                class="calibre18">extends</code> can also appear as a constraint in a generic type, and it also means
              “subset of” in this context (<a href="#calibre_link-759" class="calibre9">Item 14</a>):</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">getKey</code><code class="o">&lt;</code><code class="nx">K</code> <code class="kd">extends</code> <code class="kt">string</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">val</code>: <code class="nx">any</code><code class="p">,</code> <code class="nx">key</code>: <code class="nx">K</code><code class="p">)</code> <code class="p">{</code>
  <code class="c">// ...</code>
<code class="p">}</code></pre>

            <p class="author1">What does it mean to extend <code class="calibre18">string</code>? If you’re used to
              thinking in terms of object inheritance, it’s hard to interpret. You could define a subclass of the object
              wrapper type <code class="calibre18">String</code> (<a href="#calibre_link-757" class="calibre9">Item
                10</a>), but that seems inadvisable.</p>

            <p class="author1">Thinking in terms of sets, on the other hand, it’s crystal clear: any type whose domain
              is a subset of <code class="calibre18">string</code> will do. This includes string literal types, unions
              of string literal types and <code class="calibre18">string</code> itself:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="nx">getKey</code><code class="p">({},</code> <code class="s">'x'</code><code class="p">);</code>  <code class="c">// OK, 'x' extends string</code>
<code class="nx">getKey</code><code class="p">({},</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">&lt;</code> <code class="mi">0.5</code> <code class="o">?</code> <code class="s">'a'</code> <code class="o">:</code> <code class="s">'b'</code><code class="p">);</code>  <code class="c">// OK, 'a'|'b' extends string</code>
<code class="nx">getKey</code><code class="p">({},</code> <code class="nb">document</code><code class="p">.</code><code class="nx">title</code><code class="p">);</code>  <code class="c">// OK, string extends string</code>
<code class="nx">getKey</code><code class="p">({},</code> <code class="mi">12</code><code class="p">);</code>
        <code class="c">// ~~ Type '12' is not assignable to parameter of type 'string'</code></pre>

            <p class="author1">“extends” has turned into “assignable” in the last error, but this shouldn’t trip us up
              since we know to read both as “subset of.” This is also a helpful mindset with finite sets, such the ones
              you might get from <code class="calibre18">keyof T</code>, which returns type for just the keys of an
              object type:</p>

            <pre data-code-language="ts" data-type="programlisting" id="calibre_link-870" class="calibre17"><code class="kd">interface</code> <code class="nx">Point</code> <code class="p">{</code>
  <code class="nx">x</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">y</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">type</code> <code class="nx">PointKeys</code> <code class="o">=</code> <code class="nx">keyof</code> <code class="nx">Point</code><code class="p">;</code>  <code class="c">// Type is "x" | "y"</code>

<code class="kd">function</code> <code class="nx">sortBy</code><code class="o">&lt;</code><code class="nx">K</code> <code class="kd">extends</code> <code class="nx">keyof</code> <code class="nx">T</code><code class="p">,</code> <code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">vals</code>: <code class="nx">T</code><code class="p">[],</code> <code class="nx">key</code>: <code class="nx">K</code><code class="p">)</code><code class="o">:</code> <code class="nx">T</code><code class="p">[]</code> <code class="p">{</code>
  <code class="c">// ...</code>
<code class="p">}</code>
<code class="kd">const</code> <code class="nx">pts</code>: <code class="nx">Point</code><code class="p">[]</code> <code class="o">=</code> <code class="p">[{</code><code class="nx">x</code>: <code class="nx">1</code><code class="p">,</code> <code class="nx">y</code>: <code class="nx">1</code><code class="p">},</code> <code class="p">{</code><code class="nx">x</code>: <code class="nx">2</code><code class="p">,</code> <code class="nx">y</code>: <code class="nx">0</code><code class="p">}];</code>
<code class="nx">sortBy</code><code class="p">(</code><code class="nx">pts</code><code class="p">,</code> <code class="s">'x'</code><code class="p">);</code>  <code class="c">// OK, 'x' extends 'x'|'y' (aka keyof T)</code>
<code class="nx">sortBy</code><code class="p">(</code><code class="nx">pts</code><code class="p">,</code> <code class="s">'y'</code><code class="p">);</code>  <code class="c">// OK, 'y' extends 'x'|'y'</code>
<code class="nx">sortBy</code><code class="p">(</code><code class="nx">pts</code><code class="p">,</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">&lt;</code> <code class="mi">0.5</code> <code class="o">?</code> <code class="s">'x'</code> <code class="o">:</code> <code class="s">'y'</code><code class="p">);</code>  <code class="c">// OK, 'x'|'y' extends 'x'|'y'</code>
<code class="nx">sortBy</code><code class="p">(</code><code class="nx">pts</code><code class="p">,</code> <code class="s">'z'</code><code class="p">);</code>
         <code class="c">// ~~~ Type '"z"' is not assignable to parameter of type '"x" | "y"</code></pre>

            <p class="author1">The set interpretation also makes more sense when you have types whose relationship isn’t
              strictly hierarchical. What’s the relationship between <code class="calibre18">string|number</code> and
              <code class="calibre18">string|Date</code>, for instance? Their intersection is non-empty (it’s <code
                class="calibre18">string</code>), but neither is a subset of the other. The relationship between their
              domains is clear, even though these types don’t fit into a strict hierarchy (see <a data-type="xref"
                href="#calibre_link-793" class="calibre9">Figure&nbsp;2-8</a>).
            </p>

            <figure class="calibre28">
              <div class="figure" id="calibre_link-793">
                <img alt="efts 0206" src="images/000013.png" class="calibre29" />
                <h6 class="calibre30"><span class="calibre">Figure 2-8. </span>Union types may not fit into a hierarchy
                  but can be thought of in terms of sets of values.</h6>
              </div>
            </figure>

            <p class="author1">Thinking of types as sets can also clarify the relationships between arrays and tuples.
              For example:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">list</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">];</code>  <code class="c">// Type is number[]</code>
<code class="kd">const</code> <code class="nx">tuple</code><code class="o">:</code> <code class="p">[</code><code class="kt">number</code><code class="p">,</code> <code class="kt">number</code><code class="p">]</code> <code class="o">=</code> <code class="nx">list</code><code class="p">;</code>
   <code class="c">// ~~~~~ Type 'number[]' is missing the following</code>
   <code class="c">//       properties from type '[number, number]': 0, 1</code></pre>

            <p class="author1">Are there lists of numbers which are not pairs of numbers? Sure! The empty list and the
              list <code class="calibre18">[1]</code> are examples. It therefore makes sense that <code
                class="calibre18">number[]</code> is not assignable to <code class="calibre18">[number, number]</code>
              since it’s not a subset of it. (The reverse assignment does work.)</p>

            <p class="author1">Is a triple assignable to a pair? Thinking in terms of structural typing, you might
              expect it to be. A pair has <code class="calibre18">0</code> and <code class="calibre18">1</code> keys, so
              mightn’t it have others, too, like <code class="calibre18">2</code>?</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">triple</code><code class="o">:</code> <code class="p">[</code><code class="kt">number</code><code class="p">,</code> <code class="kt">number</code><code class="p">,</code> <code class="kt">number</code><code class="p">]</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">];</code>
<code class="kd">const</code> <code class="kd">double</code><code class="o">:</code> <code class="p">[</code><code class="kt">number</code><code class="p">,</code> <code class="kt">number</code><code class="p">]</code> <code class="o">=</code> <code class="nx">triple</code><code class="p">;</code>
   <code class="c">// ~~~~~~ '[number, number, number]' is not assignable to '[number, number]'</code>
   <code class="c">//          Types of property 'length' are incompatible</code>
   <code class="c">//          Type '3' is not assignable to type '2'</code></pre>

            <p class="author1">The answer is “no,” and for an interesting reason. Rather than modeling a pair of numbers
              as <code class="calibre18">{0: number, 1: number}</code>, TypeScript models it as <code
                class="calibre18">{0: number, 1: number, length: 2}</code>. This makes sense&mdash;you can check the
              length of a tuple&mdash;and it precludes this assignment. And that’s probably for the best!</p>

            <p class="author1">If types are best thought of as sets of values, that means that two types with the same
              sets of values are the same. And indeed this is true. Unless two types are semantically different and just
              happen to have the same domain, there’s no reason to define the same type twice.</p>

            <p class="author1">Finally, it’s worth noting that not all sets of values correspond to TypeScript types.
              There is no TypeScript type for all the integers, or for all the objects that have <code
                class="calibre18">x</code> and <code class="calibre18">y</code> properties but no others. You can
              sometimes subtract types using <code class="calibre18">Exclude</code>, but only when it would result in a
              proper TypeScript type:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">type</code> <code class="nx">T</code> <code class="o">=</code> <code class="nx">Exclude</code><code class="o">&lt;</code><code class="kt">string</code><code class="o">|</code><code class="nb">Date</code><code class="p">,</code> <code class="kt">string</code><code class="o">|</code><code class="kt">number</code><code class="o">&gt;</code><code class="p">;</code>  <code class="c">// Type is Date</code>
<code class="kd">type</code> <code class="nx">NonZeroNums</code> <code class="o">=</code> <code class="nx">Exclude</code><code class="o">&lt;</code><code class="kt">number</code><code class="p">,</code> <code class="mi">0</code><code class="o">&gt;</code><code class="p">;</code>  <code class="c">// Type is still just number</code></pre>

            <p class="author1"><a data-type="xref" href="#calibre_link-794" class="calibre9">Table&nbsp;2-1</a>
              summarizes<a data-primary="TypeScript" data-secondary="terms and set terms" data-type="indexterm"
                id="calibre_link-692" class="calibre9"></a> the correspondence between TypeScript terms and terms from
              set theory.</p>
            <table id="calibre_link-794" class="calibre34">
              <caption class="calibre35"><span class="calibre">Table 2-1. </span>TypeScript terms and set terms
              </caption>
              <thead class="calibre36">
                <tr class="calibre37">
                  <th class="calibre38">TypeScript term</th>
                  <th class="calibre38">Set term</th>
                </tr>
              </thead>
              <tbody class="calibre39">
                <tr class="calibre37">
                  <td class="calibre40">
                    <p class="author1"><code class="calibre41">never</code></p>
                  </td>
                  <td class="calibre40">
                    <p class="author1">∅ (empty set)</p>
                  </td>
                </tr>
                <tr class="calibre42">
                  <td class="calibre40">
                    <p class="author1">Literal type</p>
                  </td>
                  <td class="calibre40">
                    <p class="author1">Single element set</p>
                  </td>
                </tr>
                <tr class="calibre37">
                  <td class="calibre40">
                    <p class="author1">Value assignable to T</p>
                  </td>
                  <td class="calibre40">
                    <p class="author1">Value ∈ T (member of)</p>
                  </td>
                </tr>
                <tr class="calibre42">
                  <td class="calibre40">
                    <p class="author1">T1 assignable to T2</p>
                  </td>
                  <td class="calibre40">
                    <p class="author1">T1 ⊆ T2 (subset of)</p>
                  </td>
                </tr>
                <tr class="calibre37">
                  <td class="calibre40">
                    <p class="author1">T1 extends T2</p>
                  </td>
                  <td class="calibre40">
                    <p class="author1">T1 ⊆ T2 (subset of)</p>
                  </td>
                </tr>
                <tr class="calibre42">
                  <td class="calibre40">
                    <p class="author1">T1 | T2</p>
                  </td>
                  <td class="calibre40">
                    <p class="author1">T1 ∪ T2 (union)</p>
                  </td>
                </tr>
                <tr class="calibre37">
                  <td class="calibre40">
                    <p class="author1">T1 &amp; T2</p>
                  </td>
                  <td class="calibre40">
                    <p class="author1">T1 ∩ T2 (intersection)</p>
                  </td>
                </tr>
                <tr class="calibre42">
                  <td class="calibre40">
                    <p class="author1"><code class="calibre41">unknown</code></p>
                  </td>
                  <td class="calibre40">
                    <p class="author1">Universal set</p>
                  </td>
                </tr>
              </tbody>
            </table>








            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-871">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">Think of types as sets of values (the type’s <em class="calibre3">domain</em>).
                      These sets can either be finite (e.g., <code class="calibre18">boolean</code> or literal types) or
                      infinite (e.g., <code class="calibre18">number</code> or <code class="calibre18">string</code>).
                    </p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">TypeScript types form intersecting sets (a Venn diagram) rather than a strict
                      hierarchy. Two types can overlap without either being a subtype of the other.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Remember that an object can still belong to a type even if it has additional
                      properties that were not mentioned in the type declaration.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Type operations apply to a set’s domain. The intersection of <code
                        class="calibre18">A</code> and <code class="calibre18">B</code> is the intersection of <code
                        class="calibre18">A</code>’s domain and <code class="calibre18">B</code>’s domain. For object
                      types, this means that values in <code class="calibre18">A &amp; B</code> have the properties of
                      both <code class="calibre18">A</code> and <code class="calibre18">B</code>.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Think of “extends,” “assignable to,” and “subtype of” as synonyms for “subset
                      of.”<a data-primary="" data-startref="TSset02" data-type="indexterm" id="calibre_link-662"
                        class="calibre9"></a><a data-primary="" data-startref="Vtypes02" data-type="indexterm"
                        id="calibre_link-732" class="calibre9"></a><a data-primary="" data-startref="dom02"
                        data-type="indexterm" id="calibre_link-220" class="calibre9"></a><a data-primary=""
                        data-startref="tydom02" data-type="indexterm" id="calibre_link-606" class="calibre9"></a></p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>













        <section data-pdf-bookmark="Item 8: Know How to Tell Whether a Symbol Is in the Type Space or Value Space"
          data-type="sect1" class="praise">
          <div class="praise" id="calibre_link-776">
            <h1 class="calibre16">Item 8: Know How to Tell Whether a Symbol Is in the Type Space or Value Space</h1>

            <p class="author1">A<a data-primary="classes" data-secondary="type versus value" data-type="indexterm"
                id="calibre_link-159" class="calibre9"></a><a data-primary="type system"
                data-secondary="type space versus value space" data-type="indexterm" id="calibre_link-657"
                class="calibre9"></a><a data-primary="symbols" data-secondary="type space versus value space"
                data-type="indexterm" id="calibre_link-525" class="calibre9"></a><a data-primary="type space"
                data-type="indexterm" id="calibre_link-636" class="calibre9"></a><a data-primary="value space"
                data-type="indexterm" id="calibre_link-723" class="calibre9"></a> symbol in TypeScript exists in one of
              two spaces:</p>

            <ul class="printings">
              <li class="calibre12">
                <p class="author1">Type space</p>
              </li>
              <li class="calibre12">
                <p class="author1">Value space</p>
              </li>
            </ul>

            <p class="author1">This can get confusing because the same name can refer to different things depending on
              which space it’s in:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">interface</code> <code class="nx">Cylinder</code> <code class="p">{</code>
  <code class="nx">radius</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">height</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">const</code> <code class="nx">Cylinder</code> <code class="o">=</code> <code class="p">(</code><code class="nx">radius</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">height</code>: <code class="nx">number</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">({</code><code class="nx">radius</code><code class="p">,</code> <code class="nx">height</code><code class="p">});</code></pre>

            <p class="author1"><code class="calibre18">interface Cylinder</code> introduces a symbol in type space.
              <code class="calibre18">const Cylinder</code> introduces a symbol with the same name in value space. They
              have nothing to do with one another. Depending on the context, when you type <code
                class="calibre18">Cylinder</code>, you’ll either be referring to the type or the value. Sometimes this
              can lead to errors:
            </p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">calculateVolume</code><code class="p">(</code><code class="nx">shape</code>: <code class="nx">unknown</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">shape</code> <code class="kd">instanceof</code> <code class="nx">Cylinder</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">shape</code><code class="p">.</code><code class="nx">radius</code>
       <code class="c">// ~~~~~~ Property 'radius' does not exist on type '{}'</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

            <p class="author1">What’s going on here? You probably intended the <code class="calibre18">instanceof</code>
              to check whether the shape was of the <code class="calibre18">Cylinder</code> type. But <code
                class="calibre18">instanceof</code> is JavaScript’s runtime operator, and it operates on values. So
              <code class="calibre18">instanceof Cylinder</code> refers to the function, not the type.
            </p>

            <p class="author1">It’s not always obvious at first glance whether a symbol is in type space or value space.
              You have to tell from the context in which the symbol occurs. This can get especially confusing because
              many type-space constructs look exactly the same as value-space constructs.</p>

            <p class="author1">Literals, for example:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">type</code> <code class="nx">T1</code> <code class="o">=</code> <code class="s">'string literal'</code><code class="p">;</code>
<code class="kd">type</code> <code class="nx">T2</code> <code class="o">=</code> <code class="mi">123</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">v1</code> <code class="o">=</code> <code class="s">'string literal'</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">v2</code> <code class="o">=</code> <code class="mi">123</code><code class="p">;</code></pre>

            <p class="author1">Generally the symbols after a <code class="calibre18">type</code> or <code
                class="calibre18">interface</code> are in type space while those introduced in a <code
                class="calibre18">const</code> or <code class="calibre18">let</code> declaration are values.</p>

            <p class="author1">One<a data-primary="TypeScript Playground" data-type="indexterm" id="calibre_link-700"
                class="calibre9"></a> of the best ways to build an intuition for the two spaces is through the <a
                href="https://www.typescriptlang.org/play/" class="calibre9">TypeScript Playground</a>, which shows you
              the generated JavaScript for your TypeScript source. Types are erased during compilation (<a
                href="#calibre_link-1" class="calibre9">Item 3</a>), so if a symbol disappears then it was probably in
              type space (see <a data-type="xref" href="#calibre_link-795" class="calibre9">Figure&nbsp;2-9</a>).</p>

            <figure class="calibre28">
              <div class="figure" id="calibre_link-795">
                <img alt="efts 0207" src="images/000015.png" class="calibre29" />
                <h6 class="calibre30"><span class="calibre">Figure 2-9. </span>The TypeScript playground showing
                  generated JavaScript. The symbols on the first two lines go away, so they were in type space.</h6>
              </div>
            </figure>

            <p class="author1">Statements in TypeScript can alternate between type space and value space. The symbols
              after a type declaration (<code class="calibre18">:</code>) or an assertion (<code
                class="calibre18">as</code>) are in type space while everything after an <code
                class="calibre18">=</code> is in value space. For example:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Person</code> <code class="p">{</code>
  <code class="nx">first</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">last</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">const</code> <code class="nx">p</code>: <code class="kd">Person</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">first</code><code class="o">:</code> <code class="s">'Jane'</code><code class="p">,</code> <code class="nx">last</code><code class="o">:</code> <code class="s">'Jacobs'</code> <code class="p">};</code>
<code class="c">//    -           --------------------------------- Values</code>
<code class="c">//       ------ Type</code></pre>

            <p class="author1">Function statements in particular can alternate repeatedly between the spaces:</p>

            <pre data-code-language="ts" data-type="programlisting" id="calibre_link-872" class="calibre17"><code class="kd">function</code> <code class="nx">email</code><code class="p">(</code><code class="nx">p</code>: <code class="kd">Person</code><code class="p">,</code> <code class="nx">subject</code>: <code class="kd">string</code><code class="p">,</code> <code class="nx">body</code>: <code class="kd">string</code><code class="p">)</code>: <code class="kd">Response</code> <code class="p">{</code>
  <code class="c">//     ----- -          -------          ----  Values</code>
  <code class="c">//              ------           ------        ------   -------- Types</code>
  <code class="c">// ...</code>
<code class="p">}</code></pre>

            <p class="author1">The<a data-primary="class construct" data-type="indexterm" id="calibre_link-152"
                class="calibre9"></a><a data-primary="enums (enumerations)" data-type="indexterm" id="calibre_link-239"
                class="calibre9"></a> <code class="calibre18">class</code> and <code class="calibre18">enum</code>
              constructs introduce both a type and a value. In the first example, <code
                class="calibre18">Cylinder</code> should have been a <code class="calibre18">class</code>:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">class</code> <code class="nx">Cylinder</code> <code class="p">{</code>
  <code class="nx">radius</code><code class="o">=</code><code class="mi">1</code><code class="p">;</code>
  <code class="nx">height</code><code class="o">=</code><code class="mi">1</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="nx">calculateVolume</code><code class="p">(</code><code class="nx">shape</code>: <code class="nx">unknown</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">shape</code> <code class="kd">instanceof</code> <code class="nx">Cylinder</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">shape</code>  <code class="c">// OK, type is Cylinder</code>
    <code class="nx">shape</code><code class="p">.</code><code class="nx">radius</code>  <code class="c">// OK, type is number</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

            <p class="author1">The TypeScript type introduced by a class is based on its shape (its properties and
              methods) while the value is the constructor.</p>

            <p class="author1">There<a data-primary="typeof operator" data-type="indexterm" id="calibre_link-669"
                class="calibre9"></a> are many operators and keywords that mean different things in a type or value
              context. <code class="calibre18">typeof</code>, for instance:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">type</code> <code class="nx">T1</code> <code class="o">=</code> <code class="kd">typeof</code> <code class="nx">p</code><code class="p">;</code>  <code class="c">// Type is Person</code>
<code class="kd">type</code> <code class="nx">T2</code> <code class="o">=</code> <code class="kd">typeof</code> <code class="nx">email</code><code class="p">;</code>
    <code class="c">// Type is (p: Person, subject: string, body: string) =&gt; Response</code>

<code class="kd">const</code> <code class="nx">v1</code> <code class="o">=</code> <code class="kd">typeof</code> <code class="nx">p</code><code class="p">;</code>  <code class="c">// Value is "object"</code>
<code class="kd">const</code> <code class="nx">v2</code> <code class="o">=</code> <code class="kd">typeof</code> <code class="nx">email</code><code class="p">;</code>  <code class="c">// Value is "function"</code></pre>

            <p class="author1">In a type context, <code class="calibre18">typeof</code> takes a value and returns its
              TypeScript type. You can use these as part of a larger type expression, or use a <code
                class="calibre18">type</code> statement to give them a name.</p>

            <p class="author1">In a value context, <code class="calibre18">typeof</code> is JavaScript’s runtime <code
                class="calibre18">typeof</code> operator. It returns a string containing the runtime type of the symbol.
              This is <em class="calibre3">not</em> the same as the TypeScript type! JavaScript’s runtime type system is
              much simpler than TypeScript’s static type system. In contrast to the infinite variety of TypeScript
              types, there have historically only been six runtime types in JavaScript: “string,” “number,” “boolean,”
              “undefined,” “object,” and “function.”</p>

            <p class="author1"><code class="calibre18">typeof</code> always operates on values. You can’t apply it to
              types. The <code class="calibre18">class</code> keyword introduces both a value and a type, so what is the
              <code class="calibre18">typeof</code> a class? It depends on the context:
            </p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">const</code> <code class="nx">v</code> <code class="o">=</code> <code class="kd">typeof</code> <code class="nx">Cylinder</code><code class="p">;</code>  <code class="c">// Value is "function"</code>
<code class="kd">type</code> <code class="nx">T</code> <code class="o">=</code> <code class="kd">typeof</code> <code class="nx">Cylinder</code><code class="p">;</code>  <code class="c">// Type is typeof Cylinder</code></pre>

            <p class="author1">The value is <code class="calibre18">"function"</code> because of how classes are
              implemented in JavaScript. The type isn’t particularly illuminating. What’s important is that it’s <em
                class="calibre3">not</em> <code class="calibre18">Cylinder</code> (the type of an instance). It’s
              actually the constructor function, which you can see by using it with <code class="calibre18">new</code>:
            </p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">declare</code> <code class="kd">let</code> <code class="nx">fn</code>: <code class="nx">T</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">c</code> <code class="o">=</code> <code class="kd">new</code> <code class="nx">fn</code><code class="p">();</code>  <code class="c">// Type is Cylinder</code></pre>

            <p class="author1">You can go between the constructor type and the instance type using the <code
                class="calibre18">InstanceType</code> generic:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">type</code> <code class="nx">C</code> <code class="o">=</code> <code class="nx">InstanceType</code><code class="o">&lt;</code><code class="kd">typeof</code> <code class="nx">Cylinder</code><code class="o">&gt;</code><code class="p">;</code>  <code class="c">// Type is Cylinder</code></pre>

            <p class="author1">The<a data-primary="[ ] property accessor" data-type="indexterm" id="calibre_link-74"
                class="calibre9"></a> <code class="calibre18">[]</code> property accessor also has an identical-looking
              equivalent in type space. But be aware that while <code class="calibre18">obj['field']</code> and <code
                class="calibre18">obj.field</code> are equivalent in value space, they are not in type space. You must
              use the former to get the type of another type’s <span class="calibre">property:</span></p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">first</code>: <code class="kd">Person</code><code class="p">[</code><code class="s">'first'</code><code class="p">]</code> <code class="o">=</code> <code class="nx">p</code><code class="p">[</code><code class="s">'first'</code><code class="p">];</code>  <code class="c">// Or p.first</code>
   <code class="c">// -----                    ---------- Values</code>
   <code class="c">//        ------ ------- Types</code></pre>

            <p class="author1"><code class="calibre18">Person['first']</code> is a <em class="calibre3">type</em> here
              since it appears in a type context (after a <code class="calibre18">:</code>). You can put any type in the
              index slot, including union types or primitive types:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">type</code> <code class="nx">PersonEl</code> <code class="o">=</code> <code class="nx">Person</code><code class="p">[</code><code class="s">'first'</code> <code class="o">|</code> <code class="s">'last'</code><code class="p">];</code>  <code class="c">// Type is string</code>
<code class="kd">type</code> <code class="nx">Tuple</code> <code class="o">=</code> <code class="p">[</code><code class="kt">string</code><code class="p">,</code> <code class="kt">number</code><code class="p">,</code> <code class="nb">Date</code><code class="p">];</code>
<code class="kd">type</code> <code class="nx">TupleEl</code> <code class="o">=</code> <code class="nx">Tuple</code><code class="p">[</code><code class="kt">number</code><code class="p">];</code>  <code class="c">// Type is string | number | Date</code></pre>

            <p class="author1">See <a href="#calibre_link-759" class="calibre9">Item 14</a> for more on this.</p>

            <p class="author1">There are many other constructs that have different meanings in the two spaces:</p>

            <ul class="printings">
              <li class="calibre12">
                <p class="author1"><code class="calibre18">this</code> in<a data-primary="this operator"
                    data-type="indexterm" id="calibre_link-539" class="calibre9"></a> value space is JavaScript’s <code
                    class="calibre18">this</code> keyword (<a href="#calibre_link-12" class="calibre9">Item 49</a>). As
                  a type, <code class="calibre18">this</code> is the TypeScript type of <code
                    class="calibre18">this</code>, aka “polymorphic this.” It’s helpful for implementing method chains
                  with subclasses.</p>
              </li>
              <li class="calibre12">
                <p class="author1">In<a data-primary="&amp; operator" data-type="indexterm" id="calibre_link-59"
                    class="calibre9"></a><a data-primary="| operator" data-type="indexterm" id="calibre_link-81"
                    class="calibre9"></a> value space <code class="calibre18">&amp;</code> and <code
                    class="calibre18">|</code> are bitwise AND and OR. In type space they are the intersection and union
                  operators.</p>
              </li>
              <li class="calibre12">
                <p class="author1"><code class="calibre18">const</code> introduces<a data-primary="const"
                    data-secondary="const versus as const" data-type="indexterm" id="calibre_link-187"
                    class="calibre9"></a> a new variable, but <code class="calibre18">as const</code> changes the
                  inferred type of a literal or literal expression (<a href="#calibre_link-786" class="calibre9">Item
                    21</a>).</p>
              </li>
              <li class="calibre12">
                <p class="author1"><code class="calibre18">extends</code> can<a data-primary="extends"
                    data-type="indexterm" id="calibre_link-266" class="calibre9"></a> define a subclass (<code
                    class="calibre18">class A extends B</code>) or a subtype (<code
                    class="calibre18">interface A extends B</code>) or a constraint on a generic type (<code
                    class="calibre18">Generic&lt;T extends number&gt;</code>).</p>
              </li>
              <li class="calibre12">
                <p class="author1"><code class="calibre18">in</code> can<a data-primary="in construct"
                    data-secondary="value versus type space meanings" data-type="indexterm" id="calibre_link-314"
                    class="calibre9"></a> either be part of a loop (<code class="calibre18">for (key in object)</code>)
                  or a mapped type (<a href="#calibre_link-759" class="calibre9">Item 14</a>).</p>
              </li>
            </ul>

            <p class="author1">If TypeScript doesn’t seem to understand your code at all, it may be because of confusion
              around type and value space. For example, say you change the <code class="calibre18">email</code> function
              from earlier to take its arguments in a single object parameter:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">email</code><code class="p">(</code><code class="nx">options</code><code class="o">:</code> <code class="p">{</code><code class="nx">person</code>: <code class="kd">Person</code><code class="p">,</code> <code class="nx">subject</code>: <code class="kd">string</code><code class="p">,</code> <code class="nx">body</code>: <code class="kd">string</code><code class="p">})</code> <code class="p">{</code>
  <code class="c">// ...</code>
<code class="p">}</code></pre>

            <p class="author1">In JavaScript you can use destructuring assignment to create local variables for each
              property in the object:</p>

            <pre data-code-language="js" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">email</code><code class="p">({</code><code class="nx">person</code><code class="p">,</code> <code class="nx">subject</code><code class="p">,</code> <code class="nx">body</code><code class="p">})</code> <code class="p">{</code>
  <code class="c">// ...</code>
<code class="p">}</code></pre>

            <p class="author1">If you try to do the same in TypeScript, you get some confusing errors:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">email</code><code class="p">({</code>
  <code class="nx">person</code>: <code class="kd">Person</code><code class="p">,</code>
       <code class="c">// ~~~~~~ Binding element 'Person' implicitly has an 'any' type</code>
  <code class="nx">subject</code>: <code class="kd">string</code><code class="p">,</code>
        <code class="c">// ~~~~~~ Duplicate identifier 'string'</code>
        <code class="c">//        Binding element 'string' implicitly has an 'any' type</code>
  <code class="nx">body</code>: <code class="kd">string</code><code class="p">}</code>
     <code class="c">// ~~~~~~ Duplicate identifier 'string'</code>
     <code class="c">//        Binding element 'string' implicitly has an 'any' type</code>
<code class="p">)</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">}</code></pre>

            <p class="author1">The problem is that <code class="calibre18">Person</code> and <code
                class="calibre18">string</code> are being interpreted in a value context. You’re trying to create a
              variable named <code class="calibre18">Person</code> and two variables named <code
                class="calibre18">string</code>. Instead, you should separate the types and values:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">email</code><code class="p">(</code>
  <code class="p">{</code><code class="nx">person</code><code class="p">,</code> <code class="nx">subject</code><code class="p">,</code> <code class="nx">body</code><code class="p">}</code><code class="o">:</code> <code class="p">{</code><code class="nx">person</code>: <code class="kd">Person</code><code class="p">,</code> <code class="nx">subject</code>: <code class="kd">string</code><code class="p">,</code> <code class="nx">body</code>: <code class="kd">string</code><code class="p">}</code>
<code class="p">)</code> <code class="p">{</code>
  <code class="c">// ...</code>
<code class="p">}</code></pre>

            <p class="author1">This is significantly more verbose, but in practice you may have a named type for the
              parameters or be able to infer them from context (<a href="#calibre_link-760" class="calibre9">Item
                26</a>).</p>

            <p class="author1">While the similar constructs in type and value can be confusing at first, they’re
              eventually useful as a mnemonic once you get the hang of it.</p>








            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-873">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">Know how to tell whether you’re in type space or value space while reading a
                      TypeScript expression. Use the TypeScript playground to build an intuition for this.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Every value has a type, but types do not have values. Constructs<a
                        data-primary="interface construct" data-secondary="existence in type space"
                        data-type="indexterm" id="calibre_link-325" class="calibre9"></a> such as <code
                        class="calibre18">type</code> and <code class="calibre18">interface</code> exist only in the
                      type space.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1"><code class="calibre18">"foo"</code> might be a string literal, or it might be a
                      string literal type. Be aware of this distinction and understand how to tell which it is.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1"><code class="calibre18">typeof</code>, <code class="calibre18">this</code>, and
                      many other operators and keywords have different meanings in type space and value space.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Some constructs such as <code class="calibre18">class</code> or <code
                        class="calibre18">enum</code> introduce both a type and a value.<a data-primary=""
                        data-startref="TStype02" data-type="indexterm" id="calibre_link-658" class="calibre9"></a><a
                        data-primary="" data-startref="Stype02" data-type="indexterm" id="calibre_link-526"
                        class="calibre9"></a><a data-primary="" data-startref="tysp02" data-type="indexterm"
                        id="calibre_link-637" class="calibre9"></a><a data-primary="" data-startref="valsp02"
                        data-type="indexterm" id="calibre_link-724" class="calibre9"></a></p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>













        <section data-pdf-bookmark="Item 9: Prefer Type Declarations to Type Assertions" data-type="sect1"
          class="praise">
          <div class="praise" id="calibre_link-27">
            <h1 class="calibre16">Item 9: Prefer Type Declarations to Type Assertions</h1>

            <p class="author1">TypeScript<a data-primary="type system"
                data-secondary="type declarations versus type assertions" data-type="indexterm" id="calibre_link-655"
                class="calibre9"></a><a data-primary="type assertion" data-secondary="versus type declarations"
                data-secondary-sortas="type declarations" data-type="indexterm" id="calibre_link-567"
                class="calibre9"></a><a data-primary="type declaration" data-secondary="versus type assertion"
                data-secondary-sortas="type assertion" data-type="indexterm" id="calibre_link-581"
                class="calibre9"></a><a data-primary="variables" data-secondary="assigning values to"
                data-type="indexterm" id="calibre_link-736" class="calibre9"></a><a data-primary="values"
                data-secondary="assigning to variables" data-type="indexterm" id="calibre_link-725"
                class="calibre9"></a> seems to have two ways of assigning a value to a variable and giving it a type:
            </p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">interface</code> <code class="nx">Person</code> <code class="p">{</code> <code class="nx">name</code>: <code class="kd">string</code> <code class="p">};</code>

<code class="kd">const</code> <code class="nx">alice</code>: <code class="kd">Person</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">name</code><code class="o">:</code> <code class="s">'Alice'</code> <code class="p">};</code>  <code class="c">// Type is Person</code>
<code class="kd">const</code> <code class="nx">bob</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">name</code><code class="o">:</code> <code class="s">'Bob'</code> <code class="p">}</code> <code class="kd">as</code> <code class="nx">Person</code><code class="p">;</code>  <code class="c">// Type is Person</code></pre>

            <p class="author1">While these achieve similar ends, they are actually quite different! The first (<code
                class="calibre18">alice: Person</code>) adds a <em class="calibre3">type declaration</em> to the
              variable and ensures that the value conforms to the type. The latter (<code
                class="calibre18">as Person</code>) performs a <em class="calibre3">type assertion</em>. This tells
              TypeScript that, despite the type it inferred, you know better and would like the type to be <code
                class="calibre18">Person</code>.</p>

            <p class="author1">In general, you should prefer type declarations to type assertions. Here’s why:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">const</code> <code class="nx">alice</code>: <code class="kd">Person</code> <code class="o">=</code> <code class="p">{};</code>
   <code class="c">// ~~~~~ Property 'name' is missing in type '{}'</code>
   <code class="c">//       but required in type 'Person'</code>
<code class="kd">const</code> <code class="nx">bob</code> <code class="o">=</code> <code class="p">{}</code> <code class="kd">as</code> <code class="nx">Person</code><code class="p">;</code>  <code class="c">// No error</code></pre>

            <p class="author1">The type declaration verifies that the value conforms to the interface. Since it does
              not, TypeScript flags an error. The type assertion silences this error by telling the type checker that,
              for whatever reason, you know better than it does.</p>

            <p class="author1">The same thing happens if you specify an additional property:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">const</code> <code class="nx">alice</code>: <code class="kd">Person</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">name</code><code class="o">:</code> <code class="s">'Alice'</code><code class="p">,</code>
  <code class="nx">occupation</code><code class="o">:</code> <code class="s">'TypeScript developer'</code>
<code class="c">// ~~~~~~~~~ Object literal may only specify known properties</code>
<code class="c">//           and 'occupation' does not exist in type 'Person'</code>
<code class="p">};</code>
<code class="kd">const</code> <code class="nx">bob</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">name</code><code class="o">:</code> <code class="s">'Bob'</code><code class="p">,</code>
  <code class="nx">occupation</code><code class="o">:</code> <code class="s">'JavaScript developer'</code>
<code class="p">}</code> <code class="kd">as</code> <code class="nx">Person</code><code class="p">;</code>  <code class="c">// No error</code></pre>

            <p class="author1">This<a data-primary="excess property checking" data-secondary="type declaration and"
                data-type="indexterm" id="calibre_link-263" class="calibre9"></a> is excess property checking at work
              (<a href="#calibre_link-758" class="calibre9">Item 11</a>), but it doesn’t apply if you use an assertion.
            </p>

            <p class="author1">Because they provide additional safety checks, you should use type declarations unless
              you have a specific reason to use a type assertion.</p>
            <div data-type="note" type="note" class="calibre24">
              <h6 class="calibre25">Note</h6>
              <p class="author1">You<a data-primary="React library" data-secondary="Person in" data-type="indexterm"
                  id="calibre_link-485" class="calibre9"></a> may also see code that looks like <code
                  class="calibre18">const bob = &lt;Person&gt;{}</code>. This was the original syntax for assertions and
                is equivalent to <code class="calibre18">{} as Person</code>. It is less common now because <code
                  class="calibre18">&lt;Person&gt;</code> is interpreted as a start tag in <em
                  class="calibre3">.tsx</em> files (TypeScript + React).</p>
            </div>

            <p class="author1">It’s<a data-primary="arrow functions" data-type="indexterm" id="calibre_link-110"
                class="calibre9"></a><a data-primary="functions" data-secondary="arrow functions" data-type="indexterm"
                id="calibre_link-278" class="calibre9"></a> not always clear how to use a declaration with arrow
              functions. For example, what if you wanted to use the named <code class="calibre18">Person</code>
              interface in this code?</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">people</code> <code class="o">=</code> <code class="p">[</code><code class="s">'alice'</code><code class="p">,</code> <code class="s">'bob'</code><code class="p">,</code> <code class="s">'jan'</code><code class="p">].</code><code class="nx">map</code><code class="p">(</code><code class="nx">name</code> <code class="o">=&gt;</code> <code class="p">({</code><code class="nx">name</code><code class="p">}));</code>
<code class="c">// { name: string; }[]... but we want Person[]</code></pre>

            <p class="author1">It’s tempting to use a type assertion here, and it seems to solve the problem:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">people</code> <code class="o">=</code> <code class="p">[</code><code class="s">'alice'</code><code class="p">,</code> <code class="s">'bob'</code><code class="p">,</code> <code class="s">'jan'</code><code class="p">].</code><code class="nx">map</code><code class="p">(</code>
  <code class="nx">name</code> <code class="o">=&gt;</code> <code class="p">({</code><code class="nx">name</code><code class="p">}</code> <code class="kd">as</code> <code class="nx">Person</code><code class="p">)</code>
<code class="p">);</code> <code class="c">// Type is Person[]</code></pre>

            <p class="author1">But this suffers from all the same issues as a more direct use of type assertions. For
              example:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">people</code> <code class="o">=</code> <code class="p">[</code><code class="s">'alice'</code><code class="p">,</code> <code class="s">'bob'</code><code class="p">,</code> <code class="s">'jan'</code><code class="p">].</code><code class="nx">map</code><code class="p">(</code><code class="nx">name</code> <code class="o">=&gt;</code> <code class="p">({}</code> <code class="kd">as</code> <code class="nx">Person</code><code class="p">));</code>
<code class="c">// No error</code></pre>

            <p class="author1">So how do you use a type declaration in this context instead? The most straightforward
              way is to declare a variable in the arrow function:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">people</code> <code class="o">=</code> <code class="p">[</code><code class="s">'alice'</code><code class="p">,</code> <code class="s">'bob'</code><code class="p">,</code> <code class="s">'jan'</code><code class="p">].</code><code class="nx">map</code><code class="p">(</code><code class="nx">name</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">person</code>: <code class="kd">Person</code> <code class="o">=</code> <code class="p">{</code><code class="nx">name</code><code class="p">};</code>
  <code class="kd">return</code> <code class="nx">person</code>
<code class="p">});</code> <code class="c">// Type is Person[]</code></pre>

            <p class="author1">But this introduces considerable noise compared to the original code. A more concise way
              is to declare the return type of the arrow function:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">people</code> <code class="o">=</code> <code class="p">[</code><code class="s">'alice'</code><code class="p">,</code> <code class="s">'bob'</code><code class="p">,</code> <code class="s">'jan'</code><code class="p">].</code><code class="nx">map</code><code class="p">(</code>
  <code class="p">(</code><code class="nx">name</code><code class="p">)</code><code class="o">:</code> <code class="nx">Person</code> <code class="o">=&gt;</code> <code class="p">({</code><code class="nx">name</code><code class="p">})</code>
<code class="p">);</code> <code class="c">// Type is Person[]</code></pre>

            <p class="author1">This performs all the same checks on the value as the previous version. The parentheses
              are significant here! <code class="calibre18">(name): Person</code> infers the type of <code
                class="calibre18">name</code> and specifies that the returned type should be <code
                class="calibre18">Person</code>. But <code class="calibre18">(name: Person)</code> would specify the
              type of <code class="calibre18">name</code> as <code class="calibre18">Person</code> and allow the return
              type to be inferred, which would produce an error.</p>

            <p class="author1">In this case you could have also written the final desired type and let TypeScript check
              the validity of the assignment:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">people</code>: <code class="kd">Person</code><code class="p">[]</code> <code class="o">=</code> <code class="p">[</code><code class="s">'alice'</code><code class="p">,</code> <code class="s">'bob'</code><code class="p">,</code> <code class="s">'jan'</code><code class="p">].</code><code class="nx">map</code><code class="p">(</code>
  <code class="p">(</code><code class="nx">name</code><code class="p">)</code><code class="o">:</code> <code class="nx">Person</code> <code class="o">=&gt;</code> <code class="p">({</code><code class="nx">name</code><code class="p">})</code>
<code class="p">);</code></pre>

            <p class="author1">But in the context of a longer chain of function calls it may be necessary or desirable
              to have the named type in place earlier. And it will help flag errors where they occur.</p>

            <p class="author1">So when <em class="calibre3">should</em> you use a type assertion? Type assertions make
              the most sense when you truly do know more about a type than TypeScript does, typically from context that
              isn’t available to the type checker. For instance, you may know the type of a DOM element more precisely
              than TypeScript does:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="nb">document</code><code class="p">.</code><code class="nx">querySelector</code><code class="p">(</code><code class="s">'#myButton'</code><code class="p">).</code><code class="nx">addEventListener</code><code class="p">(</code><code class="s">'click'</code><code class="p">,</code> <code class="nx">e</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="nx">e</code><code class="p">.</code><code class="nx">currentTarget</code> <code class="c">// Type is EventTarget</code>
  <code class="kd">const</code> <code class="nx">button</code> <code class="o">=</code> <code class="nx">e</code><code class="p">.</code><code class="nx">currentTarget</code> <code class="kd">as</code> <code class="nx">HTMLButtonElement</code><code class="p">;</code>
  <code class="nx">button</code> <code class="c">// Type is HTMLButtonElement</code>
<code class="p">});</code></pre>

            <p class="author1">Because TypeScript doesn’t have access to the DOM of your page, it has no way of knowing
              that <code class="calibre18">#myButton</code> is a button element. And it doesn’t know that the <code
                class="calibre18">currentTarget</code> of the event should be that same button. Since you have
              information that TypeScript does not, a type assertion makes sense here. For more on DOM types, see <a
                href="#calibre_link-26" class="calibre9">Item 55</a>.</p>

            <p class="author1">You may also run into the non-null assertion, which is so common that it gets a special
              syntax:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">const</code> <code class="nx">elNull</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s">'foo'</code><code class="p">);</code>  <code class="c">// Type is HTMLElement | null</code>
<code class="kd">const</code> <code class="nx">el</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s">'foo'</code><code class="p">)</code><code class="o">!</code><code class="p">;</code> <code class="c">// Type is HTMLElement</code></pre>

            <p class="author1">Used<a data-primary="! operator" data-type="indexterm" id="calibre_link-56"
                class="calibre9"></a><a data-primary="non-null assertions" data-type="indexterm" id="calibre_link-427"
                class="calibre9"></a> as a prefix, <code class="calibre18">!</code> is boolean negation. But as a
              suffix, <code class="calibre18">!</code> is interpreted as an assertion that the value is non-null. You
              should treat <code class="calibre18">!</code> just like any other assertion: it is erased during
              compilation, so you should only use it if you have information that the type checker lacks and can ensure
              that the value is non-null. If you can’t, you should use a conditional to check for the <code
                class="calibre18">null</code> case.</p>

            <p class="author1">Type assertions have their limits: they don’t let you convert between arbitrary types.
              The general idea is that you can use a type assertion to convert between A and B if either is a subset of
              the other. <code class="calibre18">HTMLElement</code> is a subtype of <code
                class="calibre18">HTMLElement | null</code>, so this type assertion is OK. <code
                class="calibre18">HTMLButtonElement</code> is a subtype of <code class="calibre18">EventTarget</code>,
              so that was OK, too. And <code class="calibre18">Person</code> is a subtype of <code
                class="calibre18">{}</code>, so that assertion is also fine.</p>

            <p class="author1">But you can’t convert between a <code class="calibre18">Person</code> and an <code
                class="calibre18">HTMLElement</code> since neither is a subtype of the other:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Person</code> <code class="p">{</code> <code class="nx">name</code>: <code class="kd">string</code><code class="p">;</code> <code class="p">}</code>
<code class="kd">const</code> <code class="nx">body</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">body</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">el</code> <code class="o">=</code> <code class="nx">body</code> <code class="kd">as</code> <code class="nx">Person</code><code class="p">;</code>
        <code class="c">// ~~~~~~~~~~~~~~ Conversion of type 'HTMLElement' to type 'Person'</code>
        <code class="c">//                may be a mistake because neither type sufficiently</code>
        <code class="c">//                overlaps with the other. If this was intentional,</code>
        <code class="c">//                convert the expression to 'unknown' first</code></pre>

            <p class="author1">The error suggests an escape hatch, namely, using the <code
                class="calibre18">unknown</code> type (<a href="#calibre_link-40" class="calibre9">Item 42</a>). Every
              type is a subtype of <code class="calibre18">unknown</code>, so assertions involving <code
                class="calibre18">unknown</code> are always OK. This lets you convert between arbitrary types, but at
              least you’re being explicit that you’re doing something suspicious!</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">const</code> <code class="nx">el</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">body</code> <code class="kd">as</code> <code class="nx">unknown</code> <code class="kd">as</code> <code class="nx">Person</code><code class="p">;</code>  <code class="c">// OK</code></pre>








            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-874">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">Prefer type declarations (<code class="calibre18">: Type</code>) to type
                      assertions (<code class="calibre18">as Type</code>).</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Know how to annotate the return type of an arrow function.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Use type assertions and non-null assertions when you know something about types
                      that TypeScript does not.<a data-primary="" data-startref="TSdeclar02" data-type="indexterm"
                        id="calibre_link-656" class="calibre9"></a><a data-primary="" data-startref="TAdecl02"
                        data-type="indexterm" id="calibre_link-568" class="calibre9"></a><a data-primary=""
                        data-startref="Vassign02" data-type="indexterm" id="calibre_link-726" class="calibre9"></a><a
                        data-primary="" data-startref="TDassert02" data-type="indexterm" id="calibre_link-582"
                        class="calibre9"></a><a data-primary="" data-startref="VAvalues02" data-type="indexterm"
                        id="calibre_link-737" class="calibre9"></a></p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>













        <section data-pdf-bookmark="Item 10: Avoid Object Wrapper Types (String, Number, Boolean, Symbol, BigInt)"
          data-type="sect1" class="praise">
          <div class="praise" id="calibre_link-757">
            <h1 class="calibre16">Item 10: Avoid Object Wrapper Types (String, Number, Boolean, Symbol, BigInt)</h1>

            <p class="author1">In<a data-primary="type system" data-secondary="object wrapper types"
                data-type="indexterm" id="calibre_link-652" class="calibre9"></a><a data-primary="object wrapper types"
                data-type="indexterm" id="calibre_link-439" class="calibre9"></a><a data-primary="string primitives"
                data-type="indexterm" id="calibre_link-512" class="calibre9"></a><a data-primary="number primitives"
                data-type="indexterm" id="calibre_link-434" class="calibre9"></a><a data-primary="boolean primitives"
                data-type="indexterm" id="calibre_link-131" class="calibre9"></a><a data-primary="null primitive"
                data-type="indexterm" id="calibre_link-430" class="calibre9"></a><a data-primary="undefined primitive"
                data-type="indexterm" id="calibre_link-702" class="calibre9"></a><a data-primary="symbols"
                data-secondary="symbol primitives" data-type="indexterm" id="calibre_link-523" class="calibre9"></a><a
                data-primary="bigint primitive" data-type="indexterm" id="calibre_link-129" class="calibre9"></a>
              addition to objects, JavaScript has seven types of primitive values: strings, numbers, booleans, <code
                class="calibre18">null</code>, <code class="calibre18">undefined</code>, symbol, and bigint. The first
              five have been around since the beginning. The<a data-primary="ES2015" data-secondary="symbol primitive"
                data-type="indexterm" id="calibre_link-247" class="calibre9"></a> symbol primitive was added in ES2015,
              and bigint is in the process of being finalized.</p>

            <p class="author1">Primitives are distinguished from objects by being immutable and not having methods. You
              might object that strings <em class="calibre3">do</em> have methods:</p>
            <pre data-type="programlisting" class="calibre17">&gt; <strong class="calibre32">'primitive'.charAt(3)</strong>
"m"</pre>

            <p class="author1">But things are not quite as they seem. There’s actually something surprising and subtle
              going on here. While a string <em class="calibre3">primitive</em> does not have methods, JavaScript also
              defines a <code class="calibre18">String</code> <em class="calibre3">object</em> type that does.
              JavaScript freely converts between these types. When you access a method like <code
                class="calibre18">charAt</code> on a string primitive, JavaScript wraps it in a <code
                class="calibre18">String</code> object, calls the method, and then throws the object away.</p>

            <p class="author1">You can observe this if you monkey-patch <code class="calibre18">String.prototype</code>
              (<a href="#calibre_link-764" class="calibre9">Item 43</a>):</p>

            <pre data-code-language="js" data-type="programlisting" id="calibre_link-875"
              class="calibre17"><code class="c">// Don't do this!</code>
<code class="kd">const</code> <code class="nx">originalCharAt</code> <code class="o">=</code> <code class="nb">String</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">charAt</code><code class="p">;</code>
<code class="nb">String</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">charAt</code> <code class="o">=</code> <code class="kd">function</code><code class="p">(</code><code class="nx">pos</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="kd">this</code><code class="p">,</code> <code class="kd">typeof</code> <code class="kd">this</code><code class="p">,</code> <code class="nx">pos</code><code class="p">);</code>
  <code class="kd">return</code> <code class="nx">originalCharAt</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="kd">this</code><code class="p">,</code> <code class="nx">pos</code><code class="p">);</code>
<code class="p">};</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s">'primitive'</code><code class="p">.</code><code class="nx">charAt</code><code class="p">(</code><code class="mi">3</code><code class="p">));</code></pre>

            <p class="author1">This produces the following output:</p>

            <pre data-type="programlisting" id="calibre_link-876" class="calibre17">[String: 'primitive'] 'object' 3
m</pre>

            <p class="author1">The <code class="calibre18">this</code> value in the method is a <code
                class="calibre18">String</code> object wrapper, not a string primitive. You can instantiate a <code
                class="calibre18">String</code> object directly and it will sometimes behave like a string primitive.
              But not always. For example, a <code class="calibre18">String</code> object is only ever equal to itself:
            </p>
            <pre data-type="programlisting" class="calibre17">&gt; <strong class="calibre32">"hello" === new String("hello")</strong>
false
&gt; <strong class="calibre32">new String("hello") === new String("hello")</strong>
false</pre>

            <p class="author1">The implicit conversion to object wrapper types explains an odd phenomenon in
              JavaScript&mdash;if you assign a property to a primitive, it disappears:</p>
            <pre data-type="programlisting" class="calibre17">&gt; <strong class="calibre32">x = "hello"</strong>
&gt; <strong class="calibre32">x.language = 'English'</strong>
'English'
&gt; <strong class="calibre32">x.language</strong>
undefined</pre>

            <p class="author1">Now you know the explanation: <code class="calibre18">x</code> is converted to a <code
                class="calibre18">String</code> instance, the <code class="calibre18">language</code> property is set on
              that, and then the object (with its <code class="calibre18">language</code> property) is thrown away.</p>

            <p class="author1">There are object wrapper types for the other primitives as well: <code
                class="calibre18">Number</code> for numbers, <code class="calibre18">Boolean</code> for booleans, <code
                class="calibre18">Symbol</code> for symbols, and <code class="calibre18">BigInt</code> for bigints
              (there are no object wrappers for <code class="calibre18">null</code> and <code
                class="calibre18">undefined</code>).</p>

            <p class="author1">These wrapper types exist as a convenience to provide methods on the
              primitive&nbsp;values and to provide static methods (e.g., <code
                class="calibre18">String.fromCharCode</code>). But there’s usually no reason to instantiate them
              directly.</p>

            <p class="author1">TypeScript models this distinction by having distinct types for the primitives and their
              object wrappers:</p>

            <ul class="printings">
              <li class="calibre12">
                <p class="author1"><code class="calibre18">string</code> and <code class="calibre18">String</code></p>
              </li>
              <li class="calibre12">
                <p class="author1"><code class="calibre18">number</code> and <code class="calibre18">Number</code></p>
              </li>
              <li class="calibre12">
                <p class="author1"><code class="calibre18">boolean</code> and <code class="calibre18">Boolean</code></p>
              </li>
              <li class="calibre12">
                <p class="author1"><code class="calibre18">symbol</code> and <code class="calibre18">Symbol</code></p>
              </li>
              <li class="calibre12">
                <p class="author1"><code class="calibre18">bigint</code> and <code class="calibre18">BigInt</code></p>
              </li>
            </ul>

            <p class="author1">It’s<a data-primary="Java" data-secondary="String objects" data-type="indexterm"
                id="calibre_link-338" class="calibre9"></a> easy to inadvertently type <code
                class="calibre18">String</code> (especially if you’re coming from Java or C#) and it even seems to work,
              at least initially:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">function</code> <code class="nx">getStringLen</code><code class="p">(</code><code class="nx">foo</code>: <code class="nx">String</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">foo</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code>
<code class="p">}</code>

<code class="nx">getStringLen</code><code class="p">(</code><code class="s">"hello"</code><code class="p">);</code>  <code class="c">// OK</code>
<code class="nx">getStringLen</code><code class="p">(</code><code class="kd">new</code> <code class="nb">String</code><code class="p">(</code><code class="s">"hello"</code><code class="p">));</code>  <code class="c">// OK</code></pre>

            <p class="author1">But things go awry when you try to pass a <code class="calibre18">String</code> object to
              a method that expects a <code class="calibre18">string</code>:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">isGreeting</code><code class="p">(</code><code class="nx">phrase</code>: <code class="nx">String</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="p">[</code>
    <code class="s">'hello'</code><code class="p">,</code>
    <code class="s">'good day'</code>
  <code class="p">].</code><code class="nx">includes</code><code class="p">(</code><code class="nx">phrase</code><code class="p">);</code>
          <code class="c">// ~~~~~~</code>
          <code class="c">// Argument of type 'String' is not assignable to parameter</code>
          <code class="c">// of type 'string'.</code>
          <code class="c">// 'string' is a primitive, but 'String' is a wrapper object;</code>
          <code class="c">// prefer using 'string' when possible</code>
<code class="p">}</code></pre>

            <p class="author1">So <code class="calibre18">string</code> is assignable to <code
                class="calibre18">String</code>, but <code class="calibre18">String</code> is not assignable to <code
                class="calibre18">string</code>. Confusing? Follow the advice in the error message and stick with <code
                class="calibre18">string</code>. All the type declarations that ship with TypeScript use it, as do the
              typings for almost all other libraries.</p>

            <p class="author1">Another way you can wind up with wrapper objects is if you provide an explicit type
              annotation with a capital letter:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">const</code> <code class="nx">s</code>: <code class="nx">String</code> <code class="o">=</code> <code class="s">"primitive"</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">n</code>: <code class="nx">Number</code> <code class="o">=</code> <code class="mi">12</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">b</code>: <code class="nx">Boolean</code> <code class="o">=</code> <code class="kd">true</code><code class="p">;</code></pre>

            <p class="author1">Of course, the values at runtime are still primitives, not objects. But TypeScript
              permits these declarations because the primitive types are assignable to the object wrappers. These
              annotations are both misleading and redundant (<a href="#calibre_link-11" class="calibre9">Item 19</a>).
              Better to stick with the primitive types.</p>

            <p class="author1">As a final note, it’s OK to call <code class="calibre18">BigInt</code> and <code
                class="calibre18">Symbol</code> without <code class="calibre18">new</code>, since these create
              primitives:</p>
            <pre data-type="programlisting" class="calibre17">&gt; <strong class="calibre32">typeof BigInt(1234)</strong>
"bigint"
&gt; <strong class="calibre32">typeof Symbol('sym')</strong>
"symbol"</pre>

            <p class="author1">These are the <code class="calibre18">BigInt</code> and <code
                class="calibre18">Symbol</code> <em class="calibre3">values</em>, not the TypeScript types (<a
                href="#calibre_link-776" class="calibre9">Item 8</a>). Calling them results in values of type <code
                class="calibre18">bigint</code> and <code class="calibre18">symbol</code>.</p>








            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-877">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">Understand how object wrapper types are used to provide methods on primitive
                      values. Avoid instantiating them or using them directly.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Avoid TypeScript object wrapper types. Use the primitive types instead: <code
                        class="calibre18">string</code> instead of <code class="calibre18">String</code>, <code
                        class="calibre18">number</code> instead of <code class="calibre18">Number</code>, <code
                        class="calibre18">boolean</code> instead of <code class="calibre18">Boolean</code>, <code
                        class="calibre18">symbol</code> instead of <code class="calibre18">Symbol</code>, and <code
                        class="calibre18">bigint</code> instead of <code class="calibre18">BigInt</code>.<a
                        data-primary="" data-startref="bigint02" data-type="indexterm" id="calibre_link-130"
                        class="calibre9"></a><a data-primary="" data-startref="object02" data-type="indexterm"
                        id="calibre_link-440" class="calibre9"></a><a data-primary="" data-startref="symb02"
                        data-type="indexterm" id="calibre_link-524" class="calibre9"></a><a data-primary=""
                        data-startref="undef02" data-type="indexterm" id="calibre_link-703" class="calibre9"></a><a
                        data-primary="" data-startref="nullp02" data-type="indexterm" id="calibre_link-431"
                        class="calibre9"></a><a data-primary="" data-startref="boolean02" data-type="indexterm"
                        id="calibre_link-132" class="calibre9"></a><a data-primary="" data-startref="number02"
                        data-type="indexterm" id="calibre_link-435" class="calibre9"></a><a data-primary=""
                        data-startref="string02" data-type="indexterm" id="calibre_link-513" class="calibre9"></a><a
                        data-primary="" data-startref="TSobject02" data-type="indexterm" id="calibre_link-653"
                        class="calibre9"></a></p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>













        <section data-pdf-bookmark="Item 11: Recognize the Limits of Excess Property Checking" data-type="sect1"
          class="praise">
          <div class="praise" id="calibre_link-758">
            <h1 class="calibre16">Item 11: Recognize the Limits of Excess Property Checking</h1>

            <p class="author1">When<a data-primary="type system" data-secondary="excess property checking limits"
                data-type="indexterm" id="calibre_link-646" class="calibre9"></a><a
                data-primary="excess property checking" data-secondary="limits of" data-type="indexterm"
                id="calibre_link-261" class="calibre9"></a> you assign an object literal to a variable with a declared
              type, TypeScript makes sure it has the properties of that type <em class="calibre3">and no others</em>:
            </p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Room</code> <code class="p">{</code>
  <code class="nx">numDoors</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">ceilingHeightFt</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">const</code> <code class="nx">r</code>: <code class="nx">Room</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">numDoors</code>: <code class="nx">1</code><code class="p">,</code>
  <code class="nx">ceilingHeightFt</code>: <code class="nx">10</code><code class="p">,</code>
  <code class="nx">elephant</code><code class="o">:</code> <code class="s">'present'</code><code class="p">,</code>
<code class="c">// ~~~~~~~~~~~~~~~~~~ Object literal may only specify known properties,</code>
<code class="c">//                    and 'elephant' does not exist in type 'Room'</code>
<code class="p">};</code></pre>

            <p class="author1">While it is odd that there’s an <code class="calibre18">elephant</code> property, this
              error doesn’t make much sense from a structural typing point of view (<a href="#calibre_link-10"
                class="calibre9">Item 4</a>). That constant <em class="calibre3">is</em> assignable to the <code
                class="calibre18">Room</code> type, which you can see by introducing an intermediate variable:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">const</code> <code class="nx">obj</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">numDoors</code>: <code class="nx">1</code><code class="p">,</code>
  <code class="nx">ceilingHeightFt</code>: <code class="nx">10</code><code class="p">,</code>
  <code class="nx">elephant</code><code class="o">:</code> <code class="s">'present'</code><code class="p">,</code>
<code class="p">};</code>
<code class="kd">const</code> <code class="nx">r</code>: <code class="nx">Room</code> <code class="o">=</code> <code class="nx">obj</code><code class="p">;</code>  <code class="c">// OK</code></pre>

            <p class="author1">The type of <code class="calibre18">obj</code> is inferred as <code
                class="calibre18">{ numDoors: number; ceilingHeightFt: number; elephant: string }</code>. Because this
              type includes a subset of the values in the <code class="calibre18">Room</code> type, it is assignable to
              <code class="calibre18">Room</code>, and the code passes the type checker (see <a href="#calibre_link-47"
                class="calibre9">Item 7</a>).
            </p>

            <p class="author1">So what is different about these two examples? In the first you’ve triggered a process
              known as “excess property checking,” which helps catch an important class of errors that the structural
              type system would otherwise miss. But this process has its limits, and conflating it with regular
              assignability checks can make it harder to build an intuition for structural typing. Recognizing excess
              property checking as a distinct process will help you build a clearer mental model of TypeScript’s type
              system.</p>

            <p class="author1">As <a href="#calibre_link-777" class="calibre9">Item 1</a> explained, TypeScript goes
              beyond trying to flag code that will throw exceptions at runtime. It also tries to find code that doesn’t
              do what you intend. Here’s an example of the latter:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Options</code> <code class="p">{</code>
  <code class="nx">title</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">darkMode?</code>: <code class="nx">boolean</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">function</code> <code class="nx">createWindow</code><code class="p">(</code><code class="nx">options</code>: <code class="nx">Options</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">options</code><code class="p">.</code><code class="nx">darkMode</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">setDarkMode</code><code class="p">();</code>
  <code class="p">}</code>
  <code class="c">// ...</code>
<code class="p">}</code>
<code class="nx">createWindow</code><code class="p">({</code>
  <code class="nx">title</code><code class="o">:</code> <code class="s">'Spider Solitaire'</code><code class="p">,</code>
  <code class="nx">darkmode</code>: <code class="nx">true</code>
<code class="c">// ~~~~~~~~~~~~~ Object literal may only specify known properties, but</code>
<code class="c">//               'darkmode' does not exist in type 'Options'.</code>
<code class="c">//               Did you mean to write 'darkMode'?</code>
<code class="p">});</code></pre>

            <p class="author1">This code doesn’t throw any sort of error at runtime. But it’s also unlikely to do what
              you intended for the exact reason that TypeScript says: it should be <code
                class="calibre18">darkMode</code> (capital M), not <code class="calibre18">darkmode</code>.</p>

            <p class="author1">A<a data-primary="type checking, versus excess property checking" data-type="indexterm"
                id="calibre_link-569" class="calibre9"></a> purely structural type checker wouldn’t be able to spot this
              sort of error because the domain of the <code class="calibre18">Options</code> type is incredibly broad:
              it includes all objects with a <code class="calibre18">title</code> property that’s a <code
                class="calibre18">string</code> and <em class="calibre3">any other properties</em>, so long as those
              don’t include a <code class="calibre18">darkMode</code> property set to something other than <code
                class="calibre18">true</code> or <code class="calibre18">false</code>.</p>

            <p class="author1">It’s easy to forget how expansive TypeScript types can be. Here are a few more values
              that are assignable to <code class="calibre18">Options</code>:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">const</code> <code class="nx">o1</code>: <code class="nx">Options</code> <code class="o">=</code> <code class="nb">document</code><code class="p">;</code>  <code class="c">// OK</code>
<code class="kd">const</code> <code class="nx">o2</code>: <code class="nx">Options</code> <code class="o">=</code> <code class="kd">new</code> <code class="nx">HTMLAnchorElement</code><code class="p">;</code>  <code class="c">// OK</code></pre>

            <p class="author1">Both <code class="calibre18">document</code> and instances of <code
                class="calibre18">HTMLAnchorElement</code> have <code class="calibre18">title</code> properties that are
              strings, so these assignments are OK. <code class="calibre18">Options</code> is a broad type indeed!</p>

            <p class="author1">Excess property checking tries to rein this in without compromising the fundamentally
              structural nature of the type system. It does this by disallowing unknown properties specifically on
              object literals. (It’s sometimes called “strict object literal checking” for this reason.) Neither <code
                class="calibre18">document</code> nor <code class="calibre18">new HTMLAnchorElement</code> is an object
              literal, so they did not trigger the checks. But the <code class="calibre18">{title, darkmode}</code>
              object is, so it does:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">o</code>: <code class="nx">Options</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">darkmode</code>: <code class="nx">true</code><code class="p">,</code> <code class="nx">title</code><code class="o">:</code> <code class="s">'Ski Free'</code> <code class="p">};</code>
                  <code class="c">// ~~~~~~~~ 'darkmode' does not exist in type 'Options'...</code></pre>

            <p class="author1">This explains why using an intermediate variable without a type annotation makes the
              error go away:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">const</code> <code class="nx">intermediate</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">darkmode</code>: <code class="nx">true</code><code class="p">,</code> <code class="nx">title</code><code class="o">:</code> <code class="s">'Ski Free'</code> <code class="p">};</code>
<code class="kd">const</code> <code class="nx">o</code>: <code class="nx">Options</code> <code class="o">=</code> <code class="nx">intermediate</code><code class="p">;</code>  <code class="c">// OK</code></pre>

            <p class="author1">While the righthand side of the first line is an object literal, the righthand side of
              the second line (<code class="calibre18">intermediate</code>) is not, so excess property checking does not
              apply, and the error goes away.</p>

            <p class="author1">Excess property checking does not happen when you use a type assertion:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">const</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">darkmode</code>: <code class="nx">true</code><code class="p">,</code> <code class="nx">title</code><code class="o">:</code> <code class="s">'Ski Free'</code> <code class="p">}</code> <code class="kd">as</code> <code class="nx">Options</code><code class="p">;</code>  <code class="c">// OK</code></pre>

            <p class="author1">This is a good reason to prefer declarations to assertions (<a href="#calibre_link-27"
                class="calibre9">Item 9</a>).</p>

            <p class="author1">If you don’t want this sort of check, you can tell TypeScript to expect additional
              properties using an index signature:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">interface</code> <code class="nx">Options</code> <code class="p">{</code>
  <code class="nx">darkMode?</code>: <code class="nx">boolean</code><code class="p">;</code>
  <code class="p">[</code><code class="nx">otherOptions</code>: <code class="kd">string</code><code class="p">]</code><code class="o">:</code> <code class="nx">unknown</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">const</code> <code class="nx">o</code>: <code class="nx">Options</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">darkmode</code>: <code class="nx">true</code> <code class="p">};</code>  <code class="c">// OK</code></pre>

            <p class="author1"><a href="#calibre_link-796" class="calibre9">Item 15</a> discusses when this is and is
              not an appropriate way to model your data.</p>

            <p class="author1">A related check happens for “weak” types, which have only optional properties:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">LineChartOptions</code> <code class="p">{</code>
  <code class="nx">logscale?</code>: <code class="nx">boolean</code><code class="p">;</code>
  <code class="nx">invertedYAxis?</code>: <code class="nx">boolean</code><code class="p">;</code>
  <code class="nx">areaChart?</code>: <code class="nx">boolean</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">const</code> <code class="nx">opts</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">logScale</code>: <code class="nx">true</code> <code class="p">};</code>
<code class="kd">const</code> <code class="nx">o</code>: <code class="nx">LineChartOptions</code> <code class="o">=</code> <code class="nx">opts</code><code class="p">;</code>
   <code class="c">// ~ Type '{ logScale: boolean; }' has no properties in common</code>
   <code class="c">//   with type 'LineChartOptions'</code></pre>

            <p class="author1">From a structural point of view, the <code class="calibre18">LineChartOptions</code> type
              should include almost all objects. For weak types like this, TypeScript adds another check to make sure
              that the value type and declared type have at least one property in common. Much like excess property
              checking, this is effective at catching typos and isn’t strictly structural. But unlike excess property
              checking, it happens during all assignability checks involving weak types. Factoring out an intermediate
              variable doesn’t bypass this check.</p>

            <p class="author1">Excess property checking is an effective way of catching typos and other mistakes in
              property names that would otherwise be allowed by the structural typing system. It’s particularly useful
              with types like <code class="calibre18">Options</code> that contain optional fields. But it is also very
              limited in scope: it only applies to object literals. Recognize this limitation and distinguish between
              excess property checking and ordinary type checking. This will help you build a mental model of both.</p>

            <p class="author1">Factoring out a constant made an error go away here, but it can also introduce an error
              in other contexts. See <a href="#calibre_link-760" class="calibre9">Item 26</a> for examples of this.</p>








            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-878">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">When you assign an object literal to a variable or pass it as an argument to a
                      function, it undergoes excess property checking.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Excess property checking is an effective way to find errors, but it is distinct
                      from the usual structural assignability checks done by the TypeScript type checker. Conflating
                      these processes will make it harder for you to build a mental model of assignability.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Be aware of the limits of excess property checking: introducing an intermediate
                      variable will remove these checks.<a data-primary="" data-startref="TSexcess02"
                        data-type="indexterm" id="calibre_link-647" class="calibre9"></a><a data-primary=""
                        data-startref="EPlimit02" data-type="indexterm" id="calibre_link-262" class="calibre9"></a></p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>













        <section data-pdf-bookmark="Item 12: Apply Types to Entire Function Expressions When Possible" data-type="sect1"
          class="praise">
          <div class="praise" id="calibre_link-797">
            <h1 class="calibre16">Item 12: Apply Types to Entire Function Expressions When Possible</h1>

            <p class="author1">JavaScript<a data-primary="type system"
                data-secondary="applying type annotations to function expressions" data-type="indexterm"
                id="calibre_link-638" class="calibre9"></a><a data-primary="typeof fn" data-type="indexterm"
                id="calibre_link-667" class="calibre9"></a><a data-primary="functions"
                data-secondary="applying type annotations to function expressions" data-type="indexterm"
                id="calibre_link-276" class="calibre9"></a><a data-primary="JavaScript"
                data-secondary="function statements versus function expressions" data-type="indexterm"
                id="calibre_link-346" class="calibre9"></a><a data-primary="TypeScript"
                data-secondary="function statements versus function expressions" data-type="indexterm"
                id="calibre_link-677" class="calibre9"></a> (and TypeScript) distinguishes a function <em
                class="calibre3">statement</em> and a function <span class="calibre"><em
                  class="calibre3">expression</em></span>:</p>

            <pre data-code-language="ts" data-type="programlisting" id="calibre_link-879"
              class="calibre17"><code class="kd">function</code> <code class="nx">rollDice1</code><code class="p">(</code><code class="nx">sides</code>: <code class="nx">number</code><code class="p">)</code><code class="o">:</code> <code class="kt">number</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">}</code>  <code class="c">// Statement</code>
<code class="kd">const</code> <code class="nx">rollDice2</code> <code class="o">=</code> <code class="kd">function</code><code class="p">(</code><code class="nx">sides</code>: <code class="nx">number</code><code class="p">)</code><code class="o">:</code> <code class="kt">number</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">};</code>  <code class="c">// Expression</code>
<code class="kd">const</code> <code class="nx">rollDice3</code> <code class="o">=</code> <code class="p">(</code><code class="nx">sides</code>: <code class="nx">number</code><code class="p">)</code><code class="o">:</code> <code class="kt">number</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">};</code>  <code class="c">// Also expression</code></pre>

            <p class="author1">An advantage of function expressions in TypeScript is that you can apply a type
              declaration to the entire function at once, rather than specifying the types of the parameters and return
              type individually:</p>

            <pre data-code-language="ts" data-type="programlisting" id="calibre_link-880"
              class="calibre17"><code class="kd">type</code> <code class="nx">DiceRollFn</code> <code class="o">=</code> <code class="p">(</code><code class="nx">sides</code>: <code class="nx">number</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kt">number</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">rollDice</code>: <code class="nx">DiceRollFn</code> <code class="o">=</code> <code class="nx">sides</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">};</code></pre>

            <p class="author1">If you mouse over <code class="calibre18">sides</code> in your editor, you’ll see that
              TypeScript knows its type is <code class="calibre18">number</code>. The function type doesn’t provide much
              value in such a simple example, but the technique does open up a number of possibilities.</p>

            <p class="author1">One is reducing repetition. If you wanted to write several functions for doing arithmetic
              on numbers, for instance, you could write them like this:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">function</code> <code class="nx">add</code><code class="p">(</code><code class="nx">a</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">b</code>: <code class="nx">number</code><code class="p">)</code> <code class="p">{</code> <code class="kd">return</code> <code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code><code class="p">;</code> <code class="p">}</code>
<code class="kd">function</code> <code class="nx">sub</code><code class="p">(</code><code class="nx">a</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">b</code>: <code class="nx">number</code><code class="p">)</code> <code class="p">{</code> <code class="kd">return</code> <code class="nx">a</code> <code class="o">-</code> <code class="nx">b</code><code class="p">;</code> <code class="p">}</code>
<code class="kd">function</code> <code class="nx">mul</code><code class="p">(</code><code class="nx">a</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">b</code>: <code class="nx">number</code><code class="p">)</code> <code class="p">{</code> <code class="kd">return</code> <code class="nx">a</code> <code class="o">*</code> <code class="nx">b</code><code class="p">;</code> <code class="p">}</code>
<code class="kd">function</code> <code class="nx">div</code><code class="p">(</code><code class="nx">a</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">b</code>: <code class="nx">number</code><code class="p">)</code> <code class="p">{</code> <code class="kd">return</code> <code class="nx">a</code> <code class="o">/</code> <code class="nx">b</code><code class="p">;</code> <code class="p">}</code></pre>

            <p class="author1">or consolidate the repeated function signatures with a single function type:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">type</code> <code class="nx">BinaryFn</code> <code class="o">=</code> <code class="p">(</code><code class="nx">a</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">b</code>: <code class="nx">number</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kt">number</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">add</code>: <code class="nx">BinaryFn</code> <code class="o">=</code> <code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">sub</code>: <code class="nx">BinaryFn</code> <code class="o">=</code> <code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">a</code> <code class="o">-</code> <code class="nx">b</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">mul</code>: <code class="nx">BinaryFn</code> <code class="o">=</code> <code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">a</code> <code class="o">*</code> <code class="nx">b</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">div</code>: <code class="nx">BinaryFn</code> <code class="o">=</code> <code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">a</code> <code class="o">/</code> <code class="nx">b</code><code class="p">;</code></pre>

            <p class="author1">This has fewer type annotations than before, and they’re separated away from the function
              implementations. This makes the logic more apparent. You’ve also gained a check that the return type of
              all the function expressions is <code class="calibre18">number</code>.</p>

            <p class="author1">Libraries often provide types for common function signatures. For example, ReactJS
              provides a <code class="calibre18">MouseEventHandler</code> type that you can apply to an entire function
              rather than specifying <code class="calibre18">MouseEvent</code> as a type for the function’s parameter.
              If<a data-primary="callbacks" data-secondary="type declarations for" data-type="indexterm"
                id="calibre_link-150" class="calibre9"></a> you’re a library author, consider providing type
              declarations for common callbacks.</p>

            <p class="author1">Another<a data-primary="Twain, Mark" data-type="indexterm" id="calibre_link-555"
                class="calibre9"></a> place you might want to apply a type to a function expression is to match the
              signature of some other function. In a web browser, for example, the <code class="calibre18">fetch</code>
              function issues an HTTP request for some resource:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">const</code> <code class="nx">responseP</code> <code class="o">=</code> <code class="nx">fetch</code><code class="p">(</code><code class="s">'/quote?by=Mark+Twain'</code><code class="p">);</code>  <code class="c">// Type is Promise&lt;Response&gt;</code></pre>

            <p class="author1">You extract data from the response via <code class="calibre18">response.json()</code> or
              <code class="calibre18">response.text()</code>:
            </p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">async</code> <code class="kd">function</code> <code class="nx">getQuote() {</code>
  <code class="kd">const</code> <code class="nx">response</code> <code class="o">=</code> <code class="kd">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="s">'/quote?by=Mark+Twain'</code><code class="p">);</code>
  <code class="kd">const</code> <code class="nx">quote</code> <code class="o">=</code> <code class="kd">await</code> <code class="nx">response</code><code class="p">.</code><code class="nx">json</code><code class="p">();</code>
  <code class="kd">return</code> <code class="nx">quote</code><code class="p">;</code>
<code class="p">}</code>
<code class="c">// {</code>
<code class="c">//   "quote": "If you tell the truth, you don't have to remember anything.",</code>
<code class="c">//   "source": "notebook",</code>
<code class="c">//   "date": "1894"</code>
<code class="c">// }</code></pre>

            <p class="author1">(See <a href="#calibre_link-23" class="calibre9">Item 25</a> for more on Promises and
              <code class="calibre18">async</code>/<code class="calibre18">await</code>.)
            </p>

            <p class="author1">There’s a bug here: if the request for <code class="calibre18">/quote</code> fails, the
              response body is likely to contain an explanation like “404 Not Found.” This<a data-primary="JSON"
                data-type="indexterm" id="calibre_link-368" class="calibre9"></a> isn’t JSON, so <code
                class="calibre18">response.json()</code> will return a rejected Promise with a message about invalid
              JSON. This obscures the real error, which was a 404.</p>

            <p class="author1">It’s easy to forget that an error response with <code class="calibre18">fetch</code> does
              not result in a rejected Promise. Let’s write a <code class="calibre18">checkedFetch</code> function to do
              the status check for us. The type declarations for <code class="calibre18">fetch</code> in <code
                class="calibre18">lib.dom.d.ts</code> look like this:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">declare</code> <code class="kd">function</code> <code class="nx">fetch</code><code class="p">(</code>
  <code class="nx">input</code>: <code class="nx">RequestInfo</code><code class="p">,</code> <code class="nx">init?</code>: <code class="nx">RequestInit</code>
<code class="p">)</code><code class="o">:</code> <code class="nx">Promise</code><code class="o">&lt;</code><code class="nx">Response</code><code class="o">&gt;</code><code class="p">;</code></pre>

            <p class="author1">So you can write <code class="calibre18">checkedFetch</code> like this:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">async</code> <code class="kd">function</code> <code class="nx">checkedFetch</code><code class="p">(</code><code class="nx">input</code>: <code class="nx">RequestInfo</code><code class="p">,</code> <code class="nx">init?</code>: <code class="nx">RequestInit</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">response</code> <code class="o">=</code> <code class="kd">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">input</code><code class="p">,</code> <code class="nx">init</code><code class="p">);</code>
  <code class="kd">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">response</code><code class="p">.</code><code class="nx">ok</code><code class="p">)</code> <code class="p">{</code>
    <code class="c">// Converted to a rejected Promise in an async function</code>
    <code class="kd">throw</code> <code class="kd">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s">'Request failed: '</code> <code class="o">+</code> <code class="nx">response</code><code class="p">.</code><code class="nx">status</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="kd">return</code> <code class="nx">response</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">This works, but it can be written more concisely:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">checkedFetch</code>: <code class="nx">typeof</code> <code class="nx">fetch</code> <code class="o">=</code> <code class="kd">async</code> <code class="p">(</code><code class="nx">input</code><code class="p">,</code> <code class="nx">init</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">response</code> <code class="o">=</code> <code class="kd">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">input</code><code class="p">,</code> <code class="nx">init</code><code class="p">);</code>
  <code class="kd">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">response</code><code class="p">.</code><code class="nx">ok</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">throw</code> <code class="kd">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s">'Request failed: '</code> <code class="o">+</code> <code class="nx">response</code><code class="p">.</code><code class="nx">status</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="kd">return</code> <code class="nx">response</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">We’ve changed from a function statement to a function expression and applied a type
              (<code class="calibre18">typeof fetch</code>) to the entire function. This allows TypeScript to infer the
              types of the <code class="calibre18">input</code> and <code class="calibre18">init</code> parameters.</p>

            <p class="author1">The type annotation also guarantees that the return type of <code
                class="calibre18">checkedFetch</code> will be the same as that of <code class="calibre18">fetch</code>.
              Had you written <code class="calibre18">return</code> instead of <code class="calibre18">throw</code>, for
              example, TypeScript would have caught the mistake:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">checkedFetch</code>: <code class="nx">typeof</code> <code class="nx">fetch</code> <code class="o">=</code> <code class="kd">async</code> <code class="p">(</code><code class="nx">input</code><code class="p">,</code> <code class="nx">init</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="c">//  ~~~~~~~~~~~~   Type 'Promise&lt;Response | HTTPError&gt;'</code>
  <code class="c">//                     is not assignable to type 'Promise&lt;Response&gt;'</code>
  <code class="c">//                   Type 'Response | HTTPError' is not assignable</code>
  <code class="c">//                       to type 'Response'</code>
  <code class="kd">const</code> <code class="nx">response</code> <code class="o">=</code> <code class="kd">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">input</code><code class="p">,</code> <code class="nx">init</code><code class="p">);</code>
  <code class="kd">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">response</code><code class="p">.</code><code class="nx">ok</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">return</code> <code class="kd">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s">'Request failed: '</code> <code class="o">+</code> <code class="nx">response</code><code class="p">.</code><code class="nx">status</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="kd">return</code> <code class="nx">response</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">The same mistake in the first example would likely have led to an error, but in the code
              that called <code class="calibre18">checkedFetch</code>, rather than in the implementation.</p>

            <p class="author1">In addition to being more concise, typing this entire function expression instead of its
              parameters has given you better safety. When you’re writing a function that has the same type signature as
              another one, or writing many functions with the same type signature, consider whether you can apply a type
              declaration to entire functions, rather than repeating types of parameters and return values.</p>








            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-881">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">Consider applying type annotations to entire function expressions, rather than to
                      their parameters and return type.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">If you’re writing the same type signature repeatedly, factor out a function type
                      or look for an existing one. If you’re a library author, provide types for common callbacks.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Use <code class="calibre18">typeof fn</code> to match the signature of another
                      function.<a data-primary="" data-startref="Fapply02" data-type="indexterm" id="calibre_link-277"
                        class="calibre9"></a><a data-primary="" data-startref="typeoffn02" data-type="indexterm"
                        id="calibre_link-668" class="calibre9"></a><a data-primary="" data-startref="TSapply02"
                        data-type="indexterm" id="calibre_link-639" class="calibre9"></a></p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>













        <section data-pdf-bookmark="Item 13: Know the Differences Between type and interface" data-type="sect1"
          class="praise">
          <div class="praise" id="calibre_link-48">
            <h1 class="calibre16">Item 13: Know the Differences Between type and interface</h1>

            <p class="author1">If<a data-primary="type system" data-secondary="type versus interface"
                data-type="indexterm" id="calibre_link-659" class="calibre9"></a><a data-primary="type construct"
                data-type="indexterm" id="calibre_link-570" class="calibre9"></a><a data-primary="interface construct"
                data-secondary="type versus interface" data-type="indexterm" id="calibre_link-326" class="calibre9"></a>
              you want to define a named type in TypeScript, you have two options. You can use a type, as shown here:
            </p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">TState</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">name</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">capital</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">or an interface:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">IState</code> <code class="p">{</code>
  <code class="nx">name</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">capital</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">(You could also use a <code class="calibre18">class</code>, but that is a JavaScript
              runtime concept that also introduces a value. See <a href="#calibre_link-776" class="calibre9">Item
                8</a>.)</p>

            <p class="author1">Which should you use, <code class="calibre18">type</code> or <code
                class="calibre18">interface</code>? The line between these two options has become increasingly blurred
              over the years, to the point that in many situations you can use either. You should be aware of the
              distinctions that remain between <code class="calibre18">type</code> and <code
                class="calibre18">interface</code> and be consistent about which you use in which situation. But you
              should also know how to write the same types using both, so that you’ll be comfortable reading TypeScript
              that uses either.</p>
            <div data-type="warning" type="warning" class="calibre26">
              <h6 class="calibre27">Warning</h6>
              <p class="author1">The examples in this item prefix type names with <code class="calibre18">I</code> or
                <code class="calibre18">T</code> solely to indicate how they were defined. You should not do this in
                your code! Prefixing interface types with <code class="calibre18">I</code> is common in C#, and this
                convention made some inroads in the early days of TypeScript. But it is considered bad style today
                because it’s unnecessary, adds little value, and is not consistently followed in the standard libraries.
              </p>
            </div>

            <p class="author1">First, the similarities: the State types are nearly indistinguishable from one another.
              If you define an <code class="calibre18">IState</code> or a <code class="calibre18">TState</code> value
              with an extra property, the errors you get are character-by-character identical:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">wyoming</code>: <code class="nx">TState</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">name</code><code class="o">:</code> <code class="s">'Wyoming'</code><code class="p">,</code>
  <code class="nx">capital</code><code class="o">:</code> <code class="s">'Cheyenne'</code><code class="p">,</code>
  <code class="nx">population</code>: <code class="nx">500_000</code>
<code class="c">// ~~~~~~~~~~~~~~~~~~ Type ... is not assignable to type 'TState'</code>
<code class="c">//                    Object literal may only specify known properties, and</code>
<code class="c">//                    'population' does not exist in type 'TState'</code>
<code class="p">};</code></pre>

            <p class="author1">You can use an index signature with both <code class="calibre18">interface</code> and
              <code class="calibre18">type</code>:
            </p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">TDict</code> <code class="o">=</code> <code class="p">{</code> <code class="p">[</code><code class="nx">key</code>: <code class="kd">string</code><code class="p">]</code><code class="o">:</code> <code class="kt">string</code> <code class="p">};</code>
<code class="kd">interface</code> <code class="nx">IDict</code> <code class="p">{</code>
  <code class="p">[</code><code class="nx">key</code>: <code class="kd">string</code><code class="p">]</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">You can also define function types with either:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">type</code> <code class="nx">TFn</code> <code class="o">=</code> <code class="p">(</code><code class="nx">x</code>: <code class="nx">number</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kt">string</code><code class="p">;</code>
<code class="kd">interface</code> <code class="nx">IFn</code> <code class="p">{</code>
  <code class="p">(</code><code class="nx">x</code>: <code class="nx">number</code><code class="p">)</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">const</code> <code class="nx">toStrT</code>: <code class="nx">TFn</code> <code class="o">=</code> <code class="nx">x</code> <code class="o">=&gt;</code> <code class="s">''</code> <code class="o">+</code> <code class="nx">x</code><code class="p">;</code>  <code class="c">// OK</code>
<code class="kd">const</code> <code class="nx">toStrI</code>: <code class="nx">IFn</code> <code class="o">=</code> <code class="nx">x</code> <code class="o">=&gt;</code> <code class="s">''</code> <code class="o">+</code> <code class="nx">x</code><code class="p">;</code>  <code class="c">// OK</code></pre>

            <p class="author1">The type alias looks more natural for this straightforward function type, but if the type
              has properties as well, then the declarations start to look more alike:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">TFnWithProperties</code> <code class="o">=</code> <code class="p">{</code>
  <code class="p">(</code><code class="nx">x</code>: <code class="nx">number</code><code class="p">)</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>
  <code class="nx">prop</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">interface</code> <code class="nx">IFnWithProperties</code> <code class="p">{</code>
  <code class="p">(</code><code class="nx">x</code>: <code class="nx">number</code><code class="p">)</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>
  <code class="nx">prop</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">You can remember this syntax by reminding yourself that in JavaScript, functions are
              callable objects.</p>

            <p class="author1">Both type aliases and interfaces can be generic:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">TPair</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">first</code>: <code class="nx">T</code><code class="p">;</code>
  <code class="nx">second</code>: <code class="nx">T</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">interface</code> <code class="nx">IPair</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="p">{</code>
  <code class="nx">first</code>: <code class="nx">T</code><code class="p">;</code>
  <code class="nx">second</code>: <code class="nx">T</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">An <code class="calibre18">interface</code> can extend a <code
                class="calibre18">type</code> (with some caveats, explained momentarily), and a <code
                class="calibre18">type</code> can extend an <code class="calibre18">interface</code>:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">interface</code> <code class="nx">IStateWithPop</code> <code class="kd">extends</code> <code class="nx">TState</code> <code class="p">{</code>
  <code class="nx">population</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">type</code> <code class="nx">TStateWithPop</code> <code class="o">=</code> <code class="nx">IState</code> <code class="o">&amp;</code> <code class="p">{</code> <code class="nx">population</code>: <code class="nx">number</code><code class="p">;</code> <code class="p">};</code></pre>

            <p class="author1">Again, these types are identical. The caveat is that an <code
                class="calibre18">interface</code> cannot extend a complex type like a<a data-primary="union types"
                data-secondary="extending" data-type="indexterm" id="calibre_link-710" class="calibre9"></a> union type.
              If you want to do that, you’ll need to use <code class="calibre18">type</code> and <code
                class="calibre18">&amp;</code>.</p>

            <p class="author1">A<a data-primary="classes" data-secondary="implements" data-type="indexterm"
                id="calibre_link-154" class="calibre9"></a> class can implement either an <code
                class="calibre18">interface</code> or a simple type:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">class</code> <code class="nx">StateT</code> <code class="kd">implements</code> <code class="nx">TState</code> <code class="p">{</code>
  <code class="nx">name</code>: <code class="kd">string</code> <code class="o">=</code> <code class="s">''</code><code class="p">;</code>
  <code class="nx">capital</code>: <code class="kd">string</code> <code class="o">=</code> <code class="s">''</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">class</code> <code class="nx">StateI</code> <code class="kd">implements</code> <code class="nx">IState</code> <code class="p">{</code>
  <code class="nx">name</code>: <code class="kd">string</code> <code class="o">=</code> <code class="s">''</code><code class="p">;</code>
  <code class="nx">capital</code>: <code class="kd">string</code> <code class="o">=</code> <code class="s">''</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">Those are the similarities. What about the differences? You’ve seen one
              already&mdash;there are union <code class="calibre18">type</code>s but no union <code
                class="calibre18">interface</code>s:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">type</code> <code class="nx">AorB</code> <code class="o">=</code> <code class="s">'a'</code> <code class="o">|</code> <code class="s">'b'</code><code class="p">;</code></pre>

            <p class="author1">Extending union types can be useful. If you have separate types for <code
                class="calibre18">Input</code> and <code class="calibre18">Output</code> variables and a mapping from
              name to variable:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">Input</code> <code class="o">=</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">};</code>
<code class="kd">type</code> <code class="nx">Output</code> <code class="o">=</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">};</code>
<code class="kd">interface</code> <code class="nx">VariableMap</code> <code class="p">{</code>
  <code class="p">[</code><code class="nx">name</code>: <code class="kd">string</code><code class="p">]</code><code class="o">:</code> <code class="nx">Input</code> <code class="o">|</code> <code class="nx">Output</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">then you might want a type that attaches the name to the variable. This would be:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">type</code> <code class="nx">NamedVariable</code> <code class="o">=</code> <code class="p">(</code><code class="nx">Input</code> <code class="o">|</code> <code class="nx">Output</code><code class="p">)</code> <code class="o">&amp;</code> <code class="p">{</code> <code class="nx">name</code>: <code class="kd">string</code> <code class="p">};</code></pre>

            <p class="author1">This type cannot be expressed with <code class="calibre18">interface</code>. A <code
                class="calibre18">type</code> is, in general, more capable than an <code
                class="calibre18">interface</code>. It can be a union, and it can also take advantage of more advanced
              features like mapped or conditional types.</p>

            <p class="author1">It can also more easily express tuple and array types:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">type</code> <code class="nx">Pair</code> <code class="o">=</code> <code class="p">[</code><code class="kt">number</code><code class="p">,</code> <code class="kt">number</code><code class="p">];</code>
<code class="kd">type</code> <code class="nx">StringList</code> <code class="o">=</code> <code class="kt">string</code><code class="p">[];</code>
<code class="kd">type</code> <code class="nx">NamedNums</code> <code class="o">=</code> <code class="p">[</code><code class="kt">string</code><code class="p">,</code> <code class="p">...</code><code class="kt">number</code><code class="p">[]];</code></pre>

            <p class="author1">You can express something <em class="calibre3">like</em> a tuple using <code
                class="calibre18">interface</code>:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">interface</code> <code class="nx">Tuple</code> <code class="p">{</code>
  <code class="nx">0</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">1</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">length</code>: <code class="nx">2</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">const</code> <code class="nx">t</code>: <code class="nx">Tuple</code> <code class="o">=</code> <code class="p">[</code><code class="mi">10</code><code class="p">,</code> <code class="mi">20</code><code class="p">];</code>  <code class="c">// OK</code></pre>

            <p class="author1">But this is awkward and drops all the tuple methods like <code
                class="calibre18">concat</code>. Better to use a <code class="calibre18">type</code>. For more on the
              problems of numeric indices, see <a href="#calibre_link-21" class="calibre9">Item 16</a>.</p>

            <p class="author1">An<a data-primary="augmentation" data-type="indexterm" id="calibre_link-124"
                class="calibre9"></a> <code class="calibre18">interface</code> does have some abilities that a <code
                class="calibre18">type</code> doesn’t, however. One of these is that an <code
                class="calibre18">interface</code> can be <em class="calibre3">augmented</em>. Going back to the <code
                class="calibre18">State</code> example, you could have added a <code class="calibre18">population</code>
              field in another way:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">IState</code> <code class="p">{</code>
  <code class="nx">name</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">capital</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">interface</code> <code class="nx">IState</code> <code class="p">{</code>
  <code class="nx">population</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">const</code> <code class="nx">wyoming</code>: <code class="nx">IState</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">name</code><code class="o">:</code> <code class="s">'Wyoming'</code><code class="p">,</code>
  <code class="nx">capital</code><code class="o">:</code> <code class="s">'Cheyenne'</code><code class="p">,</code>
  <code class="nx">population</code>: <code class="nx">500_000</code>
<code class="p">};</code>  <code class="c">// OK</code></pre>

            <p class="author1">This<a data-primary="declaration merging" data-type="indexterm" id="calibre_link-206"
                class="calibre9"></a> is known as “declaration merging,” and it’s quite surprising if you’ve never seen
              it before. This is primarily used with type declaration files (<a data-type="xref"
                href="#calibre_link-791" class="calibre9">Chapter&nbsp;6</a>), and if you’re writing one, you should
              follow the norms and use <code class="calibre18">interface</code> to support it. The idea is that there
              may be gaps in your type declarations that users need to fill, and this is how they do it.</p>

            <p class="author1">TypeScript<a data-primary="Array interface" data-type="indexterm" id="calibre_link-105"
                class="calibre9"></a><a data-primary="tsconfig.json" data-secondary="merging and" data-type="indexterm"
                id="calibre_link-547" class="calibre9"></a><a data-primary="ES2015" data-secondary="merging and"
                data-type="indexterm" id="calibre_link-245" class="calibre9"></a><a data-primary="ES5"
                data-secondary="merging and" data-type="indexterm" id="calibre_link-253" class="calibre9"></a> uses
              merging to get different types for the different versions of JavaScript’s standard library. The <code
                class="calibre18">Array</code> interface, for example, is defined in <em
                class="calibre3">lib.es5.d.ts</em>. By default this is all you get. But if you add <code
                class="calibre18">ES2015</code> to the <code class="calibre18">lib</code> entry of your <em
                class="calibre3">tsconfig.json</em>, TypeScript will also include <em
                class="calibre3">lib.es2015.d.ts</em>. This includes another <code class="calibre18">Array</code>
              interface with additional methods like <code class="calibre18">find</code> that were added in ES2015. They
              get added to the other <code class="calibre18">Array</code> interface via merging. The net effect is that
              you get a single <code class="calibre18">Array</code> type with exactly the right methods.</p>

            <p class="author1">Merging is supported in regular code as well as declarations, and you should be aware of
              the possibility. If it’s essential that no one ever augment your type, then use <code
                class="calibre18">type</code>.</p>

            <p class="author1">Returning to the question at the start of the item, should you use <code
                class="calibre18">type</code> or <code class="calibre18">interface</code>? For complex types, you have
              no choice: you need to use a type alias. But what about the simpler object types that can be represented
              either way? To answer this question, you should consider consistency and augmentation. Are you working in
              a codebase that consistently uses <code class="calibre18">interface</code>? Then stick with <code
                class="calibre18">interface</code>. Does it use <code class="calibre18">type</code>? Then use <code
                class="calibre18">type</code>.</p>

            <p class="author1">For projects without an established style, you should think about augmentation. Are you
              publishing type declarations for an API? Then it might be helpful for your users to be able to be able to
              merge in new fields via an <code class="calibre18">interface</code> when the API changes. So use <code
                class="calibre18">interface</code>. But for a type that’s used internally in your project, declaration
              merging is likely to be a mistake. So prefer <code class="calibre18">type</code>.</p>








            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-882">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">Understand the differences and similarities between <code
                        class="calibre18">type</code> and <code class="calibre18">interface</code>.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Know how to write the same types using either syntax.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">In deciding which to use in your project, consider the established style and
                      whether augmentation might be beneficial.<a data-primary="" data-startref="intconst02"
                        data-type="indexterm" id="calibre_link-327" class="calibre9"></a><a data-primary=""
                        data-startref="typeconst02" data-type="indexterm" id="calibre_link-571" class="calibre9"></a><a
                        data-primary="" data-startref="TStypevs02" data-type="indexterm" id="calibre_link-660"
                        class="calibre9"></a></p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>













        <section data-pdf-bookmark="Item 14: Use Type Operations and Generics to Avoid Repeating Yourself"
          data-type="sect1" class="praise">
          <div class="praise" id="calibre_link-759">
            <h1 class="calibre16">Item 14: Use Type Operations and Generics to Avoid Repeating Yourself</h1>

            <p class="author1">This<a data-primary="type system" data-secondary="avoiding repetition"
                data-type="indexterm" id="calibre_link-644" class="calibre9"></a><a
                data-primary="DRY (don’t repeat yourself) principle" data-type="indexterm" id="calibre_link-222"
                class="calibre9"></a><a data-primary="repetition, avoiding" data-type="indexterm" id="calibre_link-491"
                class="calibre9"></a> script prints the dimensions, surface areas, and volumes of a few cylinders:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s">'Cylinder 1 x 1 '</code><code class="p">,</code>
  <code class="s">'Surface area:'</code><code class="p">,</code> <code class="mi">6.283185</code> <code class="o">*</code> <code class="mi">1</code> <code class="o">*</code> <code class="mi">1</code> <code class="o">+</code> <code class="mi">6.283185</code> <code class="o">*</code> <code class="mi">1</code> <code class="o">*</code> <code class="mi">1</code><code class="p">,</code>
  <code class="s">'Volume:'</code><code class="p">,</code> <code class="mi">3.14159</code> <code class="o">*</code> <code class="mi">1</code> <code class="o">*</code> <code class="mi">1</code> <code class="o">*</code> <code class="mi">1</code><code class="p">);</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s">'Cylinder 1 x 2 '</code><code class="p">,</code>
  <code class="s">'Surface area:'</code><code class="p">,</code> <code class="mi">6.283185</code> <code class="o">*</code> <code class="mi">1</code> <code class="o">*</code> <code class="mi">1</code> <code class="o">+</code> <code class="mi">6.283185</code> <code class="o">*</code> <code class="mi">2</code> <code class="o">*</code> <code class="mi">1</code><code class="p">,</code>
  <code class="s">'Volume:'</code><code class="p">,</code> <code class="mi">3.14159</code> <code class="o">*</code> <code class="mi">1</code> <code class="o">*</code> <code class="mi">2</code> <code class="o">*</code> <code class="mi">1</code><code class="p">);</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s">'Cylinder 2 x 1 '</code><code class="p">,</code>
  <code class="s">'Surface area:'</code><code class="p">,</code> <code class="mi">6.283185</code> <code class="o">*</code> <code class="mi">2</code> <code class="o">*</code> <code class="mi">1</code> <code class="o">+</code> <code class="mi">6.283185</code> <code class="o">*</code> <code class="mi">2</code> <code class="o">*</code> <code class="mi">1</code><code class="p">,</code>
  <code class="s">'Volume:'</code><code class="p">,</code> <code class="mi">3.14159</code> <code class="o">*</code> <code class="mi">2</code> <code class="o">*</code> <code class="mi">2</code> <code class="o">*</code> <code class="mi">1</code><code class="p">);</code></pre>

            <p class="author1">Is this code uncomfortable to look at? It should be. It’s extremely repetitive, as though
              the same line was copied and pasted, then modified. It repeats both values and constants. This has allowed
              an error to creep in (did you spot it?). Much better would be to factor out some functions, a constant,
              and a loop:</p>

            <pre data-code-language="js" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">surfaceArea</code> <code class="o">=</code> <code class="p">(</code><code class="nx">r</code><code class="p">,</code> <code class="nx">h</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="mi">2</code> <code class="o">*</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">PI</code> <code class="o">*</code> <code class="nx">r</code> <code class="o">*</code> <code class="p">(</code><code class="nx">r</code> <code class="o">+</code> <code class="nx">h</code><code class="p">);</code>
<code class="kd">const</code> <code class="nx">volume</code> <code class="o">=</code> <code class="p">(</code><code class="nx">r</code><code class="p">,</code> <code class="nx">h</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">PI</code> <code class="o">*</code> <code class="nx">r</code> <code class="o">*</code> <code class="nx">r</code> <code class="o">*</code> <code class="nx">h</code><code class="p">;</code>
<code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="p">[</code><code class="nx">r</code><code class="p">,</code> <code class="nx">h</code><code class="p">]</code> <code class="kd">of</code> <code class="p">[[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">1</code><code class="p">],</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">],</code> <code class="p">[</code><code class="mi">2</code><code class="p">,</code> <code class="mi">1</code><code class="p">]])</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code>
    <code class="s">`Cylinder </code><code class="si">${</code><code class="nx">r</code><code class="si">}</code><code class="s"> x </code><code class="si">${</code><code class="nx">h</code><code class="si">}</code><code class="s">`</code><code class="p">,</code>
    <code class="s">`Surface area: </code><code class="si">${</code><code class="nx">surfaceArea</code><code class="p">(</code><code class="nx">r</code><code class="p">,</code> <code class="nx">h</code><code class="p">)</code><code class="si">}</code><code class="s">`</code><code class="p">,</code>
    <code class="s">`Volume: </code><code class="si">${</code><code class="nx">volume</code><code class="p">(</code><code class="nx">r</code><code class="p">,</code> <code class="nx">h</code><code class="p">)</code><code class="si">}</code><code class="s">`</code><code class="p">);</code>
<code class="p">}</code></pre>

            <p class="author1">This is the DRY principle: don’t repeat yourself. It’s the closest thing to universal
              advice that you’ll find in software development. Yet developers who assiduously avoid repetition in code
              may not think twice about it in types:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Person</code> <code class="p">{</code>
  <code class="nx">firstName</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">lastName</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">interface</code> <code class="nx">PersonWithBirthDate</code> <code class="p">{</code>
  <code class="nx">firstName</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">lastName</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">birth</code>: <code class="nx">Date</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">Duplication in types has many of the same problems as duplication in code. What if you
              decide to add an optional <code class="calibre18">middleName</code> field to <code
                class="calibre18">Person</code>? Now <code class="calibre18">Person</code> and <code
                class="calibre18">PersonWithBirthDate</code> have diverged.</p>

            <p class="author1">One reason that duplication is more common in types is that the mechanisms for factoring
              out shared patterns are less familiar than they are with code: what’s the type system equivalent of
              factoring out a helper function? By learning how to map between types, you can bring the benefits of DRY
              to your type definitions.</p>

            <p class="author1">The simplest way to reduce repetition is by naming your types. Rather than writing a
              distance function this way:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">distance</code><code class="p">(</code><code class="nx">a</code><code class="o">:</code> <code class="p">{</code><code class="nx">x</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">y</code>: <code class="nx">number</code><code class="p">},</code> <code class="nx">b</code><code class="o">:</code> <code class="p">{</code><code class="nx">x</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">y</code>: <code class="nx">number</code><code class="p">})</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">sqrt</code><code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">pow</code><code class="p">(</code><code class="nx">a</code><code class="p">.</code><code class="nx">x</code> <code class="o">-</code> <code class="nx">b</code><code class="p">.</code><code class="nx">x</code><code class="p">,</code> <code class="mi">2</code><code class="p">)</code> <code class="o">+</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">pow</code><code class="p">(</code><code class="nx">a</code><code class="p">.</code><code class="nx">y</code> <code class="o">-</code> <code class="nx">b</code><code class="p">.</code><code class="nx">y</code><code class="p">,</code> <code class="mi">2</code><code class="p">));</code>
<code class="p">}</code></pre>

            <p class="author1">create a name for the type and use that:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">interface</code> <code class="nx">Point2D</code> <code class="p">{</code>
  <code class="nx">x</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">y</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">function</code> <code class="nx">distance</code><code class="p">(</code><code class="nx">a</code>: <code class="nx">Point2D</code><code class="p">,</code> <code class="nx">b</code>: <code class="nx">Point2D</code><code class="p">)</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">}</code></pre>

            <p class="author1">This is the type system equivalent of factoring out a constant instead of writing it
              repeatedly. Duplicated types aren’t always so easy to spot. Sometimes they can be obscured by syntax. If
              several functions share the same type signature, for instance:</p>

            <pre data-code-language="ts" data-type="programlisting" id="calibre_link-883"
              class="calibre17"><code class="kd">function</code> <code class="nx">get</code><code class="p">(</code><code class="nx">url</code>: <code class="kd">string</code><code class="p">,</code> <code class="nx">opts</code>: <code class="nx">Options</code><code class="p">)</code><code class="o">:</code> <code class="nx">Promise</code><code class="o">&lt;</code><code class="nx">Response</code><code class="o">&gt;</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">}</code>
<code class="kd">function</code> <code class="nx">post</code><code class="p">(</code><code class="nx">url</code>: <code class="kd">string</code><code class="p">,</code> <code class="nx">opts</code>: <code class="nx">Options</code><code class="p">)</code><code class="o">:</code> <code class="nx">Promise</code><code class="o">&lt;</code><code class="nx">Response</code><code class="o">&gt;</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">}</code></pre>

            <p class="author1">Then you can factor out a named type for this signature:</p>

            <pre data-code-language="ts" data-type="programlisting" id="calibre_link-884"
              class="calibre17"><code class="kd">type</code> <code class="nx">HTTPFunction</code> <code class="o">=</code> <code class="p">(</code><code class="nx">url</code>: <code class="kd">string</code><code class="p">,</code> <code class="nx">opts</code>: <code class="nx">Options</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">Promise</code><code class="o">&lt;</code><code class="nx">Response</code><code class="o">&gt;</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">get</code>: <code class="nx">HTTPFunction</code> <code class="o">=</code> <code class="p">(</code><code class="nx">url</code><code class="p">,</code> <code class="nx">opts</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">};</code>
<code class="kd">const</code> <code class="nx">post</code>: <code class="nx">HTTPFunction</code> <code class="o">=</code> <code class="p">(</code><code class="nx">url</code><code class="p">,</code> <code class="nx">opts</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">};</code></pre>

            <p class="author1">For more on this, see <a href="#calibre_link-797" class="calibre9">Item 12</a>.</p>

            <p class="author1">What<a data-primary="extends" data-type="indexterm" id="calibre_link-267"
                class="calibre9"></a> about the <code class="calibre18">Person</code>/<code
                class="calibre18">PersonWithBirthDate</code> example? You can eliminate the repetition by making one
              interface extend the other:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Person</code> <code class="p">{</code>
  <code class="nx">firstName</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">lastName</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">interface</code> <code class="nx">PersonWithBirthDate</code> <code class="kd">extends</code> <code class="nx">Person</code> <code class="p">{</code>
  <code class="nx">birth</code>: <code class="nx">Date</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">Now you only need to write the additional fields. If the two interfaces share a subset of
              their fields, then you can factor out a base class with just these common fields. Continuing the analogy
              with code duplication, this is akin to writing <code class="calibre18">PI</code> and <code
                class="calibre18">2*PI</code> instead of <code class="calibre18">3.141593</code> and <code
                class="calibre18">6.283185</code>.</p>

            <p class="author1">You can also use the intersection operator (<code class="calibre18">&amp;</code>) to
              extend an existing type, though this is less common:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">type</code> <code class="nx">PersonWithBirthDate</code> <code class="o">=</code> <code class="nx">Person</code> <code class="o">&amp;</code> <code class="p">{</code> <code class="nx">birth</code>: <code class="nx">Date</code> <code class="p">};</code></pre>

            <p class="author1">This technique is most useful when you want to add some additional properties to a union
              type (which you cannot <code class="calibre18">extend</code>). For more on this, see <a
                href="#calibre_link-48" class="calibre9">Item 13</a>.</p>

            <p class="author1">You can also go the other direction. What if you have a type, <code
                class="calibre18">State</code>, which represents the state of an entire application, and another, <code
                class="calibre18">TopNavState</code>, which represents just a part?</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">State</code> <code class="p">{</code>
  <code class="nx">userId</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">pageTitle</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">recentFiles</code>: <code class="kd">string</code><code class="p">[];</code>
  <code class="nx">pageContents</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">interface</code> <code class="nx">TopNavState</code> <code class="p">{</code>
  <code class="nx">userId</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">pageTitle</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">recentFiles</code>: <code class="kd">string</code><code class="p">[];</code>
<code class="p">}</code></pre>

            <p class="author1">Rather than building up <code class="calibre18">State</code> by extending <code
                class="calibre18">TopNavState</code>, you’d like to define <code class="calibre18">TopNavState</code> as
              a subset of the fields in <code class="calibre18">State</code>. This way you can keep a single interface
              defining the state for the entire app.</p>

            <p class="author1">You<a data-primary="indexing" data-type="indexterm" id="calibre_link-320"
                class="calibre9"></a> can remove duplication in the types of the properties by indexing into <code
                class="calibre18">State</code>:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">TopNavState</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">userId</code>: <code class="nx">State</code><code class="p">[</code><code class="s">'userId'</code><code class="p">];</code>
  <code class="nx">pageTitle</code>: <code class="nx">State</code><code class="p">[</code><code class="s">'pageTitle'</code><code class="p">];</code>
  <code class="nx">recentFiles</code>: <code class="nx">State</code><code class="p">[</code><code class="s">'recentFiles'</code><code class="p">];</code>
<code class="p">};</code></pre>

            <p class="author1">While<a data-primary="in construct" data-secondary="in (mapped type)"
                data-type="indexterm" id="calibre_link-310" class="calibre9"></a><a data-primary="mapped types"
                data-type="indexterm" id="calibre_link-393" class="calibre9"></a> it’s longer, this <em
                class="calibre3">is</em> progress: a change in the type of <code class="calibre18">pageTitle</code> in
              <code class="calibre18">State</code> will get reflected in <code class="calibre18">TopNavState</code>. But
              it’s still repetitive. You can do better with a <em class="calibre3">mapped type</em>:
            </p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">TopNavState</code> <code class="o">=</code> <code class="p">{</code>
  <code class="p">[</code><code class="nx">k</code> <code class="kd">in</code> <code class="s">'userId'</code> <code class="o">|</code> <code class="s">'pageTitle'</code> <code class="o">|</code> <code class="s">'recentFiles'</code><code class="p">]</code><code class="o">:</code> <code class="nx">State</code><code class="p">[</code><code class="nx">k</code><code class="p">]</code>
<code class="p">};</code></pre>

            <p class="author1">Mousing over <code class="calibre18">TopNavState</code> shows that this definition is, in
              fact, exactly the same as the previous one (see <a data-type="xref" href="#calibre_link-798"
                class="calibre9">Figure&nbsp;2-10</a>).</p>

            <figure class="calibre28">
              <div class="figure" id="calibre_link-798">
                <img alt="efts 02in03" src="images/000016.png" class="calibre29" />
                <h6 class="calibre30"><span class="calibre">Figure 2-10. </span>Showing the expanded version of a mapped
                  type in your text editor. This is the same as the initial definition, but with less duplication.</h6>
              </div>
            </figure>

            <p class="author1">Mapped types are the type system equivalent of looping over the fields in an array. This
              particular pattern is so common that it’s part of the standard library, where it’s called <code
                class="calibre18">Pick</code>:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">type</code> <code class="nx">Pick</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">K</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code> <code class="p">[</code><code class="nx">k</code> <code class="kd">in</code> <code class="nx">K</code><code class="p">]</code><code class="o">:</code> <code class="nx">T</code><code class="p">[</code><code class="nx">k</code><code class="p">]</code> <code class="p">};</code></pre>

            <p class="author1">(This definition isn’t <em class="calibre3">quite</em> complete, as you will see.) You
              use it like this:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">type</code> <code class="nx">TopNavState</code> <code class="o">=</code> <code class="nx">Pick</code><code class="o">&lt;</code><code class="nx">State</code><code class="p">,</code> <code class="s">'userId'</code> <code class="o">|</code> <code class="s">'pageTitle'</code> <code class="o">|</code> <code class="s">'recentFiles'</code><code class="o">&gt;</code><code class="p">;</code></pre>

            <p class="author1"><code class="calibre18">Pick</code> is<a data-primary="generic types"
                data-type="indexterm" id="calibre_link-291" class="calibre9"></a><a data-primary="Pick type"
                data-type="indexterm" id="calibre_link-458" class="calibre9"></a> an example of a <em
                class="calibre3">generic type</em>. Continuing the analogy to removing code duplication, using <code
                class="calibre18">Pick</code> is the equivalent of calling a function. <code
                class="calibre18">Pick</code> takes two types, <code class="calibre18">T</code> and <code
                class="calibre18">K</code>, and returns a third, much as a function might take two values and return a
              third.</p>

            <p class="author1">Another form of duplication can arise with tagged unions. What if you want a type for
              just the tag?</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">interface</code> <code class="nx">SaveAction</code> <code class="p">{</code>
  <code class="nx">type</code>: <code class="s">'save'</code><code class="p">;</code>
  <code class="c">// ...</code>
<code class="p">}</code>
<code class="kd">interface</code> <code class="nx">LoadAction</code> <code class="p">{</code>
  <code class="nx">type</code>: <code class="s">'load'</code><code class="p">;</code>
  <code class="c">// ...</code>
<code class="p">}</code>
<code class="kd">type</code> <code class="nx">Action</code> <code class="o">=</code> <code class="nx">SaveAction</code> <code class="o">|</code> <code class="nx">LoadAction</code><code class="p">;</code>
<code class="kd">type</code> <code class="nx">ActionType</code> <code class="o">=</code> <code class="s">'save'</code> <code class="o">|</code> <code class="s">'load'</code><code class="p">;</code>  <code class="c">// Repeated types!</code></pre>

            <p class="author1">You can define <code class="calibre18">ActionType</code> without repeating yourself by
              indexing into the <code class="calibre18">Action</code> union:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">type</code> <code class="nx">ActionType</code> <code class="o">=</code> <code class="nx">Action</code><code class="p">[</code><code class="s">'type'</code><code class="p">];</code>  <code class="c">// Type is "save" | "load"</code></pre>

            <p class="author1">As you add more types to the <code class="calibre18">Action</code> union, <code
                class="calibre18">ActionType</code> will incorporate them automatically. This type is distinct from what
              you’d get using <code class="calibre18">Pick</code>, which would give you an interface with a <code
                class="calibre18">type</code> property:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">type</code> <code class="nx">ActionRec</code> <code class="o">=</code> <code class="nx">Pick</code><code class="o">&lt;</code><code class="nx">Action</code><code class="p">,</code> <code class="s">'type'</code><code class="o">&gt;</code><code class="p">;</code>  <code class="c">// {type: "save" | "load"}</code></pre>

            <p class="author1">If you’re defining a class which can be initialized and later updated, the type for the
              parameter to the update method will optionally include most of the same parameters as the constructor:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Options</code> <code class="p">{</code>
  <code class="nx">width</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">height</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">color</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">label</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">interface</code> <code class="nx">OptionsUpdate</code> <code class="p">{</code>
  <code class="nx">width?</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">height?</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">color?</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">label?</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">class</code> <code class="nx">UIWidget</code> <code class="p">{</code>
  <code class="kd">constructor</code><code class="p">(</code><code class="nx">init</code>: <code class="nx">Options</code><code class="p">)</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">}</code>
  <code class="nx">update</code><code class="p">(</code><code class="nx">options</code>: <code class="nx">OptionsUpdate</code><code class="p">)</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">}</code>
<code class="p">}</code></pre>

            <p class="author1">You<a data-primary="keyof" data-type="indexterm" id="calibre_link-373"
                class="calibre9"></a> can construct <code class="calibre18">OptionsUpdate</code> from <code
                class="calibre18">Options</code> using a mapped type and <code class="calibre18">keyof</code>:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">type</code> <code class="nx">OptionsUpdate</code> <code class="o">=</code> <code class="p">{[</code><code class="nx">k</code> <code class="kd">in</code> <code class="nx">keyof</code> <code class="nx">Options</code><code class="p">]</code><code class="o">?:</code> <code class="nx">Options</code><code class="p">[</code><code class="nx">k</code><code class="p">]};</code></pre>

            <p class="author1"><code class="calibre18">keyof</code> takes a type and gives you a union of the types of
              its keys:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">OptionsKeys</code> <code class="o">=</code> <code class="nx">keyof</code> <code class="nx">Options</code><code class="p">;</code>
<code class="c">// Type is "width" | "height" | "color" | "label"</code></pre>

            <p class="author1">The mapped type (<code class="calibre18">[k in keyof Options]</code>) iterates over these
              and looks up the corresponding value type in <code class="calibre18">Options</code>. The <code
                class="calibre18">?</code> makes each property optional. This<a data-primary="Partial type"
                data-type="indexterm" id="calibre_link-456" class="calibre9"></a> pattern is also extremely common and
              is enshrined in the standard library as <code class="calibre18">Partial</code>:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">class</code> <code class="nx">UIWidget</code> <code class="p">{</code>
  <code class="kd">constructor</code><code class="p">(</code><code class="nx">init</code>: <code class="nx">Options</code><code class="p">)</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">}</code>
  <code class="nx">update</code><code class="p">(</code><code class="nx">options</code>: <code class="nx">Partial</code><code class="o">&lt;</code><code class="nx">Options</code><code class="o">&gt;</code><code class="p">)</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">}</code>
<code class="p">}</code></pre>

            <p class="author1">You may also find yourself wanting to define a type that matches the shape of a <em
                class="calibre3">value</em>:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">INIT_OPTIONS</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">width</code>: <code class="nx">640</code><code class="p">,</code>
  <code class="nx">height</code>: <code class="nx">480</code><code class="p">,</code>
  <code class="nx">color</code><code class="o">:</code> <code class="s">'#00FF00'</code><code class="p">,</code>
  <code class="nx">label</code><code class="o">:</code> <code class="s">'VGA'</code><code class="p">,</code>
<code class="p">};</code>
<code class="kd">interface</code> <code class="nx">Options</code> <code class="p">{</code>
  <code class="nx">width</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">height</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">color</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">label</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">You<a data-primary="typeof operator" data-type="indexterm" id="calibre_link-670"
                class="calibre9"></a> can do so with <code class="calibre18">typeof</code>:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">type</code> <code class="nx">Options</code> <code class="o">=</code> <code class="kd">typeof</code> <code class="nx">INIT_OPTIONS</code><code class="p">;</code></pre>

            <p class="author1">This intentionally evokes JavaScript’s runtime <code class="calibre18">typeof</code>
              operator, but it operates at the level of TypeScript types and is much more precise. For more on <code
                class="calibre18">typeof</code>, see <a href="#calibre_link-776" class="calibre9">Item 8</a>. Be careful
              about deriving types from values, however. It’s usually better to define types first and declare that
              values are assignable to them. This makes your types more explicit and less subject to the vagaries of
              widening (<a href="#calibre_link-786" class="calibre9">Item 21</a>).</p>

            <p class="author1">Similarly, you may want to create a named type for the inferred return value of a
              function or method:</p>

            <pre data-code-language="ts" data-type="programlisting" id="calibre_link-885" class="calibre17"><code class="kd">function</code> <code class="nx">getUserInfo</code><code class="p">(</code><code class="nx">userId</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{</code>
  <code class="c">// ...</code>
  <code class="kd">return</code> <code class="p">{</code>
    <code class="nx">userId</code><code class="p">,</code>
    <code class="nx">name</code><code class="p">,</code>
    <code class="nx">age</code><code class="p">,</code>
    <code class="nx">height</code><code class="p">,</code>
    <code class="nx">weight</code><code class="p">,</code>
    <code class="nx">favoriteColor</code><code class="p">,</code>
  <code class="p">};</code>
<code class="p">}</code>
<code class="c">// Return type inferred as { userId: string; name: string; age: number, ... }</code></pre>

            <p class="author1">Doing this directly requires conditional types (see <a href="#calibre_link-767"
                class="calibre9">Item 50</a>). But, as we’ve seen before, the standard library defines generic types for
              common patterns like this one. In this<a data-primary="ReturnType" data-type="indexterm"
                id="calibre_link-494" class="calibre9"></a> case the <code class="calibre18">ReturnType</code> generic
              does exactly what you want:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">type</code> <code class="nx">UserInfo</code> <code class="o">=</code> <code class="nx">ReturnType</code><code class="o">&lt;</code><code class="kd">typeof</code> <code class="nx">getUserInfo</code><code class="o">&gt;</code><code class="p">;</code></pre>

            <p class="author1">Note that <code class="calibre18">ReturnType</code> operates on <code
                class="calibre18">typeof getUserInfo</code>, the function’s <em class="calibre3">type</em>, rather than
              <code class="calibre18">getUserInfo</code>, the function’s <em class="calibre3">value</em>. As with <code
                class="calibre18">typeof</code>, use this technique judiciously. Don’t get mixed up about your source of
              truth.
            </p>

            <p class="author1">Generic types are the equivalent of functions for types. And functions are the key to DRY
              for logic. So it should come as no surprise that generics are the key to DRY for types. But there’s a
              missing piece to this analogy. You use the type system to constrain the values you can map with a
              function: you add numbers, not objects; you find the area of shapes, not database records. How do you
              constrain the parameters in a generic type?</p>

            <p class="author1">You<a data-primary="Astaire, Fred" data-type="indexterm" id="calibre_link-117"
                class="calibre9"></a><a data-primary="Rogers, Ginger" data-type="indexterm" id="calibre_link-497"
                class="calibre9"></a> do so with <code class="calibre18">extends</code>. You can declare that any
              generic parameter <code class="calibre18">extends</code> a type. For example:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Name</code> <code class="p">{</code>
  <code class="nx">first</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">last</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">type</code> <code class="nx">DancingDuo</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kd">extends</code> <code class="nx">Name</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">[</code><code class="nx">T</code><code class="p">,</code> <code class="nx">T</code><code class="p">];</code>

<code class="kd">const</code> <code class="nx">couple1</code>: <code class="nx">DancingDuo</code><code class="o">&lt;</code><code class="nx">Name</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">[</code>
  <code class="p">{</code><code class="nx">first</code><code class="o">:</code> <code class="s">'Fred'</code><code class="p">,</code> <code class="nx">last</code><code class="o">:</code> <code class="s">'Astaire'</code><code class="p">},</code>
  <code class="p">{</code><code class="nx">first</code><code class="o">:</code> <code class="s">'Ginger'</code><code class="p">,</code> <code class="nx">last</code><code class="o">:</code> <code class="s">'Rogers'</code><code class="p">}</code>
<code class="p">];</code>  <code class="c">// OK</code>
<code class="kd">const</code> <code class="nx">couple2</code>: <code class="nx">DancingDuo</code><code class="o">&lt;</code><code class="p">{</code><code class="nx">first</code>: <code class="kd">string</code><code class="p">}</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">[</code>
                       <code class="c">// ~~~~~~~~~~~~~~~</code>
                       <code class="c">// Property 'last' is missing in type</code>
                       <code class="c">// '{ first: string; }' but required in type 'Name'</code>
  <code class="p">{</code><code class="nx">first</code><code class="o">:</code> <code class="s">'Sonny'</code><code class="p">},</code>
  <code class="p">{</code><code class="nx">first</code><code class="o">:</code> <code class="s">'Cher'</code><code class="p">}</code>
<code class="p">];</code></pre>

            <p class="author1"><code class="calibre18">{first: string}</code> does not extend <code
                class="calibre18">Name</code>, hence the error.</p>
            <div data-type="note" type="note" class="calibre24">
              <h6 class="calibre25">Note</h6>
              <p class="author1">At the moment, TypeScript always requires you to write out the generic parameter in a
                declaration. Writing <code class="calibre18">DancingDuo</code> instead of <code
                  class="calibre18">DancingDuo&lt;Name&gt;</code> won’t cut it. If you want TypeScript to infer the type
                of the generic parameter, you can use a carefully typed identity function:</p>

              <pre data-code-language="ts" data-type="programlisting" class="calibre43"><code class="kd">const</code> <code class="nx">dancingDuo</code> <code class="o">=</code> <code class="o">&lt;</code><code class="nx">T</code> <code class="kd">extends</code> <code class="nx">Name</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">x</code>: <code class="nx">DancingDuo</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">couple1</code> <code class="o">=</code> <code class="nx">dancingDuo</code><code class="p">([</code>
  <code class="p">{</code><code class="nx">first</code><code class="o">:</code> <code class="s">'Fred'</code><code class="p">,</code> <code class="nx">last</code><code class="o">:</code> <code class="s">'Astaire'</code><code class="p">},</code>
  <code class="p">{</code><code class="nx">first</code><code class="o">:</code> <code class="s">'Ginger'</code><code class="p">,</code> <code class="nx">last</code><code class="o">:</code> <code class="s">'Rogers'</code><code class="p">}</code>
<code class="p">]);</code>
<code class="kd">const</code> <code class="nx">couple2</code> <code class="o">=</code> <code class="nx">dancingDuo</code><code class="p">([</code>
  <code class="p">{</code><code class="nx">first</code><code class="o">:</code> <code class="s">'Bono'</code><code class="p">},</code>
<code class="c">// ~~~~~~~~~~~~~~</code>
  <code class="p">{</code><code class="nx">first</code><code class="o">:</code> <code class="s">'Prince'</code><code class="p">}</code>
<code class="c">// ~~~~~~~~~~~~~~~~</code>
<code class="c">//     Property 'last' is missing in type</code>
<code class="c">//     '{ first: string; }' but required in type 'Name'</code>
<code class="p">]);</code></pre>

              <p class="author1">For<a data-primary="inferringPick" data-type="indexterm" id="calibre_link-323"
                  class="calibre9"></a> a particularly useful variation on this, see <code
                  class="calibre18">inferringPick</code> in <a href="#calibre_link-760" class="calibre9">Item 26</a>.
              </p>
            </div>

            <p class="author1">You can use <code class="calibre18">extends</code> to complete the definition of <code
                class="calibre18">Pick</code> from earlier. If you run the original version through the type checker,
              you get an error:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">Pick</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">K</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>
  <code class="p">[</code><code class="nx">k</code> <code class="kd">in</code> <code class="nx">K</code><code class="p">]</code><code class="o">:</code> <code class="nx">T</code><code class="p">[</code><code class="nx">k</code><code class="p">]</code>
     <code class="c">// ~ Type 'K' is not assignable to type 'string | number | symbol'</code>
<code class="p">};</code></pre>

            <p class="author1"><code class="calibre18">K</code> is unconstrained in this type and is clearly too broad:
              it needs to be something that can be used as an index, namely, <code
                class="calibre18">string | number | symbol</code>. But you can get narrower than that&mdash;<code
                class="calibre18">K</code> should really be some subset of the keys of T, namely, <code
                class="calibre18">keyof T</code>:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">Pick</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">K</code> <code class="kd">extends</code> <code class="nx">keyof</code> <code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>
  <code class="p">[</code><code class="nx">k</code> <code class="kd">in</code> <code class="nx">K</code><code class="p">]</code><code class="o">:</code> <code class="nx">T</code><code class="p">[</code><code class="nx">k</code><code class="p">]</code>
<code class="p">};</code>  <code class="c">// OK</code></pre>

            <p class="author1">Thinking of types as sets of values (<a href="#calibre_link-47" class="calibre9">Item
                7</a>), it helps to read “extends” as “subset of” here.</p>

            <p class="author1">As you work with increasingly abstract types, try not to lose sight of the goal:
              accepting valid programs and rejecting invalid ones. In this case, the upshot of the constraint is that
              passing <code class="calibre18">Pick</code> the wrong key will produce an error:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">FirstLast</code> <code class="o">=</code> <code class="nx">Pick</code><code class="o">&lt;</code><code class="nx">Name</code><code class="p">,</code> <code class="s">'first'</code> <code class="o">|</code> <code class="s">'last'</code><code class="o">&gt;</code><code class="p">;</code>  <code class="c">// OK</code>
<code class="kd">type</code> <code class="nx">FirstMiddle</code> <code class="o">=</code> <code class="nx">Pick</code><code class="o">&lt;</code><code class="nx">Name</code><code class="p">,</code> <code class="s">'first'</code> <code class="o">|</code> <code class="s">'middle'</code><code class="o">&gt;</code><code class="p">;</code>
                           <code class="c">// ~~~~~~~~~~~~~~~~~~</code>
                           <code class="c">// Type '"middle"' is not assignable</code>
                           <code class="c">// to type '"first" | "last"'</code></pre>

            <p class="author1">Repetition and copy/paste coding are just as bad in type space as they are in value
              space. The constructs you use to avoid repetition in type space may be less familiar than those used for
              program logic, but they are worth the effort to learn. Don’t repeat yourself!</p>








            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-886">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">The DRY (don’t repeat yourself) principle applies to types as much as it applies
                      to logic.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Name types rather than repeating them. Use <code class="calibre18">extends</code>
                      to avoid repeating fields in interfaces.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Build an understanding of the tools provided by TypeScript to map between types.
                      These include <code class="calibre18">keyof</code>, <code class="calibre18">typeof</code>,
                      indexing, and mapped types.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Generic types are the equivalent of functions for types. Use them to map between
                      types instead of repeating types. Use <code class="calibre18">extends</code> to constrain generic
                      types.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Familiarize yourself with generic types defined in the standard library such as
                      <code class="calibre18">Pick</code>, <code class="calibre18">Partial</code>, and <code
                        class="calibre18">ReturnType</code>.<a data-primary="" data-startref="TSavoid02"
                        data-type="indexterm" id="calibre_link-645" class="calibre9"></a><a data-primary=""
                        data-startref="dry02" data-type="indexterm" id="calibre_link-223" class="calibre9"></a><a
                        data-primary="" data-startref="repavoid02" data-type="indexterm" id="calibre_link-492"
                        class="calibre9"></a>
                    </p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>













        <section data-pdf-bookmark="Item 15: Use Index Signatures for Dynamic Data" data-type="sect1" class="praise">
          <div class="praise" id="calibre_link-796">
            <h1 class="calibre16">Item 15: Use Index Signatures for Dynamic Data</h1>

            <p class="author1">One<a data-primary="type system" data-secondary="index signatures for dynamic data"
                data-type="indexterm" id="calibre_link-648" class="calibre9"></a><a data-primary="index signatures"
                data-secondary="for dynamic data" data-type="indexterm" id="calibre_link-317" class="calibre9"></a><a
                data-primary="dynamic data" data-type="indexterm" id="calibre_link-231" class="calibre9"></a> of the
              best features of JavaScript is its convenient syntax for creating objects:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">rocket</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">name</code><code class="o">:</code> <code class="s">'Falcon 9'</code><code class="p">,</code>
  <code class="nx">variant</code><code class="o">:</code> <code class="s">'Block 5'</code><code class="p">,</code>
  <code class="nx">thrust</code><code class="o">:</code> <code class="s">'7,607 kN'</code><code class="p">,</code>
<code class="p">};</code></pre>

            <p class="author1">Objects in JavaScript map string keys to values of any type. TypeScript lets you
              represent flexible mappings like this by specifying an <em class="calibre3">index signature</em> on the
              type:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">Rocket</code> <code class="o">=</code> <code class="p">{[</code><code class="nx">property</code>: <code class="kd">string</code><code class="p">]</code><code class="o">:</code> <code class="kt">string</code><code class="p">};</code>
<code class="kd">const</code> <code class="nx">rocket</code>: <code class="nx">Rocket</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">name</code><code class="o">:</code> <code class="s">'Falcon 9'</code><code class="p">,</code>
  <code class="nx">variant</code><code class="o">:</code> <code class="s">'v1.0'</code><code class="p">,</code>
  <code class="nx">thrust</code><code class="o">:</code> <code class="s">'4,940 kN'</code><code class="p">,</code>
<code class="p">};</code>  <code class="c">// OK</code></pre>

            <p class="author1">The <code class="calibre18">[property: string]: string</code> is the index signature. It
              specifies three things:</p>
            <dl class="praise">
              <dt class="calibre19">A name for the keys</dt>
              <dd class="calibre20">
                <p class="author1">This is purely for documentation; it is not used by the type checker in any way.</p>
              </dd>
              <dt class="calibre19">A type for the key</dt>
              <dd class="calibre20">
                <p class="author1">This needs to be some combination of <code class="calibre18">string</code>, <code
                    class="calibre18">number</code>, or <code class="calibre18">symbol</code>, but generally you just
                  want to use <code class="calibre18">string</code> (see <a href="#calibre_link-21"
                    class="calibre9">Item 16</a>).</p>
              </dd>
              <dt class="calibre19">A type for the values</dt>
              <dd class="calibre20">
                <p class="author1">This can be anything.</p>
              </dd>
            </dl>

            <p class="author1">While this does type check, it has a few downsides:</p>

            <ul class="printings">
              <li class="calibre12">
                <p class="author1">It allows any keys, including incorrect ones. Had you written <code
                    class="calibre18">Name</code> instead of <code class="calibre18">name</code>, it would have still
                  been a valid <code class="calibre18">Rocket</code> type.</p>
              </li>
              <li class="calibre12">
                <p class="author1">It doesn’t require any specific keys to be present. <code class="calibre18">{}</code>
                  is also a valid <code class="calibre18">Rocket</code>.</p>
              </li>
              <li class="calibre12">
                <p class="author1">It cannot have distinct types for different keys. For example, <code
                    class="calibre18">thrust</code> should probably be a <code class="calibre18">number</code>, not a
                  <code class="calibre18">string</code>.
                </p>
              </li>
              <li class="calibre12">
                <p class="author1">TypeScript’s language services can’t help you with types like this. As you’re typing
                  <code class="calibre18">name:</code>, there’s no autocomplete because the key could be anything.
                </p>
              </li>
            </ul>

            <p class="author1">In<a data-primary="interface construct"
                data-secondary="as alternative to index signatures" data-type="indexterm" id="calibre_link-324"
                class="calibre9"></a> short, index signatures are not very precise. There are almost always better
              alternatives to them. In this case, <code class="calibre18">Rocket</code> should clearly be an <code
                class="calibre18">interface</code>:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Rocket</code> <code class="p">{</code>
  <code class="nx">name</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">variant</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">thrust_kN</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">const</code> <code class="nx">falconHeavy</code>: <code class="nx">Rocket</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">name</code><code class="o">:</code> <code class="s">'Falcon Heavy'</code><code class="p">,</code>
  <code class="nx">variant</code><code class="o">:</code> <code class="s">'v1'</code><code class="p">,</code>
  <code class="nx">thrust_kN</code>: <code class="nx">15_200</code>
<code class="p">};</code></pre>

            <p class="author1">Now <code class="calibre18">thrust_kN</code> is a <code class="calibre18">number</code>
              and TypeScript will check for the presence of all required fields. All the great language services that
              TypeScript provides are available: autocomplete, jump to definition, rename&mdash;and they all work.</p>

            <p class="author1">What<a data-primary="CSV" data-type="indexterm" id="calibre_link-196"
                class="calibre9"></a> should you use index signatures for? The canonical case is truly dynamic data.
              This might come from a CSV file, for instance, where you have a header row and want to represent data rows
              as objects mapping column names to values:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">parseCSV</code><code class="p">(</code><code class="nx">input</code>: <code class="kd">string</code><code class="p">)</code><code class="o">:</code> <code class="p">{[</code><code class="nx">columnName</code>: <code class="kd">string</code><code class="p">]</code><code class="o">:</code> <code class="kt">string</code><code class="p">}[]</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">lines</code> <code class="o">=</code> <code class="nx">input</code><code class="p">.</code><code class="nx">split</code><code class="p">(</code><code class="s">'\n'</code><code class="p">);</code>
  <code class="kd">const</code> <code class="p">[</code><code class="nx">header</code><code class="p">,</code> <code class="p">...</code><code class="nx">rows</code><code class="p">]</code> <code class="o">=</code> <code class="nx">lines</code><code class="p">;</code>
  <code class="kd">return</code> <code class="nx">rows</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">rowStr</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="kd">const</code> <code class="nx">row</code><code class="o">:</code> <code class="p">{[</code><code class="nx">columnName</code>: <code class="kd">string</code><code class="p">]</code><code class="o">:</code> <code class="kt">string</code><code class="p">}</code> <code class="o">=</code> <code class="p">{};</code>
    <code class="nx">rowStr</code><code class="p">.</code><code class="nx">split</code><code class="p">(</code><code class="s">','</code><code class="p">).</code><code class="nx">forEach</code><code class="p">((</code><code class="nx">cell</code><code class="p">,</code> <code class="nx">i</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
      <code class="nx">row</code><code class="p">[</code><code class="nx">header</code><code class="p">[</code><code class="nx">i</code><code class="p">]]</code> <code class="o">=</code> <code class="nx">cell</code><code class="p">;</code>
    <code class="p">});</code>
    <code class="kd">return</code> <code class="nx">row</code><code class="p">;</code>
  <code class="p">});</code>
<code class="p">}</code></pre>

            <p class="author1">There’s no way to know in advance what the column names are in such a general setting. So
              an index signature is appropriate. If the user of <code class="calibre18">parseCSV</code> knows more about
              what the columns are in a particular context, they may want to use an assertion to get a more specific
              type:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">interface</code> <code class="nx">ProductRow</code> <code class="p">{</code>
  <code class="nx">productId</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">name</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">price</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">declare</code> <code class="kd">let</code> <code class="nx">csvData</code>: <code class="kd">string</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">products</code> <code class="o">=</code> <code class="nx">parseCSV</code><code class="p">(</code><code class="nx">csvData</code><code class="p">)</code> <code class="kd">as</code> <code class="nx">unknown</code> <code class="kd">as</code> <code class="nx">ProductRow</code><code class="p">[];</code></pre>

            <p class="author1">Of<a data-primary="undefined value type" data-type="indexterm" id="calibre_link-704"
                class="calibre9"></a> course, there’s no guarantee that the columns at runtime will actually match your
              expectation. If this is something you’re concerned about, you can add <code
                class="calibre18">undefined</code> to the value type:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">safeParseCSV</code><code class="p">(</code>
  <code class="nx">input</code>: <code class="kd">string</code>
<code class="p">)</code><code class="o">:</code> <code class="p">{[</code><code class="nx">columnName</code>: <code class="kd">string</code><code class="p">]</code><code class="o">:</code> <code class="nx">string</code><code class="o"> | </code><code class="nx">undefined</code><code class="p">}[]</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">parseCSV</code><code class="p">(</code><code class="nx">input</code><code class="p">);</code>
<code class="p">}</code></pre>

            <p class="author1">Now every access requires a check:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">rows</code> <code class="o">=</code> <code class="nx">parseCSV</code><code class="p">(</code><code class="nx">csvData</code><code class="p">);</code>
<code class="kd">const</code> <code class="nx">prices</code><code class="o">:</code> <code class="p">{[</code><code class="nx">produt</code>: <code class="kd">string</code><code class="p">]</code><code class="o">:</code> <code class="kt">number</code><code class="p">}</code> <code class="o">=</code> <code class="p">{};</code>
<code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="nx">row</code> <code class="nx">of</code> <code class="nx">rows</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">prices</code><code class="p">[</code><code class="nx">row</code><code class="p">.</code><code class="nx">productId</code><code class="p">]</code> <code class="o">=</code> <code class="nb">Number</code><code class="p">(</code><code class="nx">row</code><code class="p">.</code><code class="nx">price</code><code class="p">);</code>
<code class="p">}</code>

<code class="kd">const</code> <code class="nx">safeRows</code> <code class="o">=</code> <code class="nx">safeParseCSV</code><code class="p">(</code><code class="nx">csvData</code><code class="p">);</code>
<code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="nx">row</code> <code class="nx">of</code> <code class="nx">safeRows</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">prices</code><code class="p">[</code><code class="nx">row</code><code class="p">.</code><code class="nx">productId</code><code class="p">]</code> <code class="o">=</code> <code class="nb">Number</code><code class="p">(</code><code class="nx">row</code><code class="p">.</code><code class="nx">price</code><code class="p">);</code>
      <code class="c">// ~~~~~~~~~~~~~ Type 'undefined' cannot be used as an index type</code>
<code class="p">}</code></pre>

            <p class="author1">Of course, this may make the type less convenient to work with. Use your judgment.</p>

            <p class="author1">If your type has a limited set of possible fields, don’t model this with an index
              signature. For instance, if you know your data will have keys like A, B, C, D, but you don’t know how many
              of them there will be, you could model the type either with optional fields or a union:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">interface</code> <code class="nx">Row1</code> <code class="p">{</code> <code class="p">[</code><code class="nx">column</code>: <code class="kd">string</code><code class="p">]</code><code class="o">:</code> <code class="kt">number</code> <code class="p">}</code>  <code class="c">// Too broad</code>
<code class="kd">interface</code> <code class="nx">Row2</code> <code class="p">{</code> <code class="nx">a</code>: <code class="nx">number</code><code class="p">;</code> <code class="nx">b?</code>: <code class="nx">number</code><code class="p">;</code> <code class="nx">c?</code>: <code class="nx">number</code><code class="p">;</code> <code class="nx">d?</code>: <code class="nx">number</code> <code class="p">}</code>  <code class="c">// Better</code>
<code class="kd">type</code> <code class="nx">Row3</code> <code class="o">=</code>
    <code class="o">|</code> <code class="p">{</code> <code class="nx">a</code>: <code class="nx">number</code><code class="p">;</code> <code class="p">}</code>
    <code class="o">|</code> <code class="p">{</code> <code class="nx">a</code>: <code class="nx">number</code><code class="p">;</code> <code class="nx">b</code>: <code class="nx">number</code><code class="p">;</code> <code class="p">}</code>
    <code class="o">|</code> <code class="p">{</code> <code class="nx">a</code>: <code class="nx">number</code><code class="p">;</code> <code class="nx">b</code>: <code class="nx">number</code><code class="p">;</code> <code class="nx">c</code>: <code class="nx">number</code><code class="p">;</code>  <code class="p">}</code>
    <code class="o">|</code> <code class="p">{</code> <code class="nx">a</code>: <code class="nx">number</code><code class="p">;</code> <code class="nx">b</code>: <code class="nx">number</code><code class="p">;</code> <code class="nx">c</code>: <code class="nx">number</code><code class="p">;</code> <code class="nx">d</code>: <code class="nx">number</code> <code class="p">};</code></pre>

            <p class="author1">The last form is the most precise, but it may be less convenient to work with.</p>

            <p class="author1">If the problem with using an index signature is that <code
                class="calibre18">string</code> is too broad, then there are a few alternatives.</p>

            <p class="author1">One<a data-primary="Records" data-type="indexterm" id="calibre_link-489"
                class="calibre9"></a> is using <code class="calibre18">Record</code>. This is a generic type that gives
              you more flexibility in the key type. In particular, you can pass in subsets of <code
                class="calibre18">string</code>:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">Vec3D</code> <code class="o">=</code> <code class="nx">Record</code><code class="o">&lt;</code><code class="s">'x'</code> <code class="o">|</code> <code class="s">'y'</code> <code class="o">|</code> <code class="s">'z'</code><code class="p">,</code> <code class="kt">number</code><code class="o">&gt;</code><code class="p">;</code>
<code class="c">// Type Vec3D = {</code>
<code class="c">//   x: number;</code>
<code class="c">//   y: number;</code>
<code class="c">//   z: number;</code>
<code class="c">// }</code></pre>

            <p class="author1">Another<a data-primary="in construct" data-secondary="in (mapped type)"
                data-type="indexterm" id="calibre_link-311" class="calibre9"></a><a data-primary="mapped types"
                data-type="indexterm" id="calibre_link-394" class="calibre9"></a> is using a mapped type. This gives you
              the possibility of using different types for different keys:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">Vec3D</code> <code class="o">=</code> <code class="p">{[</code><code class="nx">k</code> <code class="kd">in</code> <code class="s">'x'</code> <code class="o">|</code> <code class="s">'y'</code> <code class="o">|</code> <code class="s">'z'</code><code class="p">]</code><code class="o">:</code> <code class="kt">number</code><code class="p">};</code>
<code class="c">// Same as above</code>
<code class="kd">type</code> <code class="nx">ABC</code> <code class="o">=</code> <code class="p">{[</code><code class="nx">k</code> <code class="kd">in</code> <code class="s">'a'</code> <code class="o">|</code> <code class="s">'b'</code> <code class="o">|</code> <code class="s">'c'</code><code class="p">]</code><code class="o">:</code> <code class="nx">k</code> <code class="kd">extends</code> <code class="s">'b'</code> <code class="o">?</code> <code class="kt">string</code> <code class="o">:</code> <code class="kt">number</code><code class="p">};</code>
<code class="c">// Type ABC = {</code>
<code class="c">//   a: number;</code>
<code class="c">//   b: string;</code>
<code class="c">//   c: number;</code>
<code class="c">// }</code></pre>








            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-887">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">Use index signatures when the properties of an object cannot be known until
                      runtime&mdash;for example, if you’re loading them from a CSV file.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Consider adding <code class="calibre18">undefined</code> to the value type of an
                      index signature for safer access.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Prefer more precise types to index signatures when possible: <code
                        class="calibre18">interface</code>s, <code class="calibre18">Record</code>s, or mapped types.<a
                        data-primary="" data-startref="TSinsig02" data-type="indexterm" id="calibre_link-649"
                        class="calibre9"></a><a data-primary="" data-startref="insig02" data-type="indexterm"
                        id="calibre_link-318" class="calibre9"></a><a data-primary="" data-startref="dyndat02"
                        data-type="indexterm" id="calibre_link-232" class="calibre9"></a><a data-primary=""
                        data-startref="csv02" data-type="indexterm" id="calibre_link-197" class="calibre9"></a></p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>













        <section data-pdf-bookmark="Item 16: Prefer Arrays, Tuples, and ArrayLike to number Index Signatures"
          data-type="sect1" class="praise">
          <div class="praise" id="calibre_link-21">
            <h1 class="calibre16">Item 16: Prefer Arrays, Tuples, and ArrayLike to number Index Signatures</h1>

            <p class="author1">JavaScript<a data-primary="type system" data-secondary="arrays, tuples, and ArrayLike"
                data-type="indexterm" id="calibre_link-640" class="calibre9"></a><a data-primary="index signatures"
                data-secondary="versus arrays, tuples, and ArrayLike"
                data-secondary-sortas="arrays, tuples, and ArrayLike" data-type="indexterm" id="calibre_link-315"
                class="calibre9"></a><a data-primary="JavaScript" data-secondary="implicit type coercions in"
                data-type="indexterm" id="calibre_link-347" class="calibre9"></a> is a famously quirky language. Some of
              the most notorious quirks involve implicit type coercions:</p>
            <pre data-type="programlisting" class="calibre17">&gt; <strong class="calibre32">"0" == 0</strong>
true</pre>

            <p class="author1">but these can usually be avoided by using <code class="calibre18">===</code> and <code
                class="calibre18">!==</code> instead of their more coercive cousins.</p>

            <p class="author1">JavaScript’s object model also has its quirks, and these are more important to understand
              because some of them are modeled by TypeScript’s type system. You’ve already seen one such quirk in <a
                href="#calibre_link-757" class="calibre9">Item 10</a>, which discussed object wrapper types. This item
              discusses another.</p>

            <p class="author1">What<a data-primary="JavaScript" data-secondary="objects in" data-type="indexterm"
                id="calibre_link-352" class="calibre9"></a><a data-primary="objects" data-secondary="in JavaScript"
                data-secondary-sortas="JavaScript" data-type="indexterm" id="calibre_link-450" class="calibre9"></a> is
              an object? In JavaScript it’s a collection of key/value pairs. The<a data-primary="ES2015"
                data-secondary="keys in" data-type="indexterm" id="calibre_link-244" class="calibre9"></a> keys are
              ususally strings (in ES2015 and later they can also be symbols). The values can be <span
                class="calibre">anything.</span></p>

            <p class="author1">This<a data-primary="Java" data-secondary="hashable objects in" data-type="indexterm"
                id="calibre_link-335" class="calibre9"></a> is more restrictive than what you find in many other
              languages. JavaScript does not have a notion of “hashable” objects like you find in Python or Java. If you
              try to use a more complex object as a key, it is converted into a string by calling its <code
                class="calibre18">toString</code> method:</p>
            <pre data-type="programlisting" class="calibre17">&gt; <strong class="calibre32">x = {}</strong>
{}
&gt; <strong class="calibre32">x[[1, 2, 3]] = 2</strong>
2
&gt; <strong class="calibre32">x</strong>
{ '1,2,3': 1 }
</pre>

            <p class="author1">In particular, <em class="calibre3">numbers</em> cannot be used as keys. If you try to
              use a number as a property name, the JavaScript runtime will convert it to a string:</p>
            <pre data-type="programlisting" class="calibre17">&gt; <strong class="calibre32">{ 1: 2, 3: 4}</strong>
{ '1': 2, '3': 4 }</pre>

            <p class="author1">So<a data-primary="arrays" data-type="indexterm" id="calibre_link-109"
                class="calibre9"></a> what are arrays, then? They are certainly objects:</p>
            <pre data-type="programlisting" class="calibre17">&gt; <strong class="calibre32">typeof []</strong>
'object'</pre>

            <p class="author1">And yet it’s quite normal to use numeric indices with them:</p>
            <pre data-type="programlisting" class="calibre17">&gt; <strong class="calibre32">x = [1, 2, 3]</strong>
[ 1, 2, 3 ]
&gt; <strong class="calibre32">x[0]</strong>
1</pre>

            <p class="author1">Are these being converted into strings? In one of the oddest quirks of all, the answer is
              “yes.” You can also access the elements of an array using string keys:</p>
            <pre data-type="programlisting" class="calibre17">&gt; <strong class="calibre32">x['1']</strong>
2</pre>

            <p class="author1">If<a data-primary="Object.keys" data-type="indexterm" id="calibre_link-443"
                class="calibre9"></a> you use <code class="calibre18">Object.keys</code> to list the keys of an array,
              you get strings back:</p>
            <pre data-type="programlisting" class="calibre17">&gt; <strong class="calibre32">Object.keys(x)</strong>
[ '0', '1', '2' ]</pre>

            <p class="author1">TypeScript<a data-primary="ES5" data-secondary="numeric keys and" data-type="indexterm"
                id="calibre_link-254" class="calibre9"></a> attempts to bring some sanity to this by allowing numeric
              keys and distinguishing between these and strings. If you dig into the type declarations for <code
                class="calibre18">Array</code> (<a href="#calibre_link-775" class="calibre9">Item 6</a>), you’ll find
              this in <em class="calibre3">lib.es5.d.ts</em>:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nb">Array</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="p">{</code>
  <code class="c">// ...</code>
  <code class="p">[</code><code class="nx">n</code>: <code class="nx">number</code><code class="p">]</code><code class="o">:</code> <code class="nx">T</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">This is purely a fiction&mdash;string keys are accepted at runtime as the ECMAScript
              standard dictates that they must&mdash;but it is a helpful one that can catch mistakes:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">xs</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">];</code>
<code class="kd">const</code> <code class="nx">x0</code> <code class="o">=</code> <code class="nx">xs</code><code class="p">[</code><code class="mi">0</code><code class="p">];</code>  <code class="c">// OK</code>
<code class="kd">const</code> <code class="nx">x1</code> <code class="o">=</code> <code class="nx">xs</code><code class="p">[</code><code class="s">'1'</code><code class="p">];</code>
           <code class="c">// ~~~ Element implicitly has an 'any' type</code>
           <code class="c">//      because index expression is not of type 'number'</code>

<code class="kd">function</code> <code class="nx">get</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">array</code>: <code class="nx">T</code><code class="p">[],</code> <code class="nx">k</code>: <code class="kd">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">T</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">array</code><code class="p">[</code><code class="nx">k</code><code class="p">];</code>
            <code class="c">// ~ Element implicitly has an 'any' type</code>
            <code class="c">//   because index expression is not of type 'number'</code>
<code class="p">}</code></pre>

            <p class="author1">While this fiction is helpful, it’s important to remember that it is just a fiction. Like
              all aspects of TypeScript’s type system, it is erased at runtime (<a href="#calibre_link-1"
                class="calibre9">Item 3</a>). This means that constructs like <code class="calibre18">Object.keys</code>
              still return strings:</p>

            <pre data-code-language="ts" data-type="programlisting" id="calibre_link-888" class="calibre17"><code class="kd">const</code> <code class="nx">keys</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">keys</code><code class="p">(</code><code class="nx">xs</code><code class="p">);</code>  <code class="c">// Type is string[]</code>
<code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="nx">key</code> <code class="kd">in</code> <code class="nx">xs</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">key</code><code class="p">;</code>  <code class="c">// Type is string</code>
  <code class="kd">const</code> <code class="nx">x</code> <code class="o">=</code> <code class="nx">xs</code><code class="p">[</code><code class="nx">key</code><code class="p">];</code>  <code class="c">// Type is number</code>
<code class="p">}</code></pre>

            <p class="author1">That this last access works is somewhat surprising since <code
                class="calibre18">string</code> is not assignable to <code class="calibre18">number</code>. It’s best
              thought of as a pragmatic concession to this style of iterating over arrays, which is common in
              JavaScript. That’s not to say that this is a good way to loop over an array. If you don’t care about the
              index, you can<a data-primary="for-of" data-type="indexterm" id="calibre_link-273" class="calibre9"></a>
              use for-of:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="nx">x</code> <code class="nx">of</code> <code class="nx">xs</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">x</code><code class="p">;</code>  <code class="c">// Type is number</code>
<code class="p">}</code></pre>

            <p class="author1">If you do care about the index, you can use <code
                class="calibre18">Array.prototype.forEach</code>, which gives it to you as a <code
                class="calibre18">number</code>:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="nx">xs</code><code class="p">.</code><code class="nx">forEach</code><code class="p">((</code><code class="nx">x</code><code class="p">,</code> <code class="nx">i</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="nx">i</code><code class="p">;</code>  <code class="c">// Type is number</code>
  <code class="nx">x</code><code class="p">;</code>  <code class="c">// Type is number</code>
<code class="p">});</code></pre>

            <p class="author1">If<a data-primary="for(;;)" data-type="indexterm" id="calibre_link-269"
                class="calibre9"></a> you need to break out of the loop early, you’re best off using a C-style <code
                class="calibre18">for(;;)</code> loop:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">xs</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">x</code> <code class="o">=</code> <code class="nx">xs</code><code class="p">[</code><code class="nx">i</code><code class="p">];</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">x</code> <code class="o">&lt;</code> <code class="mi">0</code><code class="p">)</code> <code class="kd">break</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">If<a data-primary="in construct" data-secondary="in (for-in)" data-type="indexterm"
                id="calibre_link-308" class="calibre9"></a><a data-primary="for-in loops" data-type="indexterm"
                id="calibre_link-271" class="calibre9"></a> the types don’t convince you, perhaps the performance will:
              in most browsers and JavaScript engines, for-in loops over arrays are several orders of magnitude slower
              than for-of or a C-style for loop.</p>

            <p class="author1">The general pattern here is that a <code class="calibre18">number</code> index signature
              means that what you put in has to be a <code class="calibre18">number</code> (with the notable exception
              of for-in loops), but what you get out is a <code class="calibre18">string</code>.</p>

            <p class="author1">If<a data-primary="Array type" data-type="indexterm" id="calibre_link-107"
                class="calibre9"></a><a data-primary="tuple type" data-type="indexterm" id="calibre_link-551"
                class="calibre9"></a> this sounds confusing, it’s because it is! As a general rule, there’s not much
              reason to use <code class="calibre18">number</code> as the index signature of a type rather than <code
                class="calibre18">string</code>. If you want to specify something that will be indexed using numbers,
              you probably want to use an Array or tuple type instead. Using <code class="calibre18">number</code> as an
              index type can create the misconception that numeric properties are a thing in JavaScript, either for
              yourself or for readers of your code.</p>

            <p class="author1">If you object to accepting an Array type because they have many other properties (from
              their prototype) that you might not use, such as <code class="calibre18">push</code> and <code
                class="calibre18">concat</code>, then that’s good&mdash;you’re thinking structurally! (If you need a
              refresher on this, refer to <a href="#calibre_link-10" class="calibre9">Item 4</a>.) If you truly want to
              accept tuples of any length or any array-like construct, TypeScript<a data-primary="ArrayLike type"
                data-type="indexterm" id="calibre_link-108" class="calibre9"></a> has an <code
                class="calibre18">ArrayLike</code> type you can use:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">checkedAccess</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">xs</code>: <code class="nx">ArrayLike</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">,</code> <code class="nx">i</code>: <code class="nx">number</code><code class="p">)</code><code class="o">:</code> <code class="nx">T</code> <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">xs</code><code class="p">.</code><code class="nx">length</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">return</code> <code class="nx">xs</code><code class="p">[</code><code class="nx">i</code><code class="p">];</code>
  <code class="p">}</code>
  <code class="kd">throw</code> <code class="kd">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s">`Attempt to access </code><code class="si">${</code><code class="nx">i</code><code class="si">}</code><code class="s"> which is past end of array.`</code><code class="p">)</code>
<code class="p">}</code></pre>

            <p class="author1">This has just a <code class="calibre18">length</code> and numeric index signature. In the
              rare cases that this is what you want, you should use it instead. But remember that the keys are still
              really strings!</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">tupleLike</code>: <code class="nx">ArrayLike</code><code class="o">&lt;</code><code class="kt">string</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>
  <code class="s">'0'</code><code class="o">:</code> <code class="s">'A'</code><code class="p">,</code>
  <code class="s">'1'</code><code class="o">:</code> <code class="s">'B'</code><code class="p">,</code>
  <code class="nx">length</code>: <code class="nx">2</code><code class="p">,</code>
<code class="p">};</code>  <code class="c">// OK</code></pre>








            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-889">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">Understand that arrays are objects, so their keys are strings, not numbers. <code
                        class="calibre18">number</code> as an index signature is a purely TypeScript construct which is
                      designed to help catch bugs.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Prefer <code class="calibre18">Array</code>, tuple, or <code
                        class="calibre18">ArrayLike</code> types to using <code class="calibre18">number</code> in an
                      index signature yourself.<a data-primary="" data-startref="TSarray02" data-type="indexterm"
                        id="calibre_link-641" class="calibre9"></a><a data-primary="" data-startref="ISarray02"
                        data-type="indexterm" id="calibre_link-316" class="calibre9"></a></p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>













        <section data-pdf-bookmark="Item 17: Use readonly to Avoid Errors Associated with Mutation" data-type="sect1"
          class="praise">
          <div class="praise" id="calibre_link-814">
            <h1 class="calibre16">Item 17: Use readonly to Avoid Errors Associated with Mutation</h1>

            <p class="author1">Here’s<a data-primary="type system"
                data-secondary="avoiding errors associated with mutation" data-type="indexterm" id="calibre_link-642"
                class="calibre9"></a><a data-primary="mutations, avoiding errors associated with" data-type="indexterm"
                id="calibre_link-407" class="calibre9"></a><a data-primary="readonly" data-type="indexterm"
                id="calibre_link-487" class="calibre9"></a><a data-primary="const"
                data-secondary="avoiding errors associated with mutation" data-type="indexterm" id="calibre_link-185"
                class="calibre9"></a> some code to print the triangular numbers (1, 1+2, 1+2+3, etc.):</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">printTriangles</code><code class="p">(</code><code class="nx">n</code>: <code class="nx">number</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">nums</code> <code class="o">=</code> <code class="p">[];</code>
  <code class="kd">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">n</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">nums</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">i</code><code class="p">);</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">arraySum</code><code class="p">(</code><code class="nx">nums</code><code class="p">));</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

            <p class="author1">This code looks straightforward. But here’s what happens when you run it:</p>
            <pre data-type="programlisting" class="calibre17">&gt; <strong class="calibre32">printTriangles(5)</strong>
0
1
2
3
4</pre>

            <p class="author1">The problem is that you’ve made an assumption about <code
                class="calibre18">arraySum</code>, namely, that it doesn’t modify <code class="calibre18">nums</code>.
              But here’s my implementation:</p>

            <pre data-code-language="ts" data-type="programlisting" id="calibre_link-890" class="calibre17"><code class="kd">function</code> <code class="nx">arraySum</code><code class="p">(</code><code class="nx">arr</code>: <code class="nx">number</code><code class="p">[])</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">sum</code> <code class="o">=</code> <code class="mi">0</code><code class="p">,</code> <code class="nx">num</code><code class="p">;</code>
  <code class="kd">while</code> <code class="p">((</code><code class="nx">num</code> <code class="o">=</code> <code class="nx">arr</code><code class="p">.</code><code class="nx">pop</code><code class="p">())</code> <code class="o">!==</code> <code class="kd">undefined</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">sum</code> <code class="o">+=</code> <code class="nx">num</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="kd">return</code> <code class="nx">sum</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">This function does calculate the sum of the numbers in the array. But it also has the
              side effect of emptying the array! TypeScript is fine with this, because JavaScript arrays are mutable.
            </p>

            <p class="author1">It would be nice to have some assurances that <code class="calibre18">arraySum</code>
              does not modify the array. This is what the <code class="calibre18">readonly</code> type modifier does:
            </p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">arraySum</code><code class="p">(</code><code class="nx">arr</code>: <code class="nx">readonly</code> <code class="kt">number</code><code class="p">[])</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">sum</code> <code class="o">=</code> <code class="mi">0</code><code class="p">,</code> <code class="nx">num</code><code class="p">;</code>
  <code class="kd">while</code> <code class="p">((</code><code class="nx">num</code> <code class="o">=</code> <code class="nx">arr</code><code class="p">.</code><code class="nx">pop</code><code class="p">())</code> <code class="o">!==</code> <code class="kd">undefined</code><code class="p">)</code> <code class="p">{</code>
                 <code class="c">// ~~~ 'pop' does not exist on type 'readonly number[]'</code>
    <code class="nx">sum</code> <code class="o">+=</code> <code class="nx">num</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="kd">return</code> <code class="nx">sum</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">This error message is worth digging into. <code
                class="calibre18">readonly number[]</code> is a <em class="calibre3">type</em>, and it is distinct from
              <code class="calibre18">number[]</code> in a few ways:
            </p>

            <ul class="printings">
              <li class="calibre12">
                <p class="author1">You can read from its elements, but you can’t write to them.</p>
              </li>
              <li class="calibre12">
                <p class="author1">You can read its <code class="calibre18">length</code>, but you can’t set it (which
                  would mutate the array).</p>
              </li>
              <li class="calibre12">
                <p class="author1">You can’t call <code class="calibre18">pop</code> or other methods that mutate the
                  array.</p>
              </li>
            </ul>

            <p class="author1">Because <code class="calibre18">number[]</code> is strictly more capable than <code
                class="calibre18">readonly number[]</code>, it follows that <code class="calibre18">number[]</code> is a
              subtype of <code class="calibre18">readonly number[]</code>. (It’s easy to get this
              backwards&mdash;remember <a href="#calibre_link-47" class="calibre9">Item 7</a>!) So you can assign a
              mutable array to a <code class="calibre18">readonly</code> array, but not vice versa:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">a</code>: <code class="nx">number</code><code class="p">[]</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">];</code>
<code class="kd">const</code> <code class="nx">b</code>: <code class="nx">readonly</code> <code class="kt">number</code><code class="p">[]</code> <code class="o">=</code> <code class="nx">a</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">c</code>: <code class="nx">number</code><code class="p">[]</code> <code class="o">=</code> <code class="nx">b</code><code class="p">;</code>
   <code class="c">// ~ Type 'readonly number[]' is 'readonly' and cannot be</code>
   <code class="c">//   assigned to the mutable type 'number[]'</code></pre>

            <p class="author1">This makes sense: the <code class="calibre18">readonly</code> modifier wouldn’t be much
              use if you could get rid of it without even a type assertion.</p>

            <p class="author1">When you declare a parameter <code class="calibre18">readonly</code>, a few things
              happen:</p>

            <ul class="printings">
              <li class="calibre12">
                <p class="author1">TypeScript checks that the parameter isn’t mutated in the function body.</p>
              </li>
              <li class="calibre12">
                <p class="author1">Callers are assured that your function doesn’t mutate the parameter.</p>
              </li>
              <li class="calibre12">
                <p class="author1">Callers may pass your function a <code class="calibre18">readonly</code> array.</p>
              </li>
            </ul>

            <p class="author1">There is often an assumption in JavaScript (and TypeScript) that functions don’t mutate
              their parameters unless explicitly noted. But as we’ll see time and again in this book (particularly Items
              <a href="#calibre_link-9" class="calibre9">30</a> and <a href="#calibre_link-799"
                class="calibre9">31</a>), these sorts of implicit understandings can lead to trouble with type checking.
              Better to make them explicit, both for human readers and for <code class="calibre18">tsc</code>.
            </p>

            <p class="author1">The fix for <code class="calibre18">arraySum</code> is simple: don’t mutate the array!
            </p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">arraySum</code><code class="p">(</code><code class="nx">arr</code>: <code class="nx">readonly</code> <code class="kt">number</code><code class="p">[])</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">sum</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
  <code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="nx">num</code> <code class="nx">of</code> <code class="nx">arr</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">sum</code> <code class="o">+=</code> <code class="nx">num</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="kd">return</code> <code class="nx">sum</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">Now <code class="calibre18">printTriangles</code> does what you expect:</p>
            <pre data-type="programlisting" class="calibre17">&gt; <strong class="calibre32">printTriangles(5)</strong>
0
1
3
6
10</pre>

            <p class="author1">If your function does not mutate its parameters, then you should declare them <code
                class="calibre18">readonly</code>. There’s relatively little downside: users will be able to call them
              with a broader set of types (<a href="#calibre_link-52" class="calibre9">Item 29</a>), and inadvertent
              mutations will be caught.</p>

            <p class="author1">One downside is that you may need to call functions that haven’t marked their parameters
              <code class="calibre18">readonly</code>. If these don’t mutate their parameters and are in your control,
              make them <code class="calibre18">readonly</code>! <code class="calibre18">readonly</code> tends to be
              contagious: once you mark one function with <code class="calibre18">readonly</code>, you’ll also need to
              mark all the functions that it calls. This is a good thing since it leads to clearer contracts and better
              type safety. But if you’re calling a function in another library, you may not be able to change its type
              declarations, and you may have to resort to a type assertion (<code
                class="calibre18">param as number[]</code>).
            </p>

            <p class="author1"><code class="calibre18">readonly</code> can also be used to catch a whole class of
              mutation errors involving local variables. Imagine you’re writing a tool to process a novel. You<a
                data-primary="Shelley, Mary" data-type="indexterm" id="calibre_link-503" class="calibre9"></a> get a
              sequence of lines and would like to collect them into paragraphs, which are separated by blanks:</p>

            <pre data-type="programlisting" class="calibre17">Frankenstein; or, The Modern Prometheus
by Mary Shelley

You will rejoice to hear that no disaster has accompanied the commencement
of an enterprise which you have regarded with such evil forebodings. I arrived
here yesterday, and my first task is to assure my dear sister of my welfare and
increasing confidence in the success of my undertaking.

I am already far north of London, and as I walk in the streets of Petersburgh,
I feel a cold northern breeze play upon my cheeks, which braces my nerves and
fills me with delight.</pre>

            <p class="author1">Here’s an attempt:<sup class="calibre44"><a data-type="noteref" href="#calibre_link-800"
                  id="calibre_link-803" class="calibre45">1</a></sup></p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">parseTaggedText</code><code class="p">(</code><code class="nx">lines</code>: <code class="kd">string</code><code class="p">[])</code><code class="o">:</code> <code class="kt">string</code><code class="p">[][]</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">paragraphs</code>: <code class="kd">string</code><code class="p">[][]</code> <code class="o">=</code> <code class="p">[];</code>
  <code class="kd">const</code> <code class="nx">currPara</code>: <code class="kd">string</code><code class="p">[]</code> <code class="o">=</code> <code class="p">[];</code>

  <code class="kd">const</code> <code class="nx">addParagraph</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="kd">if</code> <code class="p">(</code><code class="nx">currPara</code><code class="p">.</code><code class="nx">length</code><code class="p">)</code> <code class="p">{</code>
      <code class="nx">paragraphs</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">currPara</code><code class="p">);</code>
      <code class="nx">currPara</code><code class="p">.</code><code class="nx">length</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>  <code class="c">// Clear the lines</code>
    <code class="p">}</code>
  <code class="p">};</code>

  <code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="nx">line</code> <code class="nx">of</code> <code class="nx">lines</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">line</code><code class="p">)</code> <code class="p">{</code>
      <code class="nx">addParagraph</code><code class="p">();</code>
    <code class="p">}</code> <code class="kd">else</code> <code class="p">{</code>
      <code class="nx">currPara</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">line</code><code class="p">);</code>
    <code class="p">}</code>
  <code class="p">}</code>
  <code class="nx">addParagraph</code><code class="p">();</code>
  <code class="kd">return</code> <code class="nx">paragraphs</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">When you run this on the example at the beginning of the item, here’s what you get:</p>

            <pre data-code-language="js" data-type="programlisting"
              class="calibre17"><code class="p">[</code> <code class="p">[],</code> <code class="p">[],</code> <code class="p">[]</code> <code class="p">]</code></pre>

            <p class="author1">Well that went horribly wrong!</p>

            <p class="author1">The problem with this code is a toxic combination of aliasing (<a
                href="#calibre_link-801" class="calibre9">Item 24</a>) and mutation. The aliasing happens on this line:
            </p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="nx">paragraphs</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">currPara</code><code class="p">);</code></pre>

            <p class="author1">Rather than pushing the contents of <code class="calibre18">currPara</code>, this pushes
              a reference to the array. When you push a new value to <code class="calibre18">currPara</code> or clear
              it, this change is also reflected in the entries in <code class="calibre18">paragraphs</code> because they
              point to the same object.</p>

            <p class="author1">In other words, the net effect of this code:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="nx">paragraphs</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">currPara</code><code class="p">);</code>
<code class="nx">currPara</code><code class="p">.</code><code class="nx">length</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>  <code class="c">// Clear lines</code></pre>

            <p class="author1">is that you push a new paragraph onto <code class="calibre18">paragraphs</code> and then
              immediately clear it.</p>

            <p class="author1">The problem is that setting <code class="calibre18">currPara.length</code> and calling
              <code class="calibre18">currPara.push</code> both mutate the <code class="calibre18">currPara</code>
              array. You can disallow this behavior by declaring it to be <code class="calibre18">readonly</code>. This
              immediately surfaces a few errors in the implementation:
            </p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">parseTaggedText</code><code class="p">(</code><code class="nx">lines</code>: <code class="kd">string</code><code class="p">[])</code><code class="o">:</code> <code class="kt">string</code><code class="p">[][]</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">currPara</code>: <code class="nx">readonly</code> <code class="kt">string</code><code class="p">[]</code> <code class="o">=</code> <code class="p">[];</code>
  <code class="kd">const</code> <code class="nx">paragraphs</code>: <code class="kd">string</code><code class="p">[][]</code> <code class="o">=</code> <code class="p">[];</code>

  <code class="kd">const</code> <code class="nx">addParagraph</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="kd">if</code> <code class="p">(</code><code class="nx">currPara</code><code class="p">.</code><code class="nx">length</code><code class="p">)</code> <code class="p">{</code>
      <code class="nx">paragraphs</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code>
        <code class="nx">currPara</code>
     <code class="c">// ~~~~~~~~ Type 'readonly string[]' is 'readonly' and</code>
     <code class="c">//          cannot be assigned to the mutable type 'string[]'</code>
      <code class="p">);</code>
      <code class="nx">currPara</code><code class="p">.</code><code class="nx">length</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>  <code class="c">// Clear lines</code>
            <code class="c">// ~~~~~~ Cannot assign to 'length' because it is a read-only</code>
            <code class="c">// property</code>
    <code class="p">}</code>
  <code class="p">};</code>

  <code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="nx">line</code> <code class="nx">of</code> <code class="nx">lines</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">line</code><code class="p">)</code> <code class="p">{</code>
      <code class="nx">addParagraph</code><code class="p">();</code>
    <code class="p">}</code> <code class="kd">else</code> <code class="p">{</code>
      <code class="nx">currPara</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">line</code><code class="p">);</code>
            <code class="c">// ~~~~ Property 'push' does not exist on type 'readonly string[]'</code>
    <code class="p">}</code>
  <code class="p">}</code>
  <code class="nx">addParagraph</code><code class="p">();</code>
  <code class="kd">return</code> <code class="nx">paragraphs</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">You can fix two of the errors by declaring <code class="calibre18">currPara</code> with
              <code class="calibre18">let</code> and using nonmutating methods:
            </p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">let</code> <code class="nx">currPara</code>: <code class="nx">readonly</code> <code class="kt">string</code><code class="p">[]</code> <code class="o">=</code> <code class="p">[];</code>
<code class="c">// ...</code>
<code class="nx">currPara</code> <code class="o">=</code> <code class="p">[];</code>  <code class="c">// Clear lines</code>
<code class="c">// ...</code>
<code class="nx">currPara</code> <code class="o">=</code> <code class="nx">currPara</code><code class="p">.</code><code class="nx">concat</code><code class="p">([</code><code class="nx">line</code><code class="p">]);</code></pre>

            <p class="author1">Unlike <code class="calibre18">push</code>, <code class="calibre18">concat</code> returns
              a new array, leaving the original unmodified. By changing the declaration from <code
                class="calibre18">const</code> to <code class="calibre18">let</code> and adding <code
                class="calibre18">readonly</code>, you’ve traded one sort of mutability for another. The <code
                class="calibre18">currPara</code> variable is now free to change which array it points to, but those
              arrays themselves are not allowed to change.</p>

            <p class="author1">This leaves the error about <code class="calibre18">paragraphs</code>. You have three
              options for fixing this.</p>

            <p class="author1">First, you could make a copy of <code class="calibre18">currPara</code>:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="nx">paragraphs</code><code class="p">.</code><code class="nx">push</code><code class="p">([...</code><code class="nx">currPara</code><code class="p">]);</code></pre>

            <p class="author1">This fixes the error because, while <code class="calibre18">currPara</code> remains <code
                class="calibre18">readonly</code>, you’re free to mutate the copy however you like.</p>

            <p class="author1">Second, you could change <code class="calibre18">paragraphs</code> (and the return type
              of the function) to be an array of <code class="calibre18">readonly string[]</code>:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">const</code> <code class="nx">paragraphs</code><code class="o">:</code> <code class="p">(</code><code class="nx">readonly</code> <code class="kt">string</code><code class="p">[])[]</code> <code class="o">=</code> <code class="p">[];</code></pre>

            <p class="author1">(The grouping is relevant here: <code class="calibre18">readonly string[][]</code> would
              be a <code class="calibre18">readonly</code> array of mutable arrays, rather than a mutable array of <code
                class="calibre18">readonly</code> arrays.)</p>

            <p class="author1">This works, but it seems a bit rude to users of <code
                class="calibre18">parseTaggedText</code>. Why do you care what they do with the paragraphs after the
              function returns?</p>

            <p class="author1">Third, you could use an assertion to remove the <code
                class="calibre18">readonly</code>-ness of the array:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="nx">paragraphs</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">currPara</code> <code class="kd">as</code> <code class="kt">string</code><code class="p">[]);</code></pre>

            <p class="author1">Since you’re assigning <code class="calibre18">currPara</code> to a new array in the very
              next statement, this doesn’t seem like the most offensive assertion.</p>

            <p class="author1">An important caveat to <code class="calibre18">readonly</code> is that it is <em
                class="calibre3">shallow</em>. You saw this with <code class="calibre18">readonly string[][]</code>
              earlier. If you have a <code class="calibre18">readonly</code> array of objects, the objects themselves
              are not <code class="calibre18">readonly</code>:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">const</code> <code class="nx">dates</code>: <code class="nx">readonly</code> <code class="nb">Date</code><code class="p">[]</code> <code class="o">=</code> <code class="p">[</code><code class="kd">new</code> <code class="nb">Date</code><code class="p">()];</code>
<code class="nx">dates</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="kd">new</code> <code class="nb">Date</code><code class="p">());</code>
   <code class="c">// ~~~~ Property 'push' does not exist on type 'readonly Date[]'</code>
<code class="nx">dates</code><code class="p">[</code><code class="mi">0</code><code class="p">].</code><code class="nx">setFullYear</code><code class="p">(</code><code class="mi">2037</code><code class="p">);</code>  <code class="c">// OK</code></pre>

            <p class="author1">Similar considerations apply to <code class="calibre18">readonly</code>’s cousin for
              objects, the <code class="calibre18">Readonly</code> generic:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">interface</code> <code class="nx">Outer</code> <code class="p">{</code>
  <code class="nx">inner</code><code class="o">:</code> <code class="p">{</code>
    <code class="nx">x</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>
<code class="kd">const</code> <code class="nx">o</code>: <code class="nx">Readonly</code><code class="o">&lt;</code><code class="nx">Outer</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">inner</code><code class="o">:</code> <code class="p">{</code> <code class="nx">x</code>: <code class="nx">0</code> <code class="p">}};</code>
<code class="nx">o</code><code class="p">.</code><code class="nx">inner</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">x</code>: <code class="nx">1</code> <code class="p">};</code>
<code class="c">// ~~~~ Cannot assign to 'inner' because it is a read-only property</code>
<code class="nx">o</code><code class="p">.</code><code class="nx">inner</code><code class="p">.</code><code class="nx">x</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>  <code class="c">// OK</code></pre>

            <p class="author1">You can create a type alias and then inspect it in your editor to see exactly what’s
              <span class="calibre">happening:</span>
            </p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">T</code> <code class="o">=</code> <code class="nx">Readonly</code><code class="o">&lt;</code><code class="nx">Outer</code><code class="o">&gt;</code><code class="p">;</code>
<code class="c">// Type T = {</code>
<code class="c">//   readonly inner: {</code>
<code class="c">//     x: number;</code>
<code class="c">//   };</code>
<code class="c">// }</code></pre>

            <p class="author1">The important thing to note is the <code class="calibre18">readonly</code> modifier on
              <code class="calibre18">inner</code> but not on <code class="calibre18">x</code>. There is no built-in
              support for deep readonly types at the time of this writing, but it is possible to create a generic to do
              this. Getting this right is tricky, so I recommend using a library rather than rolling your own. The <code
                class="calibre18">DeepReadonly</code> generic in <code class="calibre18">ts-essentials</code> is one
              implementation.
            </p>

            <p class="author1">You<a data-primary="index signatures" data-secondary="readonly and" data-type="indexterm"
                id="calibre_link-319" class="calibre9"></a> can also write <code class="calibre18">readonly</code> on an
              index signature. This has the effect of preventing writes but allowing reads:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">let</code> <code class="nx">obj</code><code class="o">:</code> <code class="p">{</code><code class="nx">readonly</code> <code class="p">[</code><code class="nx">k</code>: <code class="kd">string</code><code class="p">]</code><code class="o">:</code> <code class="kt">number</code><code class="p">}</code> <code class="o">=</code> <code class="p">{};</code>
<code class="c">// Or Readonly&lt;{[k: string]: number}</code>
<code class="nx">obj</code><code class="p">.</code><code class="nx">hi</code> <code class="o">=</code> <code class="mi">45</code><code class="p">;</code>
<code class="c">//  ~~ Index signature in type ... only permits reading</code>
<code class="nx">obj</code> <code class="o">=</code> <code class="p">{...</code><code class="nx">obj</code><code class="p">,</code> <code class="nx">hi</code>: <code class="nx">12</code><code class="p">};</code>  <code class="c">// OK</code>
<code class="nx">obj</code> <code class="o">=</code> <code class="p">{...</code><code class="nx">obj</code><code class="p">,</code> <code class="nx">bye</code>: <code class="nx">34</code><code class="p">};</code>  <code class="c">// OK</code></pre>

            <p class="author1">This can prevent issues with aliasing and mutation involving objects rather than arrays.
            </p>








            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-891">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">If your function does not modify its parameters then declare them <code
                        class="calibre18">readonly</code>. This makes its contract clearer and prevents inadvertent
                      mutations in its <span class="calibre">implementation</span>.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Use <code class="calibre18">readonly</code> to prevent errors with mutation and
                      to find the places in your code where mutations occur.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Understand the difference between <code class="calibre18">const</code> and <code
                        class="calibre18">readonly</code>.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Understand that <code class="calibre18">readonly</code> is shallow.<a
                        data-primary="" data-startref="TSmut02" data-type="indexterm" id="calibre_link-643"
                        class="calibre9"></a><a data-primary="" data-startref="Merror2" data-type="indexterm"
                        id="calibre_link-408" class="calibre9"></a><a data-primary="" data-startref="reaon02"
                        data-type="indexterm" id="calibre_link-488" class="calibre9"></a><a data-primary=""
                        data-startref="const02" data-type="indexterm" id="calibre_link-186" class="calibre9"></a></p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>













        <section data-pdf-bookmark="Item 18: Use Mapped Types to Keep Values in Sync" data-type="sect1" class="praise">
          <div class="praise" id="calibre_link-892">
            <h1 class="calibre16">Item 18: Use Mapped Types to Keep Values in Sync</h1>

            <p class="author1">Suppose<a data-primary="in construct" data-secondary="in (mapped type)"
                data-type="indexterm" id="calibre_link-312" class="calibre9"></a><a data-primary="type system"
                data-secondary="mapped types" data-type="indexterm" id="calibre_link-650" class="calibre9"></a><a
                data-primary="mapped types" data-type="indexterm" id="calibre_link-395" class="calibre9"></a><a
                data-primary="values" data-secondary="keeping in sync with mapped types" data-type="indexterm"
                id="calibre_link-727" class="calibre9"></a> you’re writing a UI component for drawing scatter plots. It
              has a few different types of properties that control its display and behavior:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">ScatterProps</code> <code class="p">{</code>
  <code class="c">// The data</code>
  <code class="nx">xs</code>: <code class="nx">number</code><code class="p">[];</code>
  <code class="nx">ys</code>: <code class="nx">number</code><code class="p">[];</code>

  <code class="c">// Display</code>
  <code class="nx">xRange</code><code class="o">:</code> <code class="p">[</code><code class="kt">number</code><code class="p">,</code> <code class="kt">number</code><code class="p">];</code>
  <code class="nx">yRange</code><code class="o">:</code> <code class="p">[</code><code class="kt">number</code><code class="p">,</code> <code class="kt">number</code><code class="p">];</code>
  <code class="nx">color</code>: <code class="kd">string</code><code class="p">;</code>

  <code class="c">// Events</code>
  <code class="nx">onClick</code><code class="o">:</code> <code class="p">(</code><code class="nx">x</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">y</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">index</code>: <code class="nx">number</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kd">void</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">To avoid unnecessary work, you’d like to redraw the chart only when you need to. Changing
              data or display properties will require a redraw, but changing the event handler will not. This<a
                data-primary="React library" data-secondary="optimizations in" data-type="indexterm"
                id="calibre_link-484" class="calibre9"></a> sort of optimization is common in React components, where an
              event handler Prop might be set to a new arrow function on every render.<sup class="calibre44"><a
                  data-type="noteref" href="#calibre_link-802" id="calibre_link-804" class="calibre45">2</a></sup></p>

            <p class="author1">Here’s one way you might implement this optimization:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">shouldUpdate</code><code class="p">(</code>
  <code class="nx">oldProps</code>: <code class="nx">ScatterProps</code><code class="p">,</code>
  <code class="nx">newProps</code>: <code class="nx">ScatterProps</code>
<code class="p">)</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">k</code>: <code class="nx">keyof</code> <code class="nx">ScatterProps</code><code class="p">;</code>
  <code class="kd">for</code> <code class="p">(</code><code class="nx">k</code> <code class="kd">in</code> <code class="nx">oldProps</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">if</code> <code class="p">(</code><code class="nx">oldProps</code><code class="p">[</code><code class="nx">k</code><code class="p">]</code> <code class="o">!==</code> <code class="nx">newProps</code><code class="p">[</code><code class="nx">k</code><code class="p">])</code> <code class="p">{</code>
      <code class="kd">if</code> <code class="p">(</code><code class="nx">k</code> <code class="o">!==</code> <code class="s">'onClick'</code><code class="p">)</code> <code class="kd">return</code> <code class="kd">true</code><code class="p">;</code>
    <code class="p">}</code>
  <code class="p">}</code>
  <code class="kd">return</code> <code class="kd">false</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">(See <a href="#calibre_link-42" class="calibre9">Item 54</a> for an explanation of the
              <code class="calibre18">keyof</code> declaration in this loop.)
            </p>

            <p class="author1">What happens when you or a coworker add a new property? The <code
                class="calibre18">shouldUpdate</code> function will redraw the chart whenever it changes. You might call
              this the conservative or “fail closed” approach. The upside is that the chart will always look right. The
              downside is that it might be drawn too often.</p>

            <p class="author1">A “fail open” approach might look like this:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">shouldUpdate</code><code class="p">(</code>
  <code class="nx">oldProps</code>: <code class="nx">ScatterProps</code><code class="p">,</code>
  <code class="nx">newProps</code>: <code class="nx">ScatterProps</code>
<code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="p">(</code>
    <code class="nx">oldProps</code><code class="p">.</code><code class="nx">xs</code> <code class="o">!==</code> <code class="nx">newProps</code><code class="p">.</code><code class="nx">xs</code> <code class="o">||</code>
    <code class="nx">oldProps</code><code class="p">.</code><code class="nx">ys</code> <code class="o">!==</code> <code class="nx">newProps</code><code class="p">.</code><code class="nx">ys</code> <code class="o">||</code>
    <code class="nx">oldProps</code><code class="p">.</code><code class="nx">xRange</code> <code class="o">!==</code> <code class="nx">newProps</code><code class="p">.</code><code class="nx">xRange</code> <code class="o">||</code>
    <code class="nx">oldProps</code><code class="p">.</code><code class="nx">yRange</code> <code class="o">!==</code> <code class="nx">newProps</code><code class="p">.</code><code class="nx">yRange</code> <code class="o">||</code>
    <code class="nx">oldProps</code><code class="p">.</code><code class="nx">color</code> <code class="o">!==</code> <code class="nx">newProps</code><code class="p">.</code><code class="nx">color</code>
    <code class="c">// (no check for onClick)</code>
  <code class="p">);</code>
<code class="p">}</code></pre>

            <p class="author1">With this approach there won’t be any unnecessary redraws, but there might be some <em
                class="calibre3">necessary</em> draws that get dropped. This violates the “first, do no harm” principle
              of optimization and so is less common.</p>

            <p class="author1">Neither approach is ideal. What you’d really like is to force your coworker or future
              self to make a decision when adding the new property. You might try adding a <span
                class="calibre">comment:</span></p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">ScatterProps</code> <code class="p">{</code>
  <code class="nx">xs</code>: <code class="nx">number</code><code class="p">[];</code>
  <code class="nx">ys</code>: <code class="nx">number</code><code class="p">[];</code>
  <code class="c">// ...</code>
  <code class="nx">onClick</code><code class="o">:</code> <code class="p">(</code><code class="nx">x</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">y</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">index</code>: <code class="nx">number</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kd">void</code><code class="p">;</code>

  <code class="c">// Note: if you add a property here, update shouldUpdate!</code>
<code class="p">}</code></pre>

            <p class="author1">But do you really expect this to work? It would be better if the type checker could
              enforce this for you.</p>

            <p class="author1">If you set it up the right way, it can. The key is to use a mapped type and an object:
            </p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">REQUIRES_UPDATE</code><code class="o">:</code> <code class="p">{[</code><code class="nx">k</code> <code class="kd">in</code> <code class="nx">keyof</code> <code class="nx">ScatterProps</code><code class="p">]</code><code class="o">:</code> <code class="kd">boolean</code><code class="p">}</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">xs</code>: <code class="nx">true</code><code class="p">,</code>
  <code class="nx">ys</code>: <code class="nx">true</code><code class="p">,</code>
  <code class="nx">xRange</code>: <code class="nx">true</code><code class="p">,</code>
  <code class="nx">yRange</code>: <code class="nx">true</code><code class="p">,</code>
  <code class="nx">color</code>: <code class="nx">true</code><code class="p">,</code>
  <code class="nx">onClick</code>: <code class="nx">false</code><code class="p">,</code>
<code class="p">};</code>

<code class="kd">function</code> <code class="nx">shouldUpdate</code><code class="p">(</code>
  <code class="nx">oldProps</code>: <code class="nx">ScatterProps</code><code class="p">,</code>
  <code class="nx">newProps</code>: <code class="nx">ScatterProps</code>
<code class="p">)</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">k</code>: <code class="nx">keyof</code> <code class="nx">ScatterProps</code><code class="p">;</code>
  <code class="kd">for</code> <code class="p">(</code><code class="nx">k</code> <code class="kd">in</code> <code class="nx">oldProps</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">if</code> <code class="p">(</code><code class="nx">oldProps</code><code class="p">[</code><code class="nx">k</code><code class="p">]</code> <code class="o">!==</code> <code class="nx">newProps</code><code class="p">[</code><code class="nx">k</code><code class="p">]</code> <code class="o">&amp;&amp;</code> <code class="nx">REQUIRES_UPDATE</code><code class="p">[</code><code class="nx">k</code><code class="p">])</code> <code class="p">{</code>
      <code class="kd">return</code> <code class="kd">true</code><code class="p">;</code>
    <code class="p">}</code>
  <code class="p">}</code>
  <code class="kd">return</code> <code class="kd">false</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">The <code class="calibre18">[k in keyof ScatterProps]</code> tells the type checker that
              <code class="calibre18">REQUIRES_UPDATES</code> should have all the same properties as <code
                class="calibre18">ScatterProps</code>. If future you adds a new property to <code
                class="calibre18">ScatterProps</code>:
            </p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">ScatterProps</code> <code class="p">{</code>
  <code class="c">// ...</code>
  <code class="nx">onDoubleClick</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="kd">void</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">Then this will produce an error in the definition of <code
                class="calibre18">REQUIRES_UPDATE</code>:</p>

            <pre data-code-language="ts" data-type="programlisting" id="calibre_link-893" class="calibre17"><code class="kd">const</code> <code class="nx">REQUIRES_UPDATE</code><code class="o">:</code> <code class="p">{[</code><code class="nx">k</code> <code class="kd">in</code> <code class="nx">keyof</code> <code class="nx">ScatterProps</code><code class="p">]</code><code class="o">:</code> <code class="kd">boolean</code><code class="p">}</code> <code class="o">=</code> <code class="p">{</code>
  <code class="c">//  ~~~~~~~~~~~~~~~ Property 'onDoubleClick' is missing in type</code>
  <code class="c">// ...</code>
<code class="p">};</code></pre>

            <p class="author1">This will certainly force the issue! Deleting or renaming a property will cause a similar
              error.</p>

            <p class="author1">It’s important that we used an object with boolean values here. Had we used an array:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">PROPS_REQUIRING_UPDATE</code><code class="o">:</code> <code class="p">(</code><code class="nx">keyof</code> <code class="nx">ScatterProps</code><code class="p">)[]</code> <code class="o">=</code> <code class="p">[</code>
  <code class="s">'xs'</code><code class="p">,</code>
  <code class="s">'ys'</code><code class="p">,</code>
  <code class="c">// ...</code>
<code class="p">];</code></pre>

            <p class="author1">then we would have been forced into the same fail open/fail closed choice.</p>

            <p class="author1">Mapped types are ideal if you want one object to have exactly the same properties as
              another. As in this example, you can use this to make TypeScript enforce constraints on your code.</p>








            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-894">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">Use mapped types to keep related values and types synchronized.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Consider using mapped types to force choices when adding new properties to an
                      interface.<a data-primary="" data-startref="Vsyne02" data-type="indexterm" id="calibre_link-728"
                        class="calibre9"></a><a data-primary="" data-startref="maptype02" data-type="indexterm"
                        id="calibre_link-396" class="calibre9"></a><a data-primary="" data-startref="TSmap02"
                        data-type="indexterm" id="calibre_link-651" class="calibre9"></a><a data-primary=""
                        data-startref="ICmap02" data-type="indexterm" id="calibre_link-313" class="calibre9"></a></p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>







        <div data-type="footnotes" class="calibre46">
          <p data-type="footnote" id="calibre_link-800" class="calibre47"><sup class="calibre48"><a
                href="#calibre_link-803" class="calibre49">1</a></sup> In practice you might just write <code
              class="calibre18">lines.join('\n').split(/\n\n+/)</code>, but bear with me.</p>
          <p data-type="footnote" id="calibre_link-802" class="calibre47"><sup class="calibre48"><a
                href="#calibre_link-804" class="calibre49">2</a></sup> React’s <code
              class="calibre18">useCallback</code> hook is another technique to avoid creating new functions on every
            render.</p>
        </div>
      </div>
    </section>
  </div>

  <div data-type="book" class="calibre1" id="calibre_link-806">
    <section data-pdf-bookmark="Chapter 3. Type Inference" data-type="chapter" type="chapter" class="praise">
      <div class="praise" id="calibre_link-772">
        <h1 class="calibre14"><span class="calibre">Chapter 3. </span>Type Inference</h1>


        <p class="author1">For<a data-primary="statically typed languages" data-type="indexterm" id="calibre_link-506"
            class="calibre9"></a><a data-primary="explicitly typed languages" data-type="indexterm"
            id="calibre_link-264" class="calibre9"></a> programming languages used in industry, “statically typed” and
          “explicitly typed” have<a data-primary="C++" data-type="indexterm" id="calibre_link-142" class="calibre9"></a>
          traditionally been synonymous. C, C++, Java: they all made you write out your types. But academic languages
          never conflated these two things: languages like ML and Haskell have long had sophisticated type inference
          systems, and in the past decade this has begun to work its way into industry languages. C++ has added <code
            class="calibre18">auto</code>, and<a data-primary="Java" data-secondary="addition of var"
            data-type="indexterm" id="calibre_link-333" class="calibre9"></a> Java has added <code
            class="calibre18">var</code>.</p>

        <p class="author1">TypeScript makes extensive use of type inference. Used well, this can dramatically reduce the
          number of type annotations your code requires to get full type safety. One of the easiest ways to tell a
          TypeScript beginner from a more experienced user is by the number of type annotations. An experienced
          TypeScript developer will use relatively few annotations (but use them to great effect), while a beginner may
          drown their code in redundant type annotations.</p>

        <p class="author1">This chapter shows you some of the problems that can arise with type inference and how to fix
          them. After reading it, you should have a good understanding of how TypeScript infers types, when you still
          need to write type declarations, and when it’s a good idea to write type declarations even when a type can be
          inferred.</p>






        <section data-pdf-bookmark="Item 19: Avoid Cluttering Your Code with Inferable Types" data-type="sect1"
          class="praise">
          <div class="praise" id="calibre_link-11">
            <h1 class="calibre16">Item 19: Avoid Cluttering Your Code with Inferable Types</h1>

            <p class="author1">The<a data-primary="type inference" data-secondary="benefits of inferable types"
                data-type="indexterm" id="calibre_link-613" class="calibre9"></a><a data-primary="TypeScript"
                data-secondary="type inference in" data-type="indexterm" id="calibre_link-693" class="calibre9"></a><a
                data-primary="inferable types" data-type="indexterm" id="calibre_link-321" class="calibre9"></a><a
                data-primary="type annotations" data-secondary="avoiding cluttered code" data-type="indexterm"
                id="calibre_link-556" class="calibre9"></a> first thing that many new TypeScript developers do when they
              convert a codebase from JavaScript is fill it with type annotations. TypeScript is about <em
                class="calibre3">types</em>, after all! But in TypeScript many annotations are unnecessary. Declaring
              types for all your variables is counterproductive and is considered poor style.</p>

            <p class="author1">Don’t write:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">let</code> <code class="nx">x</code>: <code class="nx">number</code> <code class="o">=</code> <code class="mi">12</code><code class="p">;</code></pre>

            <p class="author1">Instead, just write:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">let</code> <code class="nx">x</code> <code class="o">=</code> <code class="mi">12</code><code class="p">;</code></pre>

            <p class="author1">If you mouse over <code class="calibre18">x</code> in your editor, you’ll see that its
              type has been inferred as <code class="calibre18">number</code> (as shown in <a data-type="xref"
                href="#calibre_link-807" class="calibre9">Figure&nbsp;3-1</a>).</p>

            <figure class="calibre28">
              <div class="figure" id="calibre_link-807">
                <img alt="efts 03in01" src="images/000019.png" class="calibre29" />
                <h6 class="calibre30"><span class="calibre">Figure 3-1. </span>A text editor showing that the inferred
                  type of x is number.</h6>
              </div>
            </figure>

            <p class="author1">The explicit type annotation is redundant. Writing it just adds noise. If you’re unsure
              of the type, you can check it in your editor.</p>

            <p class="author1">TypeScript<a data-primary="Truth, Sojourner" data-type="indexterm" id="calibre_link-542"
                class="calibre9"></a> will also infer the types of more complex objects. Instead of:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">person</code><code class="o">:</code> <code class="p">{</code>
  <code class="nx">name</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">born</code><code class="o">:</code> <code class="p">{</code>
    <code class="nx">where</code>: <code class="kd">string</code><code class="p">;</code>
    <code class="nx">when</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="p">};</code>
  <code class="nx">died</code><code class="o">:</code> <code class="p">{</code>
    <code class="nx">where</code>: <code class="kd">string</code><code class="p">;</code>
    <code class="nx">when</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">name</code><code class="o">:</code> <code class="s">'Sojourner Truth'</code><code class="p">,</code>
  <code class="nx">born</code><code class="o">:</code> <code class="p">{</code>
    <code class="nx">where</code><code class="o">:</code> <code class="s">'Swartekill, NY'</code><code class="p">,</code>
    <code class="nx">when</code><code class="o">:</code> <code class="s">'c.1797'</code><code class="p">,</code>
  <code class="p">},</code>
  <code class="nx">died</code><code class="o">:</code> <code class="p">{</code>
    <code class="nx">where</code><code class="o">:</code> <code class="s">'Battle Creek, MI'</code><code class="p">,</code>
    <code class="nx">when</code><code class="o">:</code> <code class="s">'Nov. 26, 1883'</code>
  <code class="p">}</code>
<code class="p">};</code></pre>

            <p class="author1">you can just write:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">person</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">name</code><code class="o">:</code> <code class="s">'Sojourner Truth'</code><code class="p">,</code>
  <code class="nx">born</code><code class="o">:</code> <code class="p">{</code>
    <code class="nx">where</code><code class="o">:</code> <code class="s">'Swartekill, NY'</code><code class="p">,</code>
    <code class="nx">when</code><code class="o">:</code> <code class="s">'c.1797'</code><code class="p">,</code>
  <code class="p">},</code>
  <code class="nx">died</code><code class="o">:</code> <code class="p">{</code>
    <code class="nx">where</code><code class="o">:</code> <code class="s">'Battle Creek, MI'</code><code class="p">,</code>
    <code class="nx">when</code><code class="o">:</code> <code class="s">'Nov. 26, 1883'</code>
  <code class="p">}</code>
<code class="p">};</code></pre>

            <p class="author1">Again, the types are exactly the same. Writing the type in addition to the value just
              adds noise here. (<a href="#calibre_link-786" class="calibre9">Item 21</a> has more to say on the types
              inferred for object literals.)</p>

            <p class="author1">What’s true for objects is also true for arrays. TypeScript has no trouble figuring out
              the return type of this function based on its inputs and operations:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">function</code> <code class="nx">square</code><code class="p">(</code><code class="nx">nums</code>: <code class="nx">number</code><code class="p">[])</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">nums</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">x</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">x</code><code class="p">);</code>
<code class="p">}</code>
<code class="kd">const</code> <code class="nx">squares</code> <code class="o">=</code> <code class="nx">square</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">]);</code> <code class="c">// Type is number[]</code></pre>

            <p class="author1">TypeScript may infer something more precise than what you expected. This is generally a
              good thing. For example:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">const</code> <code class="nx">axis1</code>: <code class="kd">string</code> <code class="o">=</code> <code class="s">'x'</code><code class="p">;</code>  <code class="c">// Type is string</code>
<code class="kd">const</code> <code class="nx">axis2</code> <code class="o">=</code> <code class="s">'y'</code><code class="p">;</code>  <code class="c">// Type is "y"</code></pre>

            <p class="author1"><code class="calibre18">"y"</code> is a more precise type for the <code
                class="calibre18">axis</code> variable. <a href="#calibre_link-786" class="calibre9">Item 21</a> gives
              an example of how this can fix a type error.</p>

            <p class="author1">Allowing types to be inferred can also facilitate refactoring. Say you have a <code
                class="calibre18">Product</code> type and a function to log it:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Product</code> <code class="p">{</code>
  <code class="nx">id</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">name</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">price</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="nx">logProduct</code><code class="p">(</code><code class="nx">product</code>: <code class="nx">Product</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">id</code>: <code class="nx">number</code> <code class="o">=</code> <code class="nx">product</code><code class="p">.</code><code class="nx">id</code><code class="p">;</code>
  <code class="kd">const</code> <code class="nx">name</code>: <code class="kd">string</code> <code class="o">=</code> <code class="nx">product</code><code class="p">.</code><code class="nx">name</code><code class="p">;</code>
  <code class="kd">const</code> <code class="nx">price</code>: <code class="nx">number</code> <code class="o">=</code> <code class="nx">product</code><code class="p">.</code><code class="nx">price</code><code class="p">;</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">id</code><code class="p">,</code> <code class="nx">name</code><code class="p">,</code> <code class="nx">price</code><code class="p">);</code>
<code class="p">}</code></pre>

            <p class="author1">At some point you learn that product IDs might have letters in them in addition to
              numbers. So you change the type of <code class="calibre18">id</code> in <code
                class="calibre18">Product</code>. Because you included explicit annotations on all the variables in
              <code class="calibre18">logProduct</code>, this produces an error:
            </p>

            <pre data-code-language="ts" data-type="programlisting" id="calibre_link-895" class="calibre17"><code class="kd">interface</code> <code class="nx">Product</code> <code class="p">{</code>
  <code class="nx">id</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">name</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">price</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="nx">logProduct</code><code class="p">(</code><code class="nx">product</code>: <code class="nx">Product</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">id</code>: <code class="nx">number</code> <code class="o">=</code> <code class="nx">product</code><code class="p">.</code><code class="nx">id</code><code class="p">;</code>
     <code class="c">// ~~ Type 'string' is not assignable to type 'number'</code>
  <code class="kd">const</code> <code class="nx">name</code>: <code class="kd">string</code> <code class="o">=</code> <code class="nx">product</code><code class="p">.</code><code class="nx">name</code><code class="p">;</code>
  <code class="kd">const</code> <code class="nx">price</code>: <code class="nx">number</code> <code class="o">=</code> <code class="nx">product</code><code class="p">.</code><code class="nx">price</code><code class="p">;</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">id</code><code class="p">,</code> <code class="nx">name</code><code class="p">,</code> <code class="nx">price</code><code class="p">);</code>
<code class="p">}</code></pre>

            <p class="author1">Had you left off all the annotations in the <code class="calibre18">logProduct</code>
              function body, the code would have passed the type checker without modification.</p>

            <p class="author1">A better implementation of <code class="calibre18">logProduct</code> would use
              destructuring assignment (<a href="#calibre_link-29" class="calibre9">Item 58</a>):</p>

            <pre data-code-language="ts" data-type="programlisting" id="calibre_link-896" class="calibre17"><code class="kd">function</code> <code class="nx">logProduct</code><code class="p">(</code><code class="nx">product</code>: <code class="nx">Product</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="p">{</code><code class="nx">id</code><code class="p">,</code> <code class="nx">name</code><code class="p">,</code> <code class="nx">price</code><code class="p">}</code> <code class="o">=</code> <code class="nx">product</code><code class="p">;</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">id</code><code class="p">,</code> <code class="nx">name</code><code class="p">,</code> <code class="nx">price</code><code class="p">);</code>
<code class="p">}</code></pre>

            <p class="author1">This version allows the types of all the local variables to be inferred. The
              corresponding version with explicit type annotations is repetitive and cluttered:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">logProduct</code><code class="p">(</code><code class="nx">product</code>: <code class="nx">Product</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="p">{</code><code class="nx">id</code><code class="p">,</code> <code class="nx">name</code><code class="p">,</code> <code class="nx">price</code><code class="p">}</code><code class="o">:</code> <code class="p">{</code><code class="nx">id</code>: <code class="kd">string</code><code class="p">;</code> <code class="nx">name</code>: <code class="kd">string</code><code class="p">;</code> <code class="nx">price</code>: <code class="nx">number</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">product</code><code class="p">;</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">id</code><code class="p">,</code> <code class="nx">name</code><code class="p">,</code> <code class="nx">price</code><code class="p">);</code>
<code class="p">}</code></pre>

            <p class="author1">Explicit type annotations are still required in some situations where TypeScript doesn’t
              have enough context to determine a type on its own. You have seen one of these before: function
              parameters.</p>

            <p class="author1">Some languages will infer types for parameters based on their eventual usage, but
              TypeScript does not. In TypeScript, a variable’s type is generally determined when it is first introduced.
            </p>

            <p class="author1">Ideal TypeScript code includes type annotations for function/method signatures but not
              for the local variables created in their bodies. This keeps noise to a minimum and lets readers focus on
              the implementation logic.</p>

            <p class="author1">There are some situations where you can leave the type annotations off of function
              parameters, too. When there’s a default value, for example:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">parseNumber</code><code class="p">(</code><code class="nx">str</code>: <code class="kd">string</code><code class="p">,</code> <code class="nx">base</code><code class="o">=</code><code class="mi">10</code><code class="p">)</code> <code class="p">{</code>
  <code class="c">// ...</code>
<code class="p">}</code></pre>

            <p class="author1">Here the type of <code class="calibre18">base</code> is inferred as <code
                class="calibre18">number</code> because of the default value of <code class="calibre18">10</code>.</p>

            <p class="author1">Parameter types can usually be inferred when the function is used as a callback for a
              library with type declarations. The declarations on <code class="calibre18">request</code> and <code
                class="calibre18">response</code> in this example using the express HTTP server library are not
              required:</p>

            <pre data-code-language="ts" data-type="programlisting" id="calibre_link-897" class="calibre17"><code class="c">// Don't do this:</code>
<code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s">'/health'</code><code class="p">,</code> <code class="p">(</code><code class="nx">request</code>: <code class="nx">express.Request</code><code class="p">,</code> <code class="nx">response</code>: <code class="nx">express.Response</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="nx">response</code><code class="p">.</code><code class="nx">send</code><code class="p">(</code><code class="s">'OK'</code><code class="p">);</code>
<code class="p">});</code>

<code class="c">// Do this:</code>
<code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s">'/health'</code><code class="p">,</code> <code class="p">(</code><code class="nx">request</code><code class="p">,</code> <code class="nx">response</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="nx">response</code><code class="p">.</code><code class="nx">send</code><code class="p">(</code><code class="s">'OK'</code><code class="p">);</code>
<code class="p">});</code></pre>

            <p class="author1"><a href="#calibre_link-760" class="calibre9">Item 26</a> goes into more depth on how
              context is used in type inference.</p>

            <p class="author1">There are a few situations where you may still want to specify a type even where it can
              be inferred.</p>

            <p class="author1">One is when you define an object literal:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">elmo</code>: <code class="nx">Product</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">name</code><code class="o">:</code> <code class="s">'Tickle Me Elmo'</code><code class="p">,</code>
  <code class="nx">id</code><code class="o">:</code> <code class="s">'048188 627152'</code><code class="p">,</code>
  <code class="nx">price</code>: <code class="nx">28.99</code><code class="p">,</code>
<code class="p">};</code></pre>

            <p class="author1">When you specify a type on a definition like this, you enable excess property checking
              (<a href="#calibre_link-758" class="calibre9">Item 11</a>). This can help catch errors, particularly for
              types with optional fields.</p>

            <p class="author1">You also increase the odds that an error will be reported in the right place. If you
              leave off the annotation, a mistake in the object’s definition will result in a type error where it’s
              used, rather than where it’s defined:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">furby</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">name</code><code class="o">:</code> <code class="s">'Furby'</code><code class="p">,</code>
  <code class="nx">id</code>: <code class="nx">630509430963</code><code class="p">,</code>
  <code class="nx">price</code>: <code class="nx">35</code><code class="p">,</code>
<code class="p">};</code>
<code class="nx">logProduct</code><code class="p">(</code><code class="nx">furby</code><code class="p">);</code>
        <code class="c">// ~~~~~ Argument .. is not assignable to parameter of type 'Product'</code>
        <code class="c">//         Types of property 'id' are incompatible</code>
        <code class="c">//         Type 'number' is not assignable to type 'string'</code></pre>

            <p class="author1">With an annotation, you get a more concise error in the place where the mistake was made:
            </p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"> <code class="kd">const</code> <code class="nx">furby</code>: <code class="nx">Product</code> <code class="o">=</code> <code class="p">{</code>
   <code class="nx">name</code><code class="o">:</code> <code class="s">'Furby'</code><code class="p">,</code>
   <code class="nx">id</code>: <code class="nx">630509430963</code><code class="p">,</code>
<code class="c">// ~~ Type 'number' is not assignable to type 'string'</code>
   <code class="nx">price</code>: <code class="nx">35</code><code class="p">,</code>
 <code class="p">};</code>
 <code class="nx">logProduct</code><code class="p">(</code><code class="nx">furby</code><code class="p">);</code></pre>

            <p class="author1">Similar considerations apply to a function’s return type. You may still want to annotate
              this even when it can be inferred to ensure that implementation errors don’t leak out into uses of the
              function.</p>

            <p class="author1">Say you have a function which retrieves a stock quote:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">getQuote</code><code class="p">(</code><code class="nx">ticker</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">fetch</code><code class="p">(</code><code class="s">`https://quotes.example.com/?q=</code><code class="si">${</code><code class="nx">ticker</code><code class="si">}</code><code class="s">`</code><code class="p">)</code>
      <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">response</code> <code class="o">=&gt;</code> <code class="nx">response</code><code class="p">.</code><code class="nx">json</code><code class="p">());</code>
<code class="p">}</code></pre>

            <p class="author1">You decide to add a cache to avoid duplicating network requests:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">cache</code><code class="o">:</code> <code class="p">{[</code><code class="nx">ticker</code>: <code class="kd">string</code><code class="p">]</code><code class="o">:</code> <code class="kt">number</code><code class="p">}</code> <code class="o">=</code> <code class="p">{};</code>
<code class="kd">function</code> <code class="nx">getQuote</code><code class="p">(</code><code class="nx">ticker</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">ticker</code> <code class="kd">in</code> <code class="nx">cache</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">return</code> <code class="nx">cache</code><code class="p">[</code><code class="nx">ticker</code><code class="p">];</code>
  <code class="p">}</code>
  <code class="kd">return</code> <code class="nx">fetch</code><code class="p">(</code><code class="s">`https://quotes.example.com/?q=</code><code class="si">${</code><code class="nx">ticker</code><code class="si">}</code><code class="s">`</code><code class="p">)</code>
      <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">response</code> <code class="o">=&gt;</code> <code class="nx">response</code><code class="p">.</code><code class="nx">json</code><code class="p">())</code>
      <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">quote</code> <code class="o">=&gt;</code> <code class="p">{</code>
        <code class="nx">cache</code><code class="p">[</code><code class="nx">ticker</code><code class="p">]</code> <code class="o">=</code> <code class="nx">quote</code><code class="p">;</code>
        <code class="kd">return</code> <code class="nx">quote</code><code class="p">;</code>
      <code class="p">});</code>
<code class="p">}</code></pre>

            <p class="author1">There’s a mistake in this implementation: you should really be returning <code
                class="calibre18">Promise.resolve(cache[ticker])</code> so that <code class="calibre18">getQuote</code>
              always returns a Promise. The mistake will most likely produce an error…but in the code that calls <code
                class="calibre18">getQuote</code>, rather than in <code class="calibre18">getQuote</code> itself:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="nx">getQuote</code><code class="p">(</code><code class="s">'MSFT'</code><code class="p">).</code><code class="nx">then</code><code class="p">(</code><code class="nx">considerBuying</code><code class="p">);</code>
              <code class="c">// ~~~~ Property 'then' does not exist on type</code>
              <code class="c">//        'number | Promise&lt;any&gt;'</code>
              <code class="c">//      Property 'then' does not exist on type 'number'</code></pre>

            <p class="author1">Had you annotated the intended return type (<code
                class="calibre18">Promise&lt;number&gt;</code>), the error would have been reported in the correct
              place:</p>

            <pre data-code-language="ts" data-type="programlisting" id="calibre_link-898" class="calibre17"><code class="kd">const</code> <code class="nx">cache</code><code class="o">:</code> <code class="p">{[</code><code class="nx">ticker</code>: <code class="kd">string</code><code class="p">]</code><code class="o">:</code> <code class="kt">number</code><code class="p">}</code> <code class="o">=</code> <code class="p">{};</code>
<code class="kd">function</code> <code class="nx">getQuote</code><code class="p">(</code><code class="nx">ticker</code>: <code class="kd">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">Promise</code><code class="o">&lt;</code><code class="kt">number</code><code class="o">&gt;</code> <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">ticker</code> <code class="kd">in</code> <code class="nx">cache</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">return</code> <code class="nx">cache</code><code class="p">[</code><code class="nx">ticker</code><code class="p">];</code>
        <code class="c">// ~~~~~~~~~~~~~ Type 'number' is not assignable to 'Promise&lt;number&gt;'</code>
  <code class="p">}</code>
  <code class="c">// ...</code>
<code class="p">}</code></pre>

            <p class="author1">When you annotate the return type, it keeps implementation errors from manifesting as
              errors in user code. (See <a href="#calibre_link-23" class="calibre9">Item 25</a> for a discussion of
              async functions, which are an effective way to avoid this specific error with Promises.)</p>

            <p class="author1">Writing out the return type may also help you think more clearly about your function: you
              should know what its input and output types are <em class="calibre3">before you implement it</em>. While
              the implementation may shift around a bit, the function’s contract (its type signature) generally should
              not. This<a data-primary="test-driven development (TDD)" data-type="indexterm" id="calibre_link-533"
                class="calibre9"></a> is similar in spirit to test-driven development (TDD), in which you write the
              tests that exercise a function before you implement it. Writing the full type signature first helps get
              you the function you want, rather than the one the implementation makes expedient.</p>

            <p class="author1">A final reason to annotate return values is if you want to use a named type. You might
              choose not to write a return type for this function, for example:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Vector2D</code> <code class="p">{</code> <code class="nx">x</code>: <code class="nx">number</code><code class="p">;</code> <code class="nx">y</code>: <code class="nx">number</code><code class="p">;</code> <code class="p">}</code>
<code class="kd">function</code> <code class="nx">add</code><code class="p">(</code><code class="nx">a</code>: <code class="nx">Vector2D</code><code class="p">,</code> <code class="nx">b</code>: <code class="nx">Vector2D</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="p">{</code> <code class="nx">x</code>: <code class="nx">a.x</code> <code class="o">+</code> <code class="nx">b</code><code class="p">.</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code>: <code class="nx">a.y</code> <code class="o">+</code> <code class="nx">b</code><code class="p">.</code><code class="nx">y</code> <code class="p">};</code>
<code class="p">}</code></pre>

            <p class="author1">TypeScript infers the return type as <code
                class="calibre18">{ x: number; y: number; }</code>. This is compatible with <code
                class="calibre18">Vector2D</code>, but it may be surprising to users of your code when they see <code
                class="calibre18">Vector2D</code> as a type of the input and not of the output (as shown in <a
                data-type="xref" href="#calibre_link-808" class="calibre9">Figure&nbsp;3-2</a>).</p>

            <figure class="calibre28">
              <div class="figure" id="calibre_link-808">
                <img alt="efts 03in02" src="images/000026.png" class="calibre29" />
                <h6 class="calibre30"><span class="calibre">Figure 3-2. </span>The parameters to the add function have
                  named types, while the inferred return value does not.</h6>
              </div>
            </figure>

            <p class="author1">If you annotate the return type, the presentation is more straightforward. And if you’ve
              written documentation on the type (<a href="#calibre_link-49" class="calibre9">Item 48</a>) then it will
              be associated with the returned value as well. As the complexity of the inferred return type increases, it
              becomes increasingly helpful to provide a name.</p>

            <p class="author1">If you are using a linter, the<a data-primary="eslint" data-type="indexterm"
                id="calibre_link-256" class="calibre9"></a> eslint rule <code
                class="calibre18">no-inferrable-types</code> (note the variant spelling) can help ensure that all your
              type annotations are really necessary.</p>








            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-899">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">Avoid writing type annotations when TypeScript can infer the same type.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Ideally your code has type annotations in function/method signatures but not on
                      local variables in their bodies.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Consider using explicit annotations for object literals and function return types
                      even when they can be inferred. This will help prevent implementation errors from surfacing in
                      user code.<a data-primary="" data-startref="TIbene03" data-type="indexterm" id="calibre_link-614"
                        class="calibre9"></a><a data-primary="" data-startref="TStinf03" data-type="indexterm"
                        id="calibre_link-694" class="calibre9"></a><a data-primary="" data-startref="infertype03"
                        data-type="indexterm" id="calibre_link-322" class="calibre9"></a><a data-primary=""
                        data-startref="tannot03" data-type="indexterm" id="calibre_link-557" class="calibre9"></a></p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>













        <section data-pdf-bookmark="Item 20: Use Different Variables for Different Types" data-type="sect1"
          class="praise">
          <div class="praise" id="calibre_link-810">
            <h1 class="calibre16">Item 20: Use Different Variables for Different Types</h1>

            <p class="author1">In<a data-primary="type inference" data-secondary="avoiding variable reuse"
                data-type="indexterm" id="calibre_link-611" class="calibre9"></a><a data-primary="variables"
                data-secondary="avoiding reuse for different types" data-type="indexterm" id="calibre_link-738"
                class="calibre9"></a> JavaScript it’s no problem to reuse a variable to hold a differently typed value
              for a different purpose:</p>

            <pre data-code-language="js" data-type="programlisting"
              class="calibre17"><code class="kd">let</code> <code class="nx">id</code> <code class="o">=</code> <code class="s">"12-34-56"</code><code class="p">;</code>
<code class="nx">fetchProduct</code><code class="p">(</code><code class="nx">id</code><code class="p">);</code>  <code class="c">// Expects a string</code>

<code class="nx">id</code> <code class="o">=</code> <code class="mi">123456</code><code class="p">;</code>
<code class="nx">fetchProductBySerialNumber</code><code class="p">(</code><code class="nx">id</code><code class="p">);</code>  <code class="c">// Expects a number</code></pre>

            <p class="author1">In TypeScript, this results in two errors:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17">   <code class="kd">let</code> <code class="nx">id</code> <code class="o">=</code> <code class="s">"12-34-56"</code><code class="p">;</code>
   <code class="nx">fetchProduct</code><code class="p">(</code><code class="nx">id</code><code class="p">);</code>

   <code class="nx">id</code> <code class="o">=</code> <code class="mi">123456</code><code class="p">;</code>
<code class="c">// ~~ '123456' is not assignable to type 'string'.</code>
   <code class="nx">fetchProductBySerialNumber</code><code class="p">(</code><code class="nx">id</code><code class="p">);</code>
                           <code class="c">// ~~ Argument of type 'string' is not assignable to</code>
                           <code class="c">//    parameter of type 'number'</code></pre>

            <p class="author1">Hovering over the first <code class="calibre18">id</code> in your editor gives a hint as
              to what’s going on (see <a data-type="xref" href="#calibre_link-809"
                class="calibre9">Figure&nbsp;3-3</a>).</p>

            <figure class="calibre28">
              <div class="figure" id="calibre_link-809">
                <img alt="efts 03in03" src="images/000029.png" class="calibre29" />
                <h6 class="calibre30"><span class="calibre">Figure 3-3. </span>The inferred type of id is string.</h6>
              </div>
            </figure>

            <p class="author1">Based on the value <code class="calibre18">"12-34-56"</code>, TypeScript has inferred
              <code class="calibre18">id</code>’s type as <code class="calibre18">string</code>. You can’t assign a
              <code class="calibre18">number</code> to a <code class="calibre18">string</code> and hence the error.
            </p>

            <p class="author1">This leads us to a key insight about variables in TypeScript: <em class="calibre3">while
                a variable’s value can change, its type generally does not</em>. The one common way a type can change is
              to narrow (<a href="#calibre_link-43" class="calibre9">Item 22</a>), but this involves a type getting
              smaller, not expanding to include new values. There are some important exceptions to this rule (<a
                href="#calibre_link-763" class="calibre9">Item 41</a>), but they are the exceptions and not the rule.
            </p>

            <p class="author1">How can you use this idea to fix the example? In order for <code
                class="calibre18">id</code>’s type to not change, it must be broad enough to encompass both <code
                class="calibre18">string</code>s and <code class="calibre18">number</code>s. This<a
                data-primary="union types" data-secondary="purpose of" data-type="indexterm" id="calibre_link-711"
                class="calibre9"></a> is the very definition of the union type, <code
                class="calibre18">string|number</code>:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">let</code> <code class="nx">id</code>: <code class="kd">string</code><code class="o">|</code><code class="kt">number</code> <code class="o">=</code> <code class="s">"12-34-56"</code><code class="p">;</code>
<code class="nx">fetchProduct</code><code class="p">(</code><code class="nx">id</code><code class="p">);</code>

<code class="nx">id</code> <code class="o">=</code> <code class="mi">123456</code><code class="p">;</code>  <code class="c">// OK</code>
<code class="nx">fetchProductBySerialNumber</code><code class="p">(</code><code class="nx">id</code><code class="p">);</code>  <code class="c">// OK</code></pre>

            <p class="author1">This fixes the errors. It’s interesting that TypeScript has been able to determine that
              <code class="calibre18">id</code> is really a <code class="calibre18">string</code> in the first call and
              really a <code class="calibre18">number</code> in the second. It has narrowed the union type based on the
              assignment.
            </p>

            <p class="author1">While a union type does work, it may create more issues down the road. Union types are
              harder to work with than simple types like <code class="calibre18">string</code> or <code
                class="calibre18">number</code> because you usually have to check what they are before you do anything
              with them.</p>

            <p class="author1">The better solution is to introduce a new variable:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">const</code> <code class="nx">id</code> <code class="o">=</code> <code class="s">"12-34-56"</code><code class="p">;</code>
<code class="nx">fetchProduct</code><code class="p">(</code><code class="nx">id</code><code class="p">);</code>

<code class="kd">const</code> <code class="nx">serial</code> <code class="o">=</code> <code class="mi">123456</code><code class="p">;</code>  <code class="c">// OK</code>
<code class="nx">fetchProductBySerialNumber</code><code class="p">(</code><code class="nx">serial</code><code class="p">);</code>  <code class="c">// OK</code></pre>

            <p class="author1">In the previous version, the first and second <code class="calibre18">id</code> were not
              semantically related to one another. They were only related by the fact that you reused a variable. This
              was confusing for the type checker and would be confusing for a human reader, too.</p>

            <p class="author1">The version with two variables is better for a number of reasons:</p>

            <ul class="printings">
              <li class="calibre12">
                <p class="author1">It disentangles two unrelated concepts (ID and serial number).</p>
              </li>
              <li class="calibre12">
                <p class="author1">It allows you to use more specific variable names.</p>
              </li>
              <li class="calibre12">
                <p class="author1">It improves type inference. No type annotations are needed.</p>
              </li>
              <li class="calibre12">
                <p class="author1">It results in simpler types (<code class="calibre18">string</code> and <code
                    class="calibre18">number</code>, rather than <code class="calibre18">string|number</code>).</p>
              </li>
              <li class="calibre12">
                <p class="author1">It lets you declare the variables <code class="calibre18">const</code> rather than
                  <code class="calibre18">let</code>. This makes them easier for people and the type checker to reason
                  about.
                </p>
              </li>
            </ul>

            <p class="author1">Try to avoid type-changing variables. If you can use different names for different
              concepts, it will make your code clearer both to human readers and to the type checker.</p>

            <p class="author1">This is not to be confused with “shadowed” variables as in this example:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">id</code> <code class="o">=</code> <code class="s">"12-34-56"</code><code class="p">;</code>
<code class="nx">fetchProduct</code><code class="p">(</code><code class="nx">id</code><code class="p">);</code>

<code class="p">{</code>
  <code class="kd">const</code> <code class="nx">id</code> <code class="o">=</code> <code class="mi">123456</code><code class="p">;</code>  <code class="c">// OK</code>
  <code class="nx">fetchProductBySerialNumber</code><code class="p">(</code><code class="nx">id</code><code class="p">);</code>  <code class="c">// OK</code>
<code class="p">}</code></pre>

            <p class="author1">While these two <code class="calibre18">id</code>s share a name, they are actually two
              distinct variables with no relationship to one another. It’s fine for them to have different types. While
              TypeScript is not confused by this, your human readers might be. In general it’s better to use different
              names for different concepts. Many teams choose to disallow this sort of shadowing via linter rules.</p>

            <p class="author1">This item focused on scalar values, but similar considerations apply to objects. For more
              on that, see <a href="#calibre_link-33" class="calibre9">Item 23</a>.</p>








            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-900">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">While a variable’s value can change, its type generally does not.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">To avoid confusion, both for human readers and for the type checker, avoid
                      reusing variables for differently typed values.<a data-primary="" data-startref="TIreuse03"
                        data-type="indexterm" id="calibre_link-612" class="calibre9"></a><a data-primary=""
                        data-startref="Vreuse03" data-type="indexterm" id="calibre_link-739" class="calibre9"></a></p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>













        <section data-pdf-bookmark="Item 21: Understand Type Widening" data-type="sect1" class="praise">
          <div class="praise" id="calibre_link-786">
            <h1 class="calibre16">Item 21: Understand Type Widening</h1>

            <p class="author1">As<a data-primary="type inference" data-secondary="type widening" data-type="indexterm"
                id="calibre_link-623" class="calibre9"></a><a data-primary="type widening" data-type="indexterm"
                id="calibre_link-665" class="calibre9"></a><a data-primary="widening" data-type="indexterm"
                id="calibre_link-747" class="calibre9"></a> <a href="#calibre_link-47" class="calibre9">Item 7</a>
              explained, at runtime every variable has a single value. But at static analysis time, when TypeScript is
              checking your code, a variable has a set of <em class="calibre3">possible</em> values, namely, its type.
              When you initialize a variable with a constant but don’t provide a type, the type checker needs to decide
              on one. In other words, it needs to decide on a set of possible values from the single value that you
              specified. In TypeScript, this process is known as <em class="calibre3">widening</em>. Understanding<a
                data-primary="type annotations" data-secondary="using more effectively" data-type="indexterm"
                id="calibre_link-563" class="calibre9"></a> it will help you make sense of errors and make more
              effective use of type annotations.</p>

            <p class="author1">Suppose you’re writing a library to work with vectors. You write out a type for a 3D
              vector and a function to get the value of any of its components:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Vector3</code> <code class="p">{</code> <code class="nx">x</code>: <code class="nx">number</code><code class="p">;</code> <code class="nx">y</code>: <code class="nx">number</code><code class="p">;</code> <code class="nx">z</code>: <code class="nx">number</code><code class="p">;</code> <code class="p">}</code>
<code class="kd">function</code> <code class="nx">getComponent</code><code class="p">(</code><code class="nx">vector</code>: <code class="nx">Vector3</code><code class="p">,</code> <code class="nx">axis</code><code class="o">:</code> <code class="s">'x'</code> <code class="o">|</code> <code class="s">'y'</code> <code class="o">|</code> <code class="s">'z'</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">vector</code><code class="p">[</code><code class="nx">axis</code><code class="p">];</code>
<code class="p">}</code></pre>

            <p class="author1">But when you try to use it, TypeScript flags an error:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">let</code> <code class="nx">x</code> <code class="o">=</code> <code class="s">'x'</code><code class="p">;</code>
<code class="kd">let</code> <code class="nx">vec</code> <code class="o">=</code> <code class="p">{</code><code class="nx">x</code>: <code class="nx">10</code><code class="p">,</code> <code class="nx">y</code>: <code class="nx">20</code><code class="p">,</code> <code class="nx">z</code>: <code class="nx">30</code><code class="p">};</code>
<code class="nx">getComponent</code><code class="p">(</code><code class="nx">vec</code><code class="p">,</code> <code class="nx">x</code><code class="p">);</code>
               <code class="c">// ~ Argument of type 'string' is not assignable to</code>
               <code class="c">//   parameter of type '"x" | "y" | "z"'</code></pre>

            <p class="author1">This code runs fine, so why the error?</p>

            <p class="author1">The issue is that <code class="calibre18">x</code>’s type is inferred as <code
                class="calibre18">string</code>, whereas the <code class="calibre18">getComponent</code> function
              expected a more specific type for its second argument. This is widening at work, and here it has led to an
              error.</p>

            <p class="author1">This<a data-primary="const" data-secondary="need for context" data-type="indexterm"
                id="calibre_link-188" class="calibre9"></a> process is ambiguous in the sense that there are many
              possible types for any given value. In this statement, for example:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">const</code> <code class="nx">mixed</code> <code class="o">=</code> <code class="p">[</code><code class="s">'x'</code><code class="p">,</code> <code class="mi">1</code><code class="p">];</code></pre>

            <p class="author1">what should the type of <code class="calibre18">mixed</code> be? Here are a few
              possibilities:</p>

            <ul class="printings">
              <li class="calibre12">
                <p class="author1"><code class="calibre18">('x' | 1)[]</code></p>
              </li>
              <li class="calibre12">
                <p class="author1"><code class="calibre18">['x', 1]</code></p>
              </li>
              <li class="calibre12">
                <p class="author1"><code class="calibre18">[string, number]</code></p>
              </li>
              <li class="calibre12">
                <p class="author1"><code class="calibre18">readonly [string, number]</code></p>
              </li>
              <li class="calibre12">
                <p class="author1"><code class="calibre18">(string|number)[]</code></p>
              </li>
              <li class="calibre12">
                <p class="author1"><code class="calibre18">readonly (string|number)[]</code></p>
              </li>
              <li class="calibre12">
                <p class="author1"><code class="calibre18">[any, any]</code></p>
              </li>
              <li class="calibre12">
                <p class="author1"><code class="calibre18">any[]</code></p>
              </li>
            </ul>

            <p class="author1">Without<a data-primary="context" data-type="indexterm" id="calibre_link-192"
                class="calibre9"></a> more context, TypeScript has no way to know which one is “right.” It has to guess
              at your intent. (In this case, it guesses <code class="calibre18">(string|number)[]</code>.) And smart as
              it is, TypeScript can’t read your mind. It won’t get this right 100% of the time. The result is
              inadvertent errors like the one we just looked at.</p>

            <p class="author1">In the initial example, the type of <code class="calibre18">x</code> is inferred as <code
                class="calibre18">string</code> because TypeScript chooses to allow code like this:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">let</code> <code class="nx">x</code> <code class="o">=</code> <code class="s">'x'</code><code class="p">;</code>
<code class="nx">x</code> <code class="o">=</code> <code class="s">'a'</code><code class="p">;</code>
<code class="nx">x</code> <code class="o">=</code> <code class="s">'Four score and seven years ago...'</code><code class="p">;</code></pre>

            <p class="author1">But it would also be valid JavaScript to write:</p>

            <pre data-code-language="js" data-type="programlisting"
              class="calibre17"><code class="kd">let</code> <code class="nx">x</code> <code class="o">=</code> <code class="s">'x'</code><code class="p">;</code>
<code class="nx">x</code> <code class="o">=</code> <code class="sr">/x|y|z/</code><code class="p">;</code>
<code class="nx">x</code> <code class="o">=</code> <code class="p">[</code><code class="s">'x'</code><code class="p">,</code> <code class="s">'y'</code><code class="p">,</code> <code class="s">'z'</code><code class="p">];</code></pre>

            <p class="author1">In inferring the type of <code class="calibre18">x</code> as <code
                class="calibre18">string</code>, TypeScript attempts to strike a balance between specificity and
              flexibility. The general rule is that a variable’s type shouldn’t change after it’s declared (<a
                href="#calibre_link-810" class="calibre9">Item 20</a>), so <code class="calibre18">string</code> makes
              more sense than <code class="calibre18">string|RegExp</code> or <code
                class="calibre18">string|string[]</code> or <code class="calibre18">any</code>.</p>

            <p class="author1">TypeScript gives you a few ways to control the process of widening. One is <code
                class="calibre18">const</code>. If you declare a variable with <code class="calibre18">const</code>
              instead of <code class="calibre18">let</code>, it gets a narrower type. In fact, using <code
                class="calibre18">const</code> fixes the error in our original example:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">const</code> <code class="nx">x</code> <code class="o">=</code> <code class="s">'x'</code><code class="p">;</code>  <code class="c">// type is "x"</code>
<code class="kd">let</code> <code class="nx">vec</code> <code class="o">=</code> <code class="p">{</code><code class="nx">x</code>: <code class="nx">10</code><code class="p">,</code> <code class="nx">y</code>: <code class="nx">20</code><code class="p">,</code> <code class="nx">z</code>: <code class="nx">30</code><code class="p">};</code>
<code class="nx">getComponent</code><code class="p">(</code><code class="nx">vec</code><code class="p">,</code> <code class="nx">x</code><code class="p">);</code>  <code class="c">// OK</code></pre>

            <p class="author1">Because <code class="calibre18">x</code> cannot be reassigned, TypeScript is able to
              infer a narrower type without risk of inadvertently flagging errors on subsequent assignments. And because
              the string literal type <code class="calibre18">"x"</code> is assignable to <code
                class="calibre18">"x"|"y"|"z"</code>, the code passes the type checker.</p>

            <p class="author1"><code class="calibre18">const</code> isn’t a panacea, however. For objects and arrays,
              there is still ambiguity. The <code class="calibre18">mixed</code> example here illustrates the issue for
              arrays: should TypeScript infer a tuple type? What type should it infer for the elements? Similar issues
              arise with objects. This code is fine in JavaScript:</p>

            <pre data-code-language="js" data-type="programlisting"
              class="calibre17"><code class="kd">const</code> <code class="nx">v</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">x</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code>
<code class="p">};</code>
<code class="nx">v</code><code class="p">.</code><code class="nx">x</code> <code class="o">=</code> <code class="mi">3</code><code class="p">;</code>
<code class="nx">v</code><code class="p">.</code><code class="nx">x</code> <code class="o">=</code> <code class="s">'3'</code><code class="p">;</code>
<code class="nx">v</code><code class="p">.</code><code class="nx">y</code> <code class="o">=</code> <code class="mi">4</code><code class="p">;</code>
<code class="nx">v</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="s">'Pythagoras'</code><code class="p">;</code></pre>

            <p class="author1">The type of <code class="calibre18">v</code> could be inferred anywhere along the
              spectrum of specificity. At the specific end is <code class="calibre18">{readonly x: 1}</code>. More
              general is <code class="calibre18">{x: number}</code>. More general still would be <code
                class="calibre18">{[key: string]: number}</code> or <code class="calibre18">object</code>. In the case
              of objects, TypeScript’s widening algorithm treats each element as though it were assigned with <code
                class="calibre18">let</code>. So the type of <code class="calibre18">v</code> comes out as <code
                class="calibre18">{x: number}</code>. This lets you reassign <code class="calibre18">v.x</code> to a
              different number, but not to a <code class="calibre18">string</code>. And it prevents you from adding
              other properties. (This is a good reason to build objects all at once, as explained in <a
                href="#calibre_link-33" class="calibre9">Item 23</a>.)</p>

            <p class="author1">So the last three statements are errors:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"> <code class="kd">const</code> <code class="nx">v</code> <code class="o">=</code> <code class="p">{</code>
   <code class="nx">x</code>: <code class="nx">1</code><code class="p">,</code>
 <code class="p">};</code>
 <code class="nx">v</code><code class="p">.</code><code class="nx">x</code> <code class="o">=</code> <code class="mi">3</code><code class="p">;</code>  <code class="c">// OK</code>
 <code class="nx">v</code><code class="p">.</code><code class="nx">x</code> <code class="o">=</code> <code class="s">'3'</code><code class="p">;</code>
<code class="c">// ~ Type '"3"' is not assignable to type 'number'</code>
 <code class="nx">v</code><code class="p">.</code><code class="nx">y</code> <code class="o">=</code> <code class="mi">4</code><code class="p">;</code>
<code class="c">// ~ Property 'y' does not exist on type '{ x: number; }'</code>
 <code class="nx">v</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="s">'Pythagoras'</code><code class="p">;</code>
<code class="c">// ~~~~ Property 'name' does not exist on type '{ x: number; }'</code></pre>

            <p class="author1">Again, TypeScript is trying to strike a balance between specificity and flexibility. It
              needs to infer a specific enough type to catch errors, but not so specific that it creates false
              positives. It does this by inferring a type of <code class="calibre18">number</code> for a property
              initialized to a value like <code class="calibre18">1</code>.</p>

            <p class="author1">If you know better, there are a few ways to override TypeScript’s default behavior. One
              is to supply an explicit type annotation:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">v</code><code class="o">:</code> <code class="p">{</code><code class="nx">x</code>: <code class="nx">1</code><code class="o">|</code><code class="mi">3</code><code class="o">|</code><code class="mi">5</code><code class="p">}</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">x</code>: <code class="nx">1</code><code class="p">,</code>
<code class="p">};</code>  <code class="c">// Type is { x: 1 | 3 | 5; }</code></pre>

            <p class="author1">Another is to provide additional context to the type checker (e.g., by passing the value
              as the parameter of a function). For much more on the role of context in type inference, see <a
                href="#calibre_link-760" class="calibre9">Item 26</a>.</p>

            <p class="author1">A<a data-primary="as const" data-type="indexterm" id="calibre_link-112"
                class="calibre9"></a><a data-primary="const assertion" data-type="indexterm" id="calibre_link-190"
                class="calibre9"></a> third way is with a <code class="calibre18">const</code> assertion. This is not to
              be confused with <code class="calibre18">let</code> and <code class="calibre18">const</code>, which
              introduce symbols in value space. This is a purely type-level construct. Look at the different inferred
              types for these variables:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">const</code> <code class="nx">v1</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">x</code>: <code class="nx">1</code><code class="p">,</code>
  <code class="nx">y</code>: <code class="nx">2</code><code class="p">,</code>
<code class="p">};</code>  <code class="c">// Type is { x: number; y: number; }</code>

<code class="kd">const</code> <code class="nx">v2</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">x</code>: <code class="nx">1</code> <code class="kd">as</code> <code class="kd">const</code><code class="p">,</code>
  <code class="nx">y</code>: <code class="nx">2</code><code class="p">,</code>
<code class="p">};</code>  <code class="c">// Type is { x: 1; y: number; }</code>

<code class="kd">const</code> <code class="nx">v3</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">x</code>: <code class="nx">1</code><code class="p">,</code>
  <code class="nx">y</code>: <code class="nx">2</code><code class="p">,</code>
<code class="p">}</code> <code class="kd">as</code> <code class="kd">const</code><code class="p">;</code>  <code class="c">// Type is { readonly x: 1; readonly y: 2; }</code></pre>

            <p class="author1">When you write <code class="calibre18">as const</code> after a value, TypeScript will
              infer the narrowest possible type for it. There is <em class="calibre3">no</em> widening. For true
              constants, this is typically what you want. You can also use <code class="calibre18">as const</code> with
              arrays to infer a tuple type:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">const</code> <code class="nx">a1</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">];</code>  <code class="c">// Type is number[]</code>
<code class="kd">const</code> <code class="nx">a2</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">]</code> <code class="kd">as</code> <code class="kd">const</code><code class="p">;</code>  <code class="c">// Type is readonly [1, 2, 3]</code></pre>

            <p class="author1">If you’re getting incorrect errors that you think are due to widening, consider adding
              some explicit type annotations or <code class="calibre18">const</code> assertions. Inspecting types in
              your editor is the key to building an intuition for this (see <a href="#calibre_link-775"
                class="calibre9">Item 6</a>).</p>








            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-901">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">Understand how TypeScript infers a type from a constant by widening it.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Familiarize yourself with the ways you can affect this behavior: <code
                        class="calibre18">const</code>, type annotations, context, and <code
                        class="calibre18">as const</code>.<a data-primary="" data-startref="TIwiden03"
                        data-type="indexterm" id="calibre_link-624" class="calibre9"></a><a data-primary=""
                        data-startref="twiden03" data-type="indexterm" id="calibre_link-666" class="calibre9"></a><a
                        data-primary="" data-startref="widen03" data-type="indexterm" id="calibre_link-748"
                        class="calibre9"></a></p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>













        <section data-pdf-bookmark="Item 22: Understand Type Narrowing" data-type="sect1" class="praise">
          <div class="praise" id="calibre_link-43">
            <h1 class="calibre16">Item 22: Understand Type Narrowing</h1>

            <p class="author1">The<a data-primary="narrowing" data-type="indexterm" id="calibre_link-414"
                class="calibre9"></a><a data-primary="type inference" data-secondary="type narrowing"
                data-type="indexterm" id="calibre_link-621" class="calibre9"></a><a data-primary="type narrowing"
                data-type="indexterm" id="calibre_link-625" class="calibre9"></a> opposite of widening is narrowing.
              This is the process by which TypeScript goes from a broad type to a narrower one. Perhaps the most common
              example of this is null checking:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">el</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s">'foo'</code><code class="p">);</code> <code class="c">// Type is HTMLElement | null</code>
<code class="kd">if</code> <code class="p">(</code><code class="nx">el</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">el</code> <code class="c">// Type is HTMLElement</code>
  <code class="nx">el</code><code class="p">.</code><code class="nx">innerHTML</code> <code class="o">=</code> <code class="s">'Party Time'</code><code class="p">.</code><code class="nx">blink</code><code class="p">();</code>
<code class="p">}</code> <code class="kd">else</code> <code class="p">{</code>
  <code class="nx">el</code> <code class="c">// Type is null</code>
  <code class="nx">alert</code><code class="p">(</code><code class="s">'No element #foo'</code><code class="p">);</code>
<code class="p">}</code></pre>

            <p class="author1">If <code class="calibre18">el</code> is <code class="calibre18">null</code>, then the
              code in the first branch won’t execute. So TypeScript is able to exclude <code
                class="calibre18">null</code> from the type union within this block, resulting in a narrower type which
              is much easier to work with. The type checker is generally quite good at narrowing types in conditionals
              like these, though it can occasionally be thwarted by aliasing (<a href="#calibre_link-801"
                class="calibre9">Item 24</a>).</p>

            <p class="author1">You can also narrow a variable’s type for the rest of a block by throwing or returning
              from a branch. For example:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">const</code> <code class="nx">el</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s">'foo'</code><code class="p">);</code> <code class="c">// Type is HTMLElement | null</code>
<code class="kd">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">el</code><code class="p">)</code> <code class="kd">throw</code> <code class="kd">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s">'Unable to find #foo'</code><code class="p">);</code>
<code class="nx">el</code><code class="p">;</code> <code class="c">// Now type is HTMLElement</code>
<code class="nx">el</code><code class="p">.</code><code class="nx">innerHTML</code> <code class="o">=</code> <code class="s">'Party Time'</code><code class="p">.</code><code class="nx">blink</code><code class="p">();</code></pre>

            <p class="author1">There are many ways that you can narrow a type. Using <code
                class="calibre18">instanceof</code> works:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">contains</code><code class="p">(</code><code class="nx">text</code>: <code class="kd">string</code><code class="p">,</code> <code class="nx">search</code>: <code class="kd">string</code><code class="o">|</code><code class="nb">RegExp</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">search</code> <code class="kd">instanceof</code> <code class="nb">RegExp</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">search</code>  <code class="c">// Type is RegExp</code>
    <code class="kd">return</code> <code class="o">!!</code><code class="nx">search</code><code class="p">.</code><code class="nx">exec</code><code class="p">(</code><code class="nx">text</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="nx">search</code>  <code class="c">// Type is string</code>
  <code class="kd">return</code> <code class="nx">text</code><code class="p">.</code><code class="nx">includes</code><code class="p">(</code><code class="nx">search</code><code class="p">);</code>
<code class="p">}</code></pre>

            <p class="author1">So does a property check:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">A</code> <code class="p">{</code> <code class="nx">a</code>: <code class="nx">number</code> <code class="p">}</code>
<code class="kd">interface</code> <code class="nx">B</code> <code class="p">{</code> <code class="nx">b</code>: <code class="nx">number</code> <code class="p">}</code>
<code class="kd">function</code> <code class="nx">pickAB</code><code class="p">(</code><code class="nx">ab</code>: <code class="nx">A</code> <code class="o">|</code> <code class="nx">B</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="s">'a'</code> <code class="kd">in</code> <code class="nx">ab</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">ab</code> <code class="c">// Type is A</code>
  <code class="p">}</code> <code class="kd">else</code> <code class="p">{</code>
    <code class="nx">ab</code> <code class="c">// Type is B</code>
  <code class="p">}</code>
  <code class="nx">ab</code> <code class="c">// Type is A | B</code>
<code class="p">}</code></pre>

            <p class="author1">Some built-in functions such as <code class="calibre18">Array.isArray</code> are able to
              narrow types:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">contains</code><code class="p">(</code><code class="nx">text</code>: <code class="kd">string</code><code class="p">,</code> <code class="nx">terms</code>: <code class="kd">string</code><code class="o">|</code><code class="kt">string</code><code class="p">[])</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">termList</code> <code class="o">=</code> <code class="nb">Array</code><code class="p">.</code><code class="nx">isArray</code><code class="p">(</code><code class="nx">terms</code><code class="p">)</code> <code class="o">?</code> <code class="nx">terms</code> <code class="o">:</code> <code class="p">[</code><code class="nx">terms</code><code class="p">];</code>
  <code class="nx">termList</code> <code class="c">// Type is string[]</code>
  <code class="c">// ...</code>
<code class="p">}</code></pre>

            <p class="author1">TypeScript is generally quite good at tracking types through conditionals. Think twice
              before adding an assertion&mdash;it might be onto something that you’re not! For example, this is the
              wrong way to exclude <code class="calibre18">null</code> from a union type:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">el</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s">'foo'</code><code class="p">);</code> <code class="c">// type is HTMLElement | null</code>
<code class="kd">if</code> <code class="p">(</code><code class="kd">typeof</code> <code class="nx">el</code> <code class="o">===</code> <code class="s">'object'</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">el</code><code class="p">;</code>  <code class="c">// Type is HTMLElement | null</code>
<code class="p">}</code></pre>

            <p class="author1">Because <code class="calibre18">typeof null</code> is <code
                class="calibre18">"object"</code> in JavaScript, you have not, in fact, excluded <code
                class="calibre18">null</code> with this check! Similar surprises can come from falsy primitive values:
            </p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">foo</code><code class="p">(</code><code class="nx">x?</code>: <code class="nx">number</code><code class="o">|</code><code class="nx">string</code><code class="o">|</code><code class="nx">null</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">x</code><code class="p">;</code>  <code class="c">// Type is string | number | null | undefined</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

            <p class="author1">Because the empty string and <code class="calibre18">0</code> are both falsy, <code
                class="calibre18">x</code> could still be a <code class="calibre18">string</code> or <code
                class="calibre18">number</code> in that branch. TypeScript is right!</p>

            <p class="author1">Another common way to help the type checker narrow your types is by putting an explicit
              “tag” on them:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">UploadEvent</code> <code class="p">{</code> <code class="nx">type</code>: <code class="s">'upload'</code><code class="p">;</code> <code class="nx">filename</code>: <code class="kd">string</code><code class="p">;</code> <code class="nx">contents</code>: <code class="kd">string</code> <code class="p">}</code>
<code class="kd">interface</code> <code class="nx">DownloadEvent</code> <code class="p">{</code> <code class="nx">type</code>: <code class="s">'download'</code><code class="p">;</code> <code class="nx">filename</code>: <code class="kd">string</code><code class="p">;</code> <code class="p">}</code>
<code class="kd">type</code> <code class="nx">AppEvent</code> <code class="o">=</code> <code class="nx">UploadEvent</code> <code class="o">|</code> <code class="nx">DownloadEvent</code><code class="p">;</code>

<code class="kd">function</code> <code class="nx">handleEvent</code><code class="p">(</code><code class="nx">e</code>: <code class="nx">AppEvent</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">switch</code> <code class="p">(</code><code class="nx">e</code><code class="p">.</code><code class="nx">type</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">case</code> <code class="s">'download'</code><code class="o">:</code>
      <code class="nx">e</code>  <code class="c">// Type is DownloadEvent</code>
      <code class="kd">break</code><code class="p">;</code>
    <code class="kd">case</code> <code class="s">'upload'</code><code class="o">:</code>
      <code class="nx">e</code><code class="p">;</code>  <code class="c">// Type is UploadEvent</code>
      <code class="kd">break</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

            <p class="author1">This<a data-primary="tagged unions" data-secondary="example of" data-type="indexterm"
                id="calibre_link-528" class="calibre9"></a><a data-primary="discriminated unions"
                data-see="tagged unions" data-type="indexterm" id="calibre_link-902" class="calibre9"></a> pattern is
              known as a “tagged union” or “discriminated union,” and it is ubiquitous in TypeScript.</p>

            <p class="author1">If TypeScript isn’t able to figure out a type, you can even introduce a custom function
              to help it out:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">isInputElement</code><code class="p">(</code><code class="nx">el</code>: <code class="nx">HTMLElement</code><code class="p">)</code><code class="o">:</code> <code class="nx">el</code> <code class="nx">is</code> <code class="nx">HTMLInputElement</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="s">'value'</code> <code class="kd">in</code> <code class="nx">el</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="nx">getElementContent</code><code class="p">(</code><code class="nx">el</code>: <code class="nx">HTMLElement</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">isInputElement</code><code class="p">(</code><code class="nx">el</code><code class="p">))</code> <code class="p">{</code>
    <code class="nx">el</code><code class="p">;</code> <code class="c">// Type is HTMLInputElement</code>
    <code class="kd">return</code> <code class="nx">el</code><code class="p">.</code><code class="nx">value</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="nx">el</code><code class="p">;</code> <code class="c">// Type is HTMLElement</code>
  <code class="kd">return</code> <code class="nx">el</code><code class="p">.</code><code class="nx">textContent</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">This<a data-primary="user-defined type guards" data-type="indexterm"
                id="calibre_link-720" class="calibre9"></a> is known as a “user-defined type guard.” The <code
                class="calibre18">el is HTMLInputElement</code> as a return type tells the type checker that it can
              narrow the type of the parameter if the function returns true.</p>

            <p class="author1">Some functions are able to use type guards to perform type narrowing across arrays or
              objects. If you do some lookups in an array, for instance, you may wind up with an array of nullable
              types:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">jackson5</code> <code class="o">=</code> <code class="p">[</code><code class="s">'Jackie'</code><code class="p">,</code> <code class="s">'Tito'</code><code class="p">,</code> <code class="s">'Jermaine'</code><code class="p">,</code> <code class="s">'Marlon'</code><code class="p">,</code> <code class="s">'Michael'</code><code class="p">];</code>
<code class="kd">const</code> <code class="nx">members</code> <code class="o">=</code> <code class="p">[</code><code class="s">'Janet'</code><code class="p">,</code> <code class="s">'Michael'</code><code class="p">].</code><code class="nx">map</code><code class="p">(</code>
  <code class="nx">who</code> <code class="o">=&gt;</code> <code class="nx">jackson5</code><code class="p">.</code><code class="nx">find</code><code class="p">(</code><code class="nx">n</code> <code class="o">=&gt;</code> <code class="nx">n</code> <code class="o">===</code> <code class="nx">who</code><code class="p">)</code>
<code class="p">);</code>  <code class="c">// Type is (string | undefined)[]</code></pre>

            <p class="author1">If you filter out the <code class="calibre18">undefined</code> values using <code
                class="calibre18">filter</code>, TypeScript isn’t able to follow along:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">const</code> <code class="nx">members</code> <code class="o">=</code> <code class="p">[</code><code class="s">'Janet'</code><code class="p">,</code> <code class="s">'Michael'</code><code class="p">].</code><code class="nx">map</code><code class="p">(</code>
  <code class="nx">who</code> <code class="o">=&gt;</code> <code class="nx">jackson5</code><code class="p">.</code><code class="nx">find</code><code class="p">(</code><code class="nx">n</code> <code class="o">=&gt;</code> <code class="nx">n</code> <code class="o">===</code> <code class="nx">who</code><code class="p">)</code>
<code class="p">).</code><code class="nx">filter</code><code class="p">(</code><code class="nx">who</code> <code class="o">=&gt;</code> <code class="nx">who</code> <code class="o">!==</code> <code class="kd">undefined</code><code class="p">);</code>  <code class="c">// Type is (string | undefined)[]</code></pre>

            <p class="author1">But if you use a type guard, it can:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">function</code> <code class="nx">isDefined</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">x</code>: <code class="nx">T</code> <code class="o">|</code> <code class="kd">undefined</code><code class="p">)</code><code class="o">:</code> <code class="nx">x</code> <code class="nx">is</code> <code class="nx">T</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">x</code> <code class="o">!==</code> <code class="kd">undefined</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">const</code> <code class="nx">members</code> <code class="o">=</code> <code class="p">[</code><code class="s">'Janet'</code><code class="p">,</code> <code class="s">'Michael'</code><code class="p">].</code><code class="nx">map</code><code class="p">(</code>
  <code class="nx">who</code> <code class="o">=&gt;</code> <code class="nx">jackson5</code><code class="p">.</code><code class="nx">find</code><code class="p">(</code><code class="nx">n</code> <code class="o">=&gt;</code> <code class="nx">n</code> <code class="o">===</code> <code class="nx">who</code><code class="p">)</code>
<code class="p">).</code><code class="nx">filter</code><code class="p">(</code><code class="nx">isDefined</code><code class="p">);</code>  <code class="c">// Type is string[]</code></pre>

            <p class="author1">As always, inspecting types in your editor is key to building an intuition for how
              narrowing works.</p>

            <p class="author1">Understanding how types in TypeScript narrow will help you build an intuition for how
              type inference works, make sense of errors, and generally have a more productive relationship with the
              type checker.</p>








            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-903">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">Understand how TypeScript narrows types based on conditionals and other types of
                      control flow.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Use tagged/discriminated unions and user-defined type guards to help the process
                      of narrowing.<a data-primary="" data-startref="TInarrow03" data-type="indexterm"
                        id="calibre_link-622" class="calibre9"></a><a data-primary="" data-startref="tnarrow03"
                        data-type="indexterm" id="calibre_link-626" class="calibre9"></a></p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>













        <section data-pdf-bookmark="Item 23: Create Objects All at Once" data-type="sect1" class="praise">
          <div class="praise" id="calibre_link-33">
            <h1 class="calibre16">Item 23: Create Objects All at Once</h1>

            <p class="author1">As<a data-primary="type inference" data-secondary="object creation" data-type="indexterm"
                id="calibre_link-619" class="calibre9"></a><a data-primary="objects"
                data-secondary="creating all at once" data-type="indexterm" id="calibre_link-447" class="calibre9"></a>
              <a href="#calibre_link-810" class="calibre9">Item 20</a> explained, while a variable’s value may change,
              its type in TypeScript generally does not. This makes some JavaScript patterns easier to model in
              TypeScript than others. In particular, it means that you should prefer creating objects all at once,
              rather than piece by piece.
            </p>

            <p class="author1">Here’s one way to create an object representing a two-dimensional point in JavaScript:
            </p>

            <pre data-code-language="js" data-type="programlisting"
              class="calibre17"><code class="kd">const</code> <code class="nx">pt</code> <code class="o">=</code> <code class="p">{};</code>
<code class="nx">pt</code><code class="p">.</code><code class="nx">x</code> <code class="o">=</code> <code class="mi">3</code><code class="p">;</code>
<code class="nx">pt</code><code class="p">.</code><code class="nx">y</code> <code class="o">=</code> <code class="mi">4</code><code class="p">;</code></pre>

            <p class="author1">In TypeScript, this will produce errors on each assignment:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">pt</code> <code class="o">=</code> <code class="p">{};</code>
<code class="nx">pt</code><code class="p">.</code><code class="nx">x</code> <code class="o">=</code> <code class="mi">3</code><code class="p">;</code>
<code class="c">// ~ Property 'x' does not exist on type '{}'</code>
<code class="nx">pt</code><code class="p">.</code><code class="nx">y</code> <code class="o">=</code> <code class="mi">4</code><code class="p">;</code>
<code class="c">// ~ Property 'y' does not exist on type '{}'</code></pre>

            <p class="author1">This is because the type of <code class="calibre18">pt</code> on the first line is
              inferred based on its value <code class="calibre18">{}</code>, and you may only assign to known
              properties.</p>

            <p class="author1">You get the opposite problem if you define a <code class="calibre18">Point</code>
              interface:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">interface</code> <code class="nx">Point</code> <code class="p">{</code> <code class="nx">x</code>: <code class="nx">number</code><code class="p">;</code> <code class="nx">y</code>: <code class="nx">number</code><code class="p">;</code> <code class="p">}</code>
<code class="kd">const</code> <code class="nx">pt</code>: <code class="nx">Point</code> <code class="o">=</code> <code class="p">{};</code>
   <code class="c">// ~~ Type '{}' is missing the following properties from type 'Point': x, y</code>
<code class="nx">pt</code><code class="p">.</code><code class="nx">x</code> <code class="o">=</code> <code class="mi">3</code><code class="p">;</code>
<code class="nx">pt</code><code class="p">.</code><code class="nx">y</code> <code class="o">=</code> <code class="mi">4</code><code class="p">;</code></pre>

            <p class="author1">The solution is to define the object all at once:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">pt</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">x</code>: <code class="nx">3</code><code class="p">,</code>
  <code class="nx">y</code>: <code class="nx">4</code><code class="p">,</code>
<code class="p">};</code>  <code class="c">// OK</code></pre>

            <p class="author1">If you must build the object piecemeal, you may use a type assertion (<code
                class="calibre18">as</code>) to silence the type checker:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">const</code> <code class="nx">pt</code> <code class="o">=</code> <code class="p">{}</code> <code class="kd">as</code> <code class="nx">Point</code><code class="p">;</code>
<code class="nx">pt</code><code class="p">.</code><code class="nx">x</code> <code class="o">=</code> <code class="mi">3</code><code class="p">;</code>
<code class="nx">pt</code><code class="p">.</code><code class="nx">y</code> <code class="o">=</code> <code class="mi">4</code><code class="p">;</code>  <code class="c">// OK</code></pre>

            <p class="author1">But the better way is by building the object all at once and using a declaration (see <a
                href="#calibre_link-27" class="calibre9">Item 9</a>):</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">pt</code>: <code class="nx">Point</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">x</code>: <code class="nx">3</code><code class="p">,</code>
  <code class="nx">y</code>: <code class="nx">4</code><code class="p">,</code>
<code class="p">};</code></pre>

            <p class="author1">If you need to build a larger object from smaller ones, avoid doing it in multiple steps:
            </p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">pt</code> <code class="o">=</code> <code class="p">{</code><code class="nx">x</code>: <code class="nx">3</code><code class="p">,</code> <code class="nx">y</code>: <code class="nx">4</code><code class="p">};</code>
<code class="kd">const</code> <code class="nx">id</code> <code class="o">=</code> <code class="p">{</code><code class="nx">name</code><code class="o">:</code> <code class="s">'Pythagoras'</code><code class="p">};</code>
<code class="kd">const</code> <code class="nx">namedPoint</code> <code class="o">=</code> <code class="p">{};</code>
<code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">(</code><code class="nx">namedPoint</code><code class="p">,</code> <code class="nx">pt</code><code class="p">,</code> <code class="nx">id</code><code class="p">);</code>
<code class="nx">namedPoint</code><code class="p">.</code><code class="nx">name</code><code class="p">;</code>
        <code class="c">// ~~~~ Property 'name' does not exist on type '{}'</code></pre>

            <p class="author1">You<a data-primary="object spread operator (…)" data-type="indexterm"
                id="calibre_link-436" class="calibre9"></a> can build the larger object all at once instead using the
              <em class="calibre3">object spread operator</em>, <code class="calibre18">...</code>:
            </p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">const</code> <code class="nx">namedPoint</code> <code class="o">=</code> <code class="p">{...</code><code class="nx">pt</code><code class="p">,</code> <code class="p">...</code><code class="nx">id</code><code class="p">};</code>
<code class="nx">namedPoint</code><code class="p">.</code><code class="nx">name</code><code class="p">;</code>  <code class="c">// OK, type is string</code></pre>

            <p class="author1">You can also use the object spread operator to build up objects field by field in a
              type-safe way. The key is to use a new variable on every update so that each gets a new type:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">const</code> <code class="nx">pt0</code> <code class="o">=</code> <code class="p">{};</code>
<code class="kd">const</code> <code class="nx">pt1</code> <code class="o">=</code> <code class="p">{...</code><code class="nx">pt0</code><code class="p">,</code> <code class="nx">x</code>: <code class="nx">3</code><code class="p">};</code>
<code class="kd">const</code> <code class="nx">pt</code>: <code class="nx">Point</code> <code class="o">=</code> <code class="p">{...</code><code class="nx">pt1</code><code class="p">,</code> <code class="nx">y</code>: <code class="nx">4</code><code class="p">};</code>  <code class="c">// OK</code></pre>

            <p class="author1">While this is a roundabout way to build up such a simple object, it can be a useful
              technique for adding properties to an object and allowing TypeScript to infer a new type.</p>

            <p class="author1">To conditionally add a property in a type-safe way, you can use object spread with <code
                class="calibre18">null</code> or <code class="calibre18">{}</code>, which add no properties:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">declare</code> <code class="kd">let</code> <code class="nx">hasMiddle</code>: <code class="nx">boolean</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">firstLast</code> <code class="o">=</code> <code class="p">{</code><code class="nx">first</code><code class="o">:</code> <code class="s">'Harry'</code><code class="p">,</code> <code class="nx">last</code><code class="o">:</code> <code class="s">'Truman'</code><code class="p">};</code>
<code class="kd">const</code> <code class="nx">president</code> <code class="o">=</code> <code class="p">{...</code><code class="nx">firstLast</code><code class="p">,</code> <code class="p">...(</code><code class="nx">hasMiddle</code> <code class="o">?</code> <code class="p">{</code><code class="nx">middle</code><code class="o">:</code> <code class="s">'S'</code><code class="p">}</code> <code class="o">:</code> <code class="p">{})};</code></pre>

            <p class="author1">If you mouse over <code class="calibre18">president</code> in your editor, you’ll see
              that its type is inferred as a union:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">president</code><code class="o">:</code> <code class="p">{</code>
    <code class="nx">middle</code>: <code class="kd">string</code><code class="p">;</code>
    <code class="nx">first</code>: <code class="kd">string</code><code class="p">;</code>
    <code class="nx">last</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code> <code class="o">|</code> <code class="p">{</code>
    <code class="nx">first</code>: <code class="kd">string</code><code class="p">;</code>
    <code class="nx">last</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">This may come as a surprise if you wanted <code class="calibre18">middle</code> to be an
              optional field. You can’t read <code class="calibre18">middle</code> off this type, for example:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="nx">president</code><code class="p">.</code><code class="nx">middle</code>
       <code class="c">// ~~~~~~ Property 'middle' does not exist on type</code>
       <code class="c">//        '{ first: string; last: string; }'</code></pre>

            <p class="author1">If you’re conditionally adding multiple properties, the union does more accurately
              represent the set of possible values (<a href="#calibre_link-811" class="calibre9">Item 32</a>). But an
              optional field would be easier to work with. You can get one with a helper:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">function</code> <code class="nx">addOptional</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kd">extends</code> <code class="nx">object</code><code class="p">,</code> <code class="nx">U</code> <code class="kd">extends</code> <code class="nx">object</code><code class="o">&gt;</code><code class="p">(</code>
  <code class="nx">a</code>: <code class="nx">T</code><code class="p">,</code> <code class="nx">b</code>: <code class="nx">U</code> <code class="o">|</code> <code class="kd">null</code>
<code class="p">)</code><code class="o">:</code> <code class="nx">T</code> <code class="o">&amp;</code> <code class="nx">Partial</code><code class="o">&lt;</code><code class="nx">U</code><code class="o">&gt;</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="p">{...</code><code class="nx">a</code><code class="p">,</code> <code class="p">...</code><code class="nx">b</code><code class="p">};</code>
<code class="p">}</code>

<code class="kd">const</code> <code class="nx">president</code> <code class="o">=</code> <code class="nx">addOptional</code><code class="p">(</code><code class="nx">firstLast</code><code class="p">,</code> <code class="nx">hasMiddle</code> <code class="o">?</code> <code class="p">{</code><code class="nx">middle</code><code class="o">:</code> <code class="s">'S'</code><code class="p">}</code> <code class="o">:</code> <code class="kd">null</code><code class="p">);</code>
<code class="nx">president</code><code class="p">.</code><code class="nx">middle</code>  <code class="c">// OK, type is string | undefined</code></pre>

            <p class="author1">Sometimes you want to build an object or array by transforming another one. In this case
              the equivalent of “building objects all at once” is using built-in functional constructs or utility
              libraries like Lodash rather than loops. See <a href="#calibre_link-44" class="calibre9">Item 27</a> for
              more on this.</p>








            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-904">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">Prefer to build objects all at once rather than piecemeal. Use object spread
                      (<code class="calibre18">{...a, ...b}</code>) to add properties in a type-safe way.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Know how to conditionally add properties to an object.<a data-primary=""
                        data-startref="TIobject03" data-type="indexterm" id="calibre_link-620" class="calibre9"></a><a
                        data-primary="" data-startref="Ocreate03" data-type="indexterm" id="calibre_link-448"
                        class="calibre9"></a></p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>













        <section data-pdf-bookmark="Item 24: Be Consistent in Your Use of Aliases" data-type="sect1" class="praise">
          <div class="praise" id="calibre_link-801">
            <h1 class="calibre16">Item 24: Be Consistent in Your Use of Aliases</h1>

            <p class="author1">When<a data-primary="type inference" data-secondary="aliases" data-type="indexterm"
                id="calibre_link-607" class="calibre9"></a><a data-primary="aliases" data-type="indexterm"
                id="calibre_link-82" class="calibre9"></a> you introduce a new name for a value:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">const</code> <code class="nx">borough</code> <code class="o">=</code> <code class="p">{</code><code class="nx">name</code><code class="o">:</code> <code class="s">'Brooklyn'</code><code class="p">,</code> <code class="nx">location</code><code class="o">:</code> <code class="p">[</code><code class="mi">40.688</code><code class="p">,</code> <code class="o">-</code><code class="mi">73.979</code><code class="p">]};</code>
<code class="kd">const</code> <code class="nx">loc</code> <code class="o">=</code> <code class="nx">borough</code><code class="p">.</code><code class="nx">location</code><code class="p">;</code></pre>

            <p class="author1">you have created an <em class="calibre3">alias</em>. Changes to properties on the alias
              will be visible on the original value as well:</p>
            <pre data-type="programlisting" class="calibre17">&gt; <strong class="calibre32">loc[0] = 0;</strong>
&gt; <strong class="calibre32">borough.location</strong>
[0, -73.979]</pre>

            <p class="author1">Aliases are the bane of compiler writers in all languages because they make control flow
              analysis difficult. If you’re deliberate in your use of aliases, TypeScript will be able to understand
              your code better and help you find more real errors.</p>

            <p class="author1">Suppose you have a data structure that represents a polygon:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Coordinate</code> <code class="p">{</code>
  <code class="nx">x</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">y</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">interface</code> <code class="nx">BoundingBox</code> <code class="p">{</code>
  <code class="nx">x</code><code class="o">:</code> <code class="p">[</code><code class="kt">number</code><code class="p">,</code> <code class="kt">number</code><code class="p">];</code>
  <code class="nx">y</code><code class="o">:</code> <code class="p">[</code><code class="kt">number</code><code class="p">,</code> <code class="kt">number</code><code class="p">];</code>
<code class="p">}</code>

<code class="kd">interface</code> <code class="nx">Polygon</code> <code class="p">{</code>
  <code class="nx">exterior</code>: <code class="nx">Coordinate</code><code class="p">[];</code>
  <code class="nx">holes</code>: <code class="nx">Coordinate</code><code class="p">[][];</code>
  <code class="nx">bbox?</code>: <code class="nx">BoundingBox</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">The geometry of the polygon is specified by the <code class="calibre18">exterior</code>
              and <code class="calibre18">holes</code> properties. The <code class="calibre18">bbox</code> property is
              an optimization that may or may not be present. You can use it to speed up a point-in-polygon check:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">isPointInPolygon</code><code class="p">(</code><code class="nx">polygon</code>: <code class="nx">Polygon</code><code class="p">,</code> <code class="nx">pt</code>: <code class="nx">Coordinate</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">polygon</code><code class="p">.</code><code class="nx">bbox</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">if</code> <code class="p">(</code><code class="nx">pt</code><code class="p">.</code><code class="nx">x</code> <code class="o">&lt;</code> <code class="nx">polygon</code><code class="p">.</code><code class="nx">bbox</code><code class="p">.</code><code class="nx">x</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="o">||</code> <code class="nx">pt</code><code class="p">.</code><code class="nx">x</code> <code class="o">&gt;</code> <code class="nx">polygon</code><code class="p">.</code><code class="nx">bbox</code><code class="p">.</code><code class="nx">x</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code> <code class="o">||</code>
        <code class="nx">pt</code><code class="p">.</code><code class="nx">y</code> <code class="o">&lt;</code> <code class="nx">polygon</code><code class="p">.</code><code class="nx">bbox</code><code class="p">.</code><code class="nx">y</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code> <code class="o">||</code> <code class="nx">pt</code><code class="p">.</code><code class="nx">y</code> <code class="o">&gt;</code> <code class="nx">polygon</code><code class="p">.</code><code class="nx">bbox</code><code class="p">.</code><code class="nx">y</code><code class="p">[</code><code class="mi">1</code><code class="p">])</code> <code class="p">{</code>
      <code class="kd">return</code> <code class="kd">false</code><code class="p">;</code>
    <code class="p">}</code>
  <code class="p">}</code>

  <code class="c">// ... more complex check</code>
<code class="p">}</code></pre>

            <p class="author1">This code works (and type checks) but is a bit repetitive: <code
                class="calibre18">polygon.bbox</code> appears five times in three lines! Here’s an attempt to factor out
              an intermediate variable to reduce duplication:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">isPointInPolygon</code><code class="p">(</code><code class="nx">polygon</code>: <code class="nx">Polygon</code><code class="p">,</code> <code class="nx">pt</code>: <code class="nx">Coordinate</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">box</code> <code class="o">=</code> <code class="nx">polygon</code><code class="p">.</code><code class="nx">bbox</code><code class="p">;</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">polygon</code><code class="p">.</code><code class="nx">bbox</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">if</code> <code class="p">(</code><code class="nx">pt</code><code class="p">.</code><code class="nx">x</code> <code class="o">&lt;</code> <code class="nx">box</code><code class="p">.</code><code class="nx">x</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="o">||</code> <code class="nx">pt</code><code class="p">.</code><code class="nx">x</code> <code class="o">&gt;</code> <code class="nx">box</code><code class="p">.</code><code class="nx">x</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code> <code class="o">||</code>
        <code class="c">//     ~~~                ~~~  Object is possibly 'undefined'</code>
        <code class="nx">pt</code><code class="p">.</code><code class="nx">y</code> <code class="o">&lt;</code> <code class="nx">box</code><code class="p">.</code><code class="nx">y</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code> <code class="o">||</code> <code class="nx">pt</code><code class="p">.</code><code class="nx">y</code> <code class="o">&gt;</code> <code class="nx">box</code><code class="p">.</code><code class="nx">y</code><code class="p">[</code><code class="mi">1</code><code class="p">])</code> <code class="p">{</code>
        <code class="c">//     ~~~                ~~~  Object is possibly 'undefined'</code>
      <code class="kd">return</code> <code class="kd">false</code><code class="p">;</code>
    <code class="p">}</code>
  <code class="p">}</code>
  <code class="c">// ...</code>
<code class="p">}</code></pre>

            <p class="author1">(I’m assuming you’ve enabled <code class="calibre18">strictNullChecks</code>.)</p>

            <p class="author1">This code still works, so why the error? By factoring out the <code
                class="calibre18">box</code> variable, you’ve created an alias for <code
                class="calibre18">polygon.bbox</code>, and this has thwarted the control flow analysis that quietly
              worked in the first example.</p>

            <p class="author1">You can inspect the types of <code class="calibre18">box</code> and <code
                class="calibre18">polygon.bbox</code> to see what’s happening:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">isPointInPolygon</code><code class="p">(</code><code class="nx">polygon</code>: <code class="nx">Polygon</code><code class="p">,</code> <code class="nx">pt</code>: <code class="nx">Coordinate</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">polygon</code><code class="p">.</code><code class="nx">bbox</code>  <code class="c">// Type is BoundingBox | undefined</code>
  <code class="kd">const</code> <code class="nx">box</code> <code class="o">=</code> <code class="nx">polygon</code><code class="p">.</code><code class="nx">bbox</code><code class="p">;</code>
  <code class="nx">box</code>  <code class="c">// Type is BoundingBox | undefined</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">polygon</code><code class="p">.</code><code class="nx">bbox</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">polygon</code><code class="p">.</code><code class="nx">bbox</code>  <code class="c">// Type is BoundingBox</code>
    <code class="nx">box</code>  <code class="c">// Type is BoundingBox | undefined</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

            <p class="author1">The property check refines the type of <code class="calibre18">polygon.bbox</code> but
              not of <code class="calibre18">box</code> and hence the errors. This leads us to the golden rule of
              aliasing: <em class="calibre3">if you introduce an alias, use it</em> <span class="calibre"><em
                  class="calibre3">consistently</em>.</span></p>

            <p class="author1">Using <code class="calibre18">box</code> in the property check fixes the error:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">isPointInPolygon</code><code class="p">(</code><code class="nx">polygon</code>: <code class="nx">Polygon</code><code class="p">,</code> <code class="nx">pt</code>: <code class="nx">Coordinate</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">box</code> <code class="o">=</code> <code class="nx">polygon</code><code class="p">.</code><code class="nx">bbox</code><code class="p">;</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">box</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">if</code> <code class="p">(</code><code class="nx">pt</code><code class="p">.</code><code class="nx">x</code> <code class="o">&lt;</code> <code class="nx">box</code><code class="p">.</code><code class="nx">x</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="o">||</code> <code class="nx">pt</code><code class="p">.</code><code class="nx">x</code> <code class="o">&gt;</code> <code class="nx">box</code><code class="p">.</code><code class="nx">x</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code> <code class="o">||</code>
        <code class="nx">pt</code><code class="p">.</code><code class="nx">y</code> <code class="o">&lt;</code> <code class="nx">box</code><code class="p">.</code><code class="nx">y</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code> <code class="o">||</code> <code class="nx">pt</code><code class="p">.</code><code class="nx">y</code> <code class="o">&gt;</code> <code class="nx">box</code><code class="p">.</code><code class="nx">y</code><code class="p">[</code><code class="mi">1</code><code class="p">])</code> <code class="p">{</code>  <code class="c">// OK</code>
      <code class="kd">return</code> <code class="kd">false</code><code class="p">;</code>
    <code class="p">}</code>
  <code class="p">}</code>
  <code class="c">// ...</code>
<code class="p">}</code></pre>

            <p class="author1">The type checker is happy now, but there’s an issue for human readers. We’re using two
              names for the same thing: <code class="calibre18">box</code> and <code class="calibre18">bbox</code>. This
              is a distinction without a difference (<a href="#calibre_link-22" class="calibre9">Item 36</a>).</p>

            <p class="author1">Object destructuring syntax rewards consistent naming with a more compact syntax. You can
              even use it on arrays and nested structures:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">isPointInPolygon</code><code class="p">(</code><code class="nx">polygon</code>: <code class="nx">Polygon</code><code class="p">,</code> <code class="nx">pt</code>: <code class="nx">Coordinate</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="p">{</code><code class="nx">bbox</code><code class="p">}</code> <code class="o">=</code> <code class="nx">polygon</code><code class="p">;</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">bbox</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">const</code> <code class="p">{</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">}</code> <code class="o">=</code> <code class="nx">bbox</code><code class="p">;</code>
    <code class="kd">if</code> <code class="p">(</code><code class="nx">pt</code><code class="p">.</code><code class="nx">x</code> <code class="o">&lt;</code> <code class="nx">x</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="o">||</code> <code class="nx">pt</code><code class="p">.</code><code class="nx">x</code> <code class="o">&gt;</code> <code class="nx">x</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code> <code class="o">||</code>
        <code class="nx">pt</code><code class="p">.</code><code class="nx">y</code> <code class="o">&lt;</code> <code class="nx">x</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="o">||</code> <code class="nx">pt</code><code class="p">.</code><code class="nx">y</code> <code class="o">&gt;</code> <code class="nx">y</code><code class="p">[</code><code class="mi">1</code><code class="p">])</code> <code class="p">{</code>
      <code class="kd">return</code> <code class="kd">false</code><code class="p">;</code>
    <code class="p">}</code>
  <code class="p">}</code>
  <code class="c">// ...</code>
<code class="p">}</code></pre>

            <p class="author1">A few other points:</p>

            <ul class="printings">
              <li class="calibre12">
                <p class="author1">This code would have required more property checks if the <code
                    class="calibre18">x</code> and <code class="calibre18">y</code> properties had been optional, rather
                  than the whole <code class="calibre18">bbox</code> property. We benefited from following the advice of
                  <a href="#calibre_link-799" class="calibre9">Item 31</a>, which discusses the importance of pushing
                  null values to the perimeter of your types.
                </p>
              </li>
              <li class="calibre12">
                <p class="author1">An optional property was appropriate for <code class="calibre18">bbox</code> but
                  would not have been appropriate for <code class="calibre18">holes</code>. If <code
                    class="calibre18">holes</code> was optional, then it would be possible for it to be either missing
                  or an empty array (<code class="calibre18">[]</code>). This would be a distinction without a
                  difference. An empty array is a fine way to indicate “no holes.”</p>
              </li>
            </ul>

            <p class="author1">In your interactions with the type checker, don’t forget that aliasing can introduce
              confusion at runtime, too:</p>

            <pre data-code-language="ts" data-type="programlisting" id="calibre_link-905" class="calibre17"><code class="kd">const</code> <code class="p">{</code><code class="nx">bbox</code><code class="p">}</code> <code class="o">=</code> <code class="nx">polygon</code><code class="p">;</code>
<code class="kd">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">bbox</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">calculatePolygonBbox</code><code class="p">(</code><code class="nx">polygon</code><code class="p">);</code>  <code class="c">// Fills in polygon.bbox</code>
  <code class="c">// Now polygon.bbox and bbox refer to different values!</code>
<code class="p">}</code></pre>

            <p class="author1">TypeScript’s control flow analysis tends to be quite good for local variables. But for
              properties you should be on guard:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">fn</code><code class="p">(</code><code class="nx">p</code>: <code class="nx">Polygon</code><code class="p">)</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">}</code>

<code class="nx">polygon</code><code class="p">.</code><code class="nx">bbox</code>  <code class="c">// Type is BoundingBox | undefined</code>
<code class="kd">if</code> <code class="p">(</code><code class="nx">polygon</code><code class="p">.</code><code class="nx">bbox</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">polygon</code><code class="p">.</code><code class="nx">bbox</code>  <code class="c">// Type is BoundingBox</code>
  <code class="nx">fn</code><code class="p">(</code><code class="nx">polygon</code><code class="p">);</code>
  <code class="nx">polygon</code><code class="p">.</code><code class="nx">bbox</code>  <code class="c">// Type is still BoundingBox</code>
<code class="p">}</code></pre>

            <p class="author1">The<a data-primary="type refinements" data-type="indexterm" id="calibre_link-627"
                class="calibre9"></a> call to <code class="calibre18">fn(polygon)</code> could very well un-set <code
                class="calibre18">polygon.bbox</code>, so it would be safer for the type to revert to <code
                class="calibre18">BoundingBox | undefined</code>. But this would get frustrating: you’d have to repeat
              your property checks every time you called a function. So TypeScript makes the pragmatic choice to assume
              the function does not invalidate its type refinements. But it <em class="calibre3">could</em>. If you’d
              factored out a local <code class="calibre18">bbox</code> variable instead of using <code
                class="calibre18">polygon.bbox</code>, the type of <code class="calibre18">bbox</code> would remain
              accurate, but it might no longer be the same value as <code class="calibre18">polygon.box</code>.</p>








            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-906">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">Aliasing can prevent TypeScript from narrowing types. If you create an alias for
                      a variable, use it consistently.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Use destructuring syntax to encourage consistent naming.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Be aware of how function calls can invalidate type refinements on properties.
                      Trust refinements on local variables more than on properties.<a data-primary=""
                        data-startref="TIalias03" data-type="indexterm" id="calibre_link-608" class="calibre9"></a><a
                        data-primary="" data-startref="alias03" data-type="indexterm" id="calibre_link-83"
                        class="calibre9"></a></p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>













        <section data-pdf-bookmark="Item 25: Use async Functions Instead of Callbacks for Asynchronous Code"
          data-type="sect1" class="praise">
          <div class="praise" id="calibre_link-23">
            <h1 class="calibre16">Item 25: Use async Functions Instead of Callbacks for Asynchronous Code</h1>

            <p class="author1">Classic<a data-primary="callbacks" data-secondary="async functions versus callbacks"
                data-type="indexterm" id="calibre_link-144" class="calibre9"></a><a data-primary="type inference"
                data-secondary="asynchronous code" data-type="indexterm" id="calibre_link-609" class="calibre9"></a><a
                data-primary="asynchronous code" data-type="indexterm" id="calibre_link-122" class="calibre9"></a><a
                data-primary="Promises" data-type="indexterm" id="calibre_link-462" class="calibre9"></a><a
                data-primary="async functions" data-type="indexterm" id="calibre_link-119" class="calibre9"></a>
              JavaScript modeled asynchronous behavior using callbacks. This leads to the infamous “pyramid of doom”:
            </p>

            <pre data-code-language="ts" data-type="programlisting" id="calibre_link-907" class="calibre17"><code class="nx">fetchURL</code><code class="p">(</code><code class="nx">url1</code><code class="p">,</code> <code class="kd">function</code><code class="p">(</code><code class="nx">response1</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">fetchURL</code><code class="p">(</code><code class="nx">url2</code><code class="p">,</code> <code class="kd">function</code><code class="p">(</code><code class="nx">response2</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">fetchURL</code><code class="p">(</code><code class="nx">url3</code><code class="p">,</code> <code class="kd">function</code><code class="p">(</code><code class="nx">response3</code><code class="p">)</code> <code class="p">{</code>
      <code class="c">// ...</code>
      <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="mi">1</code><code class="p">);</code>
    <code class="p">});</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="mi">2</code><code class="p">);</code>
  <code class="p">});</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="mi">3</code><code class="p">);</code>
<code class="p">});</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="mi">4</code><code class="p">);</code>

<code class="c">// Logs:</code>
<code class="c">// 4</code>
<code class="c">// 3</code>
<code class="c">// 2</code>
<code class="c">// 1</code></pre>

            <p class="author1">As you can see from the logs, the execution order is the opposite of the code order. This
              makes callback code hard to read. It gets even more confusing if you want to run the requests in parallel
              or bail when an error occurs.</p>

            <p class="author1">ES2015<a data-primary="ES2015" data-secondary="Promises in" data-type="indexterm"
                id="calibre_link-246" class="calibre9"></a> introduced the concept of a Promise to break the pyramid of
              doom. A Promise represents something that will be available in the future (they’re also sometimes called
              “futures”). Here’s the same code using Promises:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">page1Promise</code> <code class="o">=</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">url1</code><code class="p">);</code>
<code class="nx">page1Promise</code><code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">response1</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">url2</code><code class="p">);</code>
<code class="p">}).</code><code class="nx">then</code><code class="p">(</code><code class="nx">response2</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">url3</code><code class="p">);</code>
<code class="p">}).</code><code class="nx">then</code><code class="p">(</code><code class="nx">response3</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="c">// ...</code>
<code class="p">}).</code><code class="kd">catch</code><code class="p">(</code><code class="nx">error</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="c">// ...</code>
<code class="p">});</code></pre>

            <p class="author1">Now there’s less nesting, and the execution order more directly matches the code order.
              It’s also easier to consolidate error handling and use higher-order tools like <code
                class="calibre18">Promise.all</code>.</p>

            <p class="author1">ES2017<a data-primary="ES2017" data-type="indexterm" id="calibre_link-249"
                class="calibre9"></a><a data-primary="await keyword" data-type="indexterm" id="calibre_link-126"
                class="calibre9"></a> introduced the <code class="calibre18">async</code> and <code
                class="calibre18">await</code> keywords to make things even simpler:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">async</code> <code class="kd">function</code> <code class="nx">fetchPages() {</code>
  <code class="kd">const</code> <code class="nx">response1</code> <code class="o">=</code> <code class="kd">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">url1</code><code class="p">);</code>
  <code class="kd">const</code> <code class="nx">response2</code> <code class="o">=</code> <code class="kd">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">url2</code><code class="p">);</code>
  <code class="kd">const</code> <code class="nx">response3</code> <code class="o">=</code> <code class="kd">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">url3</code><code class="p">);</code>
  <code class="c">// ...</code>
<code class="p">}</code></pre>

            <p class="author1">The <code class="calibre18">await</code> keyword pauses execution of the <code
                class="calibre18">fetchPages</code> function until each Promise resolves. Within an <code
                class="calibre18">async</code> function, <code class="calibre18">await</code>ing a Promise that throws
              an exception. This lets you use the usual try/catch machinery:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">async</code> <code class="kd">function</code> <code class="nx">fetchPages() {</code>
  <code class="kd">try</code> <code class="p">{</code>
    <code class="kd">const</code> <code class="nx">response1</code> <code class="o">=</code> <code class="kd">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">url1</code><code class="p">);</code>
    <code class="kd">const</code> <code class="nx">response2</code> <code class="o">=</code> <code class="kd">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">url2</code><code class="p">);</code>
    <code class="kd">const</code> <code class="nx">response3</code> <code class="o">=</code> <code class="kd">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">url3</code><code class="p">);</code>
    <code class="c">// ...</code>
  <code class="p">}</code> <code class="kd">catch</code> <code class="p">(</code><code class="nx">e</code><code class="p">)</code> <code class="p">{</code>
    <code class="c">// ...</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

            <p class="author1">When<a data-primary="ES5" data-secondary="async and await in" data-type="indexterm"
                id="calibre_link-251" class="calibre9"></a> you target ES5 or earlier, the TypeScript compiler will
              perform some elaborate transformations to make <code class="calibre18">async</code> and <code
                class="calibre18">await</code> work. In other words, whatever your runtime, with TypeScript you can use
              <code class="calibre18">async</code>/<code class="calibre18">await</code>.
            </p>

            <p class="author1">There are a few good reasons to prefer Promises or <code
                class="calibre18">async</code>/<code class="calibre18">await</code> to callbacks:</p>

            <ul class="printings">
              <li class="calibre12">
                <p class="author1">Promises are easier to compose than callbacks.</p>
              </li>
              <li class="calibre12">
                <p class="author1">Types are able to flow through Promises more easily than callbacks.</p>
              </li>
            </ul>

            <p class="author1">If you want to fetch the pages in parallel, for example, you can compose Promises with
              <code class="calibre18">Promise.all</code>:
            </p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">async</code> <code class="kd">function</code> <code class="nx">fetchPages() {</code>
  <code class="kd">const</code> <code class="p">[</code><code class="nx">response1</code><code class="p">,</code> <code class="nx">response2</code><code class="p">,</code> <code class="nx">response3</code><code class="p">]</code> <code class="o">=</code> <code class="kd">await</code> <code class="nx">Promise</code><code class="p">.</code><code class="nx">all</code><code class="p">([</code>
    <code class="nx">fetch</code><code class="p">(</code><code class="nx">url1</code><code class="p">),</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">url2</code><code class="p">),</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">url3</code><code class="p">)</code>
  <code class="p">]);</code>
  <code class="c">// ...</code>
<code class="p">}</code></pre>

            <p class="author1">Using destructuring assignment with <code class="calibre18">await</code> is particularly
              nice in this context.</p>

            <p class="author1">TypeScript is able to infer the types of each of the three <code
                class="calibre18">response</code> variables as <code class="calibre18">Response</code>. The equivalent
              code to do the requests in parallel with callbacks requires more machinery and a type annotation:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">fetchPagesCB() {</code>
  <code class="kd">let</code> <code class="nx">numDone</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
  <code class="kd">const</code> <code class="nx">responses</code>: <code class="kd">string</code><code class="p">[]</code> <code class="o">=</code> <code class="p">[];</code>
  <code class="kd">const</code> <code class="nx">done</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="kd">const</code> <code class="p">[</code><code class="nx">response1</code><code class="p">,</code> <code class="nx">response2</code><code class="p">,</code> <code class="nx">response3</code><code class="p">]</code> <code class="o">=</code> <code class="nx">responses</code><code class="p">;</code>
    <code class="c">// ...</code>
  <code class="p">};</code>
  <code class="kd">const</code> <code class="nx">urls</code> <code class="o">=</code> <code class="p">[</code><code class="nx">url1</code><code class="p">,</code> <code class="nx">url2</code><code class="p">,</code> <code class="nx">url3</code><code class="p">];</code>
  <code class="nx">urls</code><code class="p">.</code><code class="nx">forEach</code><code class="p">((</code><code class="nx">url</code><code class="p">,</code> <code class="nx">i</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="nx">fetchURL</code><code class="p">(</code><code class="nx">url</code><code class="p">,</code> <code class="nx">r</code> <code class="o">=&gt;</code> <code class="p">{</code>
      <code class="nx">responses</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code> <code class="o">=</code> <code class="nx">url</code><code class="p">;</code>
      <code class="nx">numDone</code><code class="o">++</code><code class="p">;</code>
      <code class="kd">if</code> <code class="p">(</code><code class="nx">numDone</code> <code class="o">===</code> <code class="nx">urls</code><code class="p">.</code><code class="nx">length</code><code class="p">)</code> <code class="nx">done</code><code class="p">();</code>
    <code class="p">});</code>
  <code class="p">});</code>
<code class="p">}</code></pre>

            <p class="author1">Extending this to include error handling or to be as generic as <code
                class="calibre18">Promise.all</code> is <span class="calibre">challenging.</span></p>

            <p class="author1">Type inference also works well with <code class="calibre18">Promise.race</code>, which
              resolves when the first of its input Promises resolves. You can use this to add timeouts to Promises in a
              general way:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">timeout</code><code class="p">(</code><code class="nx">millis</code>: <code class="nx">number</code><code class="p">)</code><code class="o">:</code> <code class="nx">Promise</code><code class="o">&lt;</code><code class="nx">never</code><code class="o">&gt;</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="kd">new</code> <code class="nx">Promise</code><code class="p">((</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
     <code class="nx">setTimeout</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">reject</code><code class="p">(</code><code class="s">'timeout'</code><code class="p">),</code> <code class="nx">millis</code><code class="p">);</code>
  <code class="p">});</code>
<code class="p">}</code>

<code class="kd">async</code> <code class="kd">function</code> <code class="nx">fetchWithTimeout</code><code class="p">(</code><code class="nx">url</code>: <code class="kd">string</code><code class="p">,</code> <code class="nx">ms</code>: <code class="nx">number</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">Promise</code><code class="p">.</code><code class="nx">race</code><code class="p">([</code><code class="nx">fetch</code><code class="p">(</code><code class="nx">url</code><code class="p">),</code> <code class="nx">timeout</code><code class="p">(</code><code class="nx">ms</code><code class="p">)]);</code>
<code class="p">}</code></pre>

            <p class="author1">The return type of <code class="calibre18">fetchWithTimeout</code> is inferred as <code
                class="calibre18">Promise&lt;Response&gt;</code>, no type annotations required. It’s interesting to dig
              into why this works: the return type of <code class="calibre18">Promise.race</code> is the union of the
              types of its inputs, in this case <code class="calibre18">Promise&lt;Response | never&gt;</code>. But
              taking a union with <code class="calibre18">never</code> (the empty set) is a no-op, so this gets
              simplified to <code class="calibre18">Promise&lt;Response&gt;</code>. When you work with Promises, all of
              TypeScript’s type inference machinery works to get you the right types.</p>

            <p class="author1">There are some times when you need to use raw Promises, notably when you are wrapping a
              callback API like <code class="calibre18">setTimeout</code>. But if you have a choice, you should
              generally prefer <code class="calibre18">async</code>/<code class="calibre18">await</code> to raw Promises
              for two reasons:</p>

            <ul class="printings">
              <li class="calibre12">
                <p class="author1">It typically produces more concise and straightforward code.</p>
              </li>
              <li class="calibre12">
                <p class="author1">It enforces that <code class="calibre18">async</code> functions always return
                  Promises.</p>
              </li>
            </ul>

            <p class="author1">An <code class="calibre18">async</code> function always returns a <code
                class="calibre18">Promise</code>, even if it doesn’t involve <code class="calibre18">await</code>ing
              anything. TypeScript can help you build an intuition for this:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="c">// function getNumber(): Promise&lt;number&gt;</code>
<code class="kd">async</code> <code class="kd">function</code> <code class="nx">getNumber() {</code>
  <code class="kd">return</code> <code class="mi">42</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">You<a data-primary="async arrow functions" data-type="indexterm" id="calibre_link-118"
                class="calibre9"></a> can also create <code class="calibre18">async</code> arrow functions:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">const</code> <code class="nx">getNumber</code> <code class="o">=</code> <code class="kd">async</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="mi">42</code><code class="p">;</code>  <code class="c">// Type is () =&gt; Promise&lt;number&gt;</code></pre>

            <p class="author1">The raw Promise equivalent is:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">const</code> <code class="nx">getNumber</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">Promise</code><code class="p">.</code><code class="nx">resolve</code><code class="p">(</code><code class="mi">42</code><code class="p">);</code>  <code class="c">// Type is () =&gt; Promise&lt;number&gt;</code></pre>

            <p class="author1">While it may seem odd to return a Promise for an immediately available value, this
              actually helps enforce an important rule: a function should either always be run synchronously or always
              be run asynchronously. It should never mix the two. For example, what if you want to add a cache to the
              <code class="calibre18">fetchURL</code> function? Here’s an attempt:
            </p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="c">// Don't do this!</code>
<code class="kd">const</code> <code class="nx">_cache</code><code class="o">:</code> <code class="p">{[</code><code class="nx">url</code>: <code class="kd">string</code><code class="p">]</code><code class="o">:</code> <code class="kt">string</code><code class="p">}</code> <code class="o">=</code> <code class="p">{};</code>
<code class="kd">function</code> <code class="nx">fetchWithCache</code><code class="p">(</code><code class="nx">url</code>: <code class="kd">string</code><code class="p">,</code> <code class="nx">callback</code><code class="o">:</code> <code class="p">(</code><code class="nx">text</code>: <code class="kd">string</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kd">void</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">url</code> <code class="kd">in</code> <code class="nx">_cache</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">callback</code><code class="p">(</code><code class="nx">_cache</code><code class="p">[</code><code class="nx">url</code><code class="p">]);</code>
  <code class="p">}</code> <code class="kd">else</code> <code class="p">{</code>
    <code class="nx">fetchURL</code><code class="p">(</code><code class="nx">url</code><code class="p">,</code> <code class="nx">text</code> <code class="o">=&gt;</code> <code class="p">{</code>
      <code class="nx">_cache</code><code class="p">[</code><code class="nx">url</code><code class="p">]</code> <code class="o">=</code> <code class="nx">text</code><code class="p">;</code>
      <code class="nx">callback</code><code class="p">(</code><code class="nx">text</code><code class="p">);</code>
    <code class="p">});</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

            <p class="author1">While this may seem like an optimization, the function is now extremely difficult for a
              client to use:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">let</code> <code class="nx">requestStatus</code><code class="o">:</code> <code class="s">'loading'</code> <code class="o">|</code> <code class="s">'success'</code> <code class="o">|</code> <code class="s">'error'</code><code class="p">;</code>
<code class="kd">function</code> <code class="nx">getUser</code><code class="p">(</code><code class="nx">userId</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">fetchWithCache</code><code class="p">(</code><code class="s">`/user/</code><code class="si">${</code><code class="nx">userId</code><code class="si">}</code><code class="s">`</code><code class="p">,</code> <code class="nx">profile</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="nx">requestStatus</code> <code class="o">=</code> <code class="s">'success'</code><code class="p">;</code>
  <code class="p">});</code>
  <code class="nx">requestStatus</code> <code class="o">=</code> <code class="s">'loading'</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">What will the value of <code class="calibre18">requestStatus</code> be after calling
              <code class="calibre18">getUser</code>? It depends entirely on whether the profile is cached. If it’s not,
              <code class="calibre18">requestStatus</code> will be set to “success.” If it is, it’ll get set to
              “success” and then set back to “loading.” Oops!
            </p>

            <p class="author1">Using <code class="calibre18">async</code> for both functions enforces consistent
              behavior:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">_cache</code><code class="o">:</code> <code class="p">{[</code><code class="nx">url</code>: <code class="kd">string</code><code class="p">]</code><code class="o">:</code> <code class="kt">string</code><code class="p">}</code> <code class="o">=</code> <code class="p">{};</code>
<code class="kd">async</code> <code class="kd">function</code> <code class="nx">fetchWithCache</code><code class="p">(</code><code class="nx">url</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">url</code> <code class="kd">in</code> <code class="nx">_cache</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">return</code> <code class="nx">_cache</code><code class="p">[</code><code class="nx">url</code><code class="p">];</code>
  <code class="p">}</code>
  <code class="kd">const</code> <code class="nx">response</code> <code class="o">=</code> <code class="kd">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">url</code><code class="p">);</code>
  <code class="kd">const</code> <code class="nx">text</code> <code class="o">=</code> <code class="kd">await</code> <code class="nx">response</code><code class="p">.</code><code class="nx">text</code><code class="p">();</code>
  <code class="nx">_cache</code><code class="p">[</code><code class="nx">url</code><code class="p">]</code> <code class="o">=</code> <code class="nx">text</code><code class="p">;</code>
  <code class="kd">return</code> <code class="nx">text</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">let</code> <code class="nx">requestStatus</code><code class="o">:</code> <code class="s">'loading'</code> <code class="o">|</code> <code class="s">'success'</code> <code class="o">|</code> <code class="s">'error'</code><code class="p">;</code>
<code class="kd">async</code> <code class="kd">function</code> <code class="nx">getUser</code><code class="p">(</code><code class="nx">userId</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">requestStatus</code> <code class="o">=</code> <code class="s">'loading'</code><code class="p">;</code>
  <code class="kd">const</code> <code class="nx">profile</code> <code class="o">=</code> <code class="kd">await</code> <code class="nx">fetchWithCache</code><code class="p">(</code><code class="s">`/user/</code><code class="si">${</code><code class="nx">userId</code><code class="si">}</code><code class="s">`</code><code class="p">);</code>
  <code class="nx">requestStatus</code> <code class="o">=</code> <code class="s">'success'</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">Now it’s completely transparent that <code class="calibre18">requestStatus</code> will
              end in “success.” It’s easy to accidentally produce half-synchronous code with callbacks or raw Promises,
              but difficult with <code class="calibre18">async</code>.</p>

            <p class="author1">Note that if you return a Promise from an <code class="calibre18">async</code> function,
              it will not get wrapped in another Promise: the return type will be <code
                class="calibre18">Promise&lt;T&gt;</code> rather than <code
                class="calibre18">Promise&lt;Promise&lt;T&gt;&gt;</code>. Again, TypeScript will help you build an
              intuition for this:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="c">// Function getJSON(url: string): Promise&lt;any&gt;</code>
<code class="kd">async</code> <code class="kd">function</code> <code class="nx">getJSON</code><code class="p">(</code><code class="nx">url</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">response</code> <code class="o">=</code> <code class="kd">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">url</code><code class="p">);</code>
  <code class="kd">const</code> <code class="nx">jsonPromise</code> <code class="o">=</code> <code class="nx">response</code><code class="p">.</code><code class="nx">json</code><code class="p">();</code>  <code class="c">// Type is Promise&lt;any&gt;</code>
  <code class="kd">return</code> <code class="nx">jsonPromise</code><code class="p">;</code>
<code class="p">}</code></pre>








            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-908">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">Prefer Promises to callbacks for better composability and type flow.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Prefer <code class="calibre18">async</code> and <code
                        class="calibre18">await</code> to raw Promises when possible. They produce more concise,
                      straightforward code and eliminate whole classes of errors.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">If a function returns a Promise, declare it <code
                        class="calibre18">async</code>.<a data-primary="" data-startref="TIasyn03" data-type="indexterm"
                        id="calibre_link-610" class="calibre9"></a><a data-primary="" data-startref="async03"
                        data-type="indexterm" id="calibre_link-123" class="calibre9"></a><a data-primary=""
                        data-startref="prom03" data-type="indexterm" id="calibre_link-463" class="calibre9"></a><a
                        data-primary="" data-startref="afunc03" data-type="indexterm" id="calibre_link-120"
                        class="calibre9"></a><a data-primary="" data-startref="await03" data-type="indexterm"
                        id="calibre_link-127" class="calibre9"></a><a data-primary="" data-startref="callback03"
                        data-type="indexterm" id="calibre_link-145" class="calibre9"></a></p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>













        <section data-pdf-bookmark="Item 26: Understand How Context Is Used in Type Inference" data-type="sect1"
          class="praise">
          <div class="praise" id="calibre_link-760">
            <h1 class="calibre16">Item 26: Understand How Context Is Used in Type Inference</h1>

            <p class="author1">TypeScript<a data-primary="type inference" data-secondary="context in"
                data-type="indexterm" id="calibre_link-615" class="calibre9"></a><a data-primary="context"
                data-type="indexterm" id="calibre_link-193" class="calibre9"></a> doesn’t just infer types based on
              values. It also considers the context in which the value occurs. This usually works well but can sometimes
              lead to surprises. Understanding how context is used in type inference will help you identify and work
              around these surprises when they do occur.</p>

            <p class="author1">In JavaScript you can factor an expression out into a constant without changing the
              behavior of your code (so long as you don’t alter execution order). In other words, these two statements
              are equivalent:</p>

            <pre data-code-language="js" data-type="programlisting"
              class="calibre17"><code class="c">// Inline form</code>
<code class="nx">setLanguage</code><code class="p">(</code><code class="s">'JavaScript'</code><code class="p">);</code>

<code class="c">// Reference form</code>
<code class="kd">let</code> <code class="nx">language</code> <code class="o">=</code> <code class="s">'JavaScript'</code><code class="p">;</code>
<code class="nx">setLanguage</code><code class="p">(</code><code class="nx">language</code><code class="p">);</code></pre>

            <p class="author1">In TypeScript, this refactor still works:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">function</code> <code class="nx">setLanguage</code><code class="p">(</code><code class="nx">language</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">}</code>

<code class="nx">setLanguage</code><code class="p">(</code><code class="s">'JavaScript'</code><code class="p">);</code>  <code class="c">// OK</code>

<code class="kd">let</code> <code class="nx">language</code> <code class="o">=</code> <code class="s">'JavaScript'</code><code class="p">;</code>
<code class="nx">setLanguage</code><code class="p">(</code><code class="nx">language</code><code class="p">);</code>  <code class="c">// OK</code></pre>

            <p class="author1">Now suppose you take to heart the advice of <a href="#calibre_link-812"
                class="calibre9">Item 33</a> and replace the string type with a more precise union of string literal
              types:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">Language</code> <code class="o">=</code> <code class="s">'JavaScript'</code> <code class="o">|</code> <code class="s">'TypeScript'</code> <code class="o">|</code> <code class="s">'Python'</code><code class="p">;</code>
<code class="kd">function</code> <code class="nx">setLanguage</code><code class="p">(</code><code class="nx">language</code>: <code class="nx">Language</code><code class="p">)</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">}</code>

<code class="nx">setLanguage</code><code class="p">(</code><code class="s">'JavaScript'</code><code class="p">);</code>  <code class="c">// OK</code>

<code class="kd">let</code> <code class="nx">language</code> <code class="o">=</code> <code class="s">'JavaScript'</code><code class="p">;</code>
<code class="nx">setLanguage</code><code class="p">(</code><code class="nx">language</code><code class="p">);</code>
         <code class="c">// ~~~~~~~~ Argument of type 'string' is not assignable</code>
         <code class="c">//          to parameter of type 'Language'</code></pre>

            <p class="author1">What went wrong? With the inline form, TypeScript knows from the function declaration
              that the parameter is supposed to be of type <code class="calibre18">Language</code>. The string literal
              <code class="calibre18">'JavaScript'</code> is assignable to this type, so this is OK. But when you factor
              out a variable, TypeScript must infer its type at the time of assignment. In this case it infers <code
                class="calibre18">string</code>, which is not assignable to <code class="calibre18">Language</code>.
              Hence the error.
            </p>

            <p class="author1">(Some languages are able to infer types for variables based on their eventual usage. But
              this can also be confusing. Anders Hejlsberg,<a data-primary="Hejlsberg, Anders" data-type="indexterm"
                id="calibre_link-304" class="calibre9"></a> the creator of TypeScript, refers to it as “spooky action at
              a distance.” By and large, TypeScript determines the type of a variable when it is first introduced. For a
              notable exception to this rule, see <a href="#calibre_link-763" class="calibre9">Item 41</a>.)</p>

            <p class="author1">There are two good ways to solve this problem. One is to constrain the possible values of
              <code class="calibre18">language</code> with a type declaration:
            </p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">let</code> <code class="nx">language</code>: <code class="nx">Language</code> <code class="o">=</code> <code class="s">'JavaScript'</code><code class="p">;</code>
<code class="nx">setLanguage</code><code class="p">(</code><code class="nx">language</code><code class="p">);</code>  <code class="c">// OK</code></pre>

            <p class="author1">This also has the benefit of flagging an error if there’s a typo in the
              language&mdash;for example <code class="calibre18">'Typescript'</code> (it should be a capital “S”).</p>

            <p class="author1">The other solution is to make the variable constant:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">const</code> <code class="nx">language</code> <code class="o">=</code> <code class="s">'JavaScript'</code><code class="p">;</code>
<code class="nx">setLanguage</code><code class="p">(</code><code class="nx">language</code><code class="p">);</code>  <code class="c">// OK</code></pre>

            <p class="author1">By using <code class="calibre18">const</code>, we’ve told the type checker that this
              variable cannot change. So TypeScript can infer a more precise type for <code
                class="calibre18">language</code>, the string literal type <code class="calibre18">"JavaScript"</code>.
              This is assignable to <code class="calibre18">Language</code> so the code type checks. Of course, if you
              do need to reassign <code class="calibre18">language</code>, then you’ll need to use the type declaration.
              (For more on this, see <a href="#calibre_link-786" class="calibre9">Item 21</a>.)</p>

            <p class="author1">The fundamental issue here is that we’ve separated the value from the context in which
              it’s used. Sometimes this is OK, but often it is not. The rest of this item walks through a few cases
              where this loss of context can cause errors and shows you how to fix them.</p>








            <section class="praise" data-pdf-bookmark="Tuple Types" data-type="sect2">
              <div class="praise" id="calibre_link-909">
                <h2 class="calibre31">Tuple Types</h2>

                <p class="author1">In<a data-primary="tuple type" data-type="indexterm" id="calibre_link-552"
                    class="calibre9"></a> addition to string literal types, problems can come up with tuple types.
                  Suppose you’re working with a map visualization that lets you programmatically pan the map:</p>

                <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="c">// Parameter is a (latitude, longitude) pair.</code>
<code class="kd">function</code> <code class="nx">panTo</code><code class="p">(</code><code class="nx">where</code><code class="o">:</code> <code class="p">[</code><code class="kt">number</code><code class="p">,</code> <code class="kt">number</code><code class="p">])</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">}</code>

<code class="nx">panTo</code><code class="p">([</code><code class="mi">10</code><code class="p">,</code> <code class="mi">20</code><code class="p">]);</code>  <code class="c">// OK</code>

<code class="kd">const</code> <code class="nx">loc</code> <code class="o">=</code> <code class="p">[</code><code class="mi">10</code><code class="p">,</code> <code class="mi">20</code><code class="p">];</code>
<code class="nx">panTo</code><code class="p">(</code><code class="nx">loc</code><code class="p">);</code>
<code class="c">//    ~~~ Argument of type 'number[]' is not assignable to</code>
<code class="c">//        parameter of type '[number, number]'</code></pre>

                <p class="author1">As before, you’ve separated a value from its context. In the first instance <code
                    class="calibre18">[10, 20]</code> is assignable to the tuple type <code
                    class="calibre18">[number, number]</code>. In the second, TypeScript infers the type of <code
                    class="calibre18">loc</code> as <code class="calibre18">number[]</code> (i.e., an array of numbers
                  of unknown length). This is not assignable to the tuple type, since many arrays have the wrong number
                  of elements.</p>

                <p class="author1">So<a data-primary="const" data-secondary="type declarations and"
                    data-type="indexterm" id="calibre_link-189" class="calibre9"></a> how can you fix this error without
                  resorting to <code class="calibre18">any</code>? You’ve already declared it <code
                    class="calibre18">const</code>, so that won’t help. But you can still provide a type declaration to
                  let TypeScript know precisely what you mean:</p>

                <pre data-code-language="ts" data-type="programlisting"
                  class="calibre17"><code class="kd">const</code> <code class="nx">loc</code><code class="o">:</code> <code class="p">[</code><code class="kt">number</code><code class="p">,</code> <code class="kt">number</code><code class="p">]</code> <code class="o">=</code> <code class="p">[</code><code class="mi">10</code><code class="p">,</code> <code class="mi">20</code><code class="p">];</code>
<code class="nx">panTo</code><code class="p">(</code><code class="nx">loc</code><code class="p">);</code>  <code class="c">// OK</code></pre>

                <p class="author1">Another way is to provide a “const context.” This tells TypeScript that you intend
                  the value to be deeply constant, rather than the shallow constant that <code
                    class="calibre18">const</code> gives:</p>

                <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">loc</code> <code class="o">=</code> <code class="p">[</code><code class="mi">10</code><code class="p">,</code> <code class="mi">20</code><code class="p">]</code> <code class="kd">as</code> <code class="kd">const</code><code class="p">;</code>
<code class="nx">panTo</code><code class="p">(</code><code class="nx">loc</code><code class="p">);</code>
   <code class="c">// ~~~ Type 'readonly [10, 20]' is 'readonly'</code>
   <code class="c">//     and cannot be assigned to the mutable type '[number, number]'</code></pre>

                <p class="author1">If you hover over <code class="calibre18">loc</code> in your editor, you’ll see that
                  its type is now inferred as <code class="calibre18">readonly [10, 20]</code>, rather than <code
                    class="calibre18">number[]</code>. Unfortunately this is <em class="calibre3">too</em> precise! The
                  type signature of <code class="calibre18">panTo</code> makes no promises that it won’t modify the
                  contents of its <code class="calibre18">where</code> parameter. Since the <code
                    class="calibre18">loc</code> parameter has a <code class="calibre18">readonly</code> type, this
                  won’t do. The best solution here is to add a <code class="calibre18">readonly</code> annotation to the
                  <code class="calibre18">panTo</code> function:
                </p>

                <pre data-code-language="ts" data-type="programlisting"
                  class="calibre17"><code class="kd">function</code> <code class="nx">panTo</code><code class="p">(</code><code class="nx">where</code>: <code class="nx">readonly</code> <code class="p">[</code><code class="kt">number</code><code class="p">,</code> <code class="kt">number</code><code class="p">])</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">}</code>
<code class="kd">const</code> <code class="nx">loc</code> <code class="o">=</code> <code class="p">[</code><code class="mi">10</code><code class="p">,</code> <code class="mi">20</code><code class="p">]</code> <code class="kd">as</code> <code class="kd">const</code><code class="p">;</code>
<code class="nx">panTo</code><code class="p">(</code><code class="nx">loc</code><code class="p">);</code>  <code class="c">// OK</code></pre>

                <p class="author1">If the type signature is outside your control, then you’ll need to use an annotation.
                </p>

                <p class="author1"><code class="calibre18">const</code> contexts can neatly solve issues around losing
                  context in inference, but they do have an unfortunate downside: if you make a mistake in the
                  definition (say you add a third element to the tuple) then the error will be flagged at the call site,
                  not at the definition. This may be confusing, especially if the error occurs in a deeply nested
                  object:</p>

                <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">loc</code> <code class="o">=</code> <code class="p">[</code><code class="mi">10</code><code class="p">,</code> <code class="mi">20</code><code class="p">,</code> <code class="mi">30</code><code class="p">]</code> <code class="kd">as</code> <code class="kd">const</code><code class="p">;</code>  <code class="c">// error is really here.</code>
<code class="nx">panTo</code><code class="p">(</code><code class="nx">loc</code><code class="p">);</code>
<code class="c">//    ~~~ Argument of type 'readonly [10, 20, 30]' is not assignable to</code>
<code class="c">//        parameter of type 'readonly [number, number]'</code>
<code class="c">//          Types of property 'length' are incompatible</code>
<code class="c">//            Type '3' is not assignable to type '2'</code></pre>
              </div>
            </section>













            <section class="praise" data-pdf-bookmark="Objects" data-type="sect2">
              <div class="praise" id="calibre_link-910">
                <h2 class="calibre31">Objects</h2>

                <p class="author1">The<a data-primary="objects" data-secondary="type inference and"
                    data-type="indexterm" id="calibre_link-451" class="calibre9"></a> problem of separating a value from
                  its context also comes up when you factor out a constant from a larger object that contains some
                  string literals or tuples. For example:</p>

                <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">Language</code> <code class="o">=</code> <code class="s">'JavaScript'</code> <code class="o">|</code> <code class="s">'TypeScript'</code> <code class="o">|</code> <code class="s">'Python'</code><code class="p">;</code>
<code class="kd">interface</code> <code class="nx">GovernedLanguage</code> <code class="p">{</code>
  <code class="nx">language</code>: <code class="nx">Language</code><code class="p">;</code>
  <code class="nx">organization</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="nx">complain</code><code class="p">(</code><code class="nx">language</code>: <code class="nx">GovernedLanguage</code><code class="p">)</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">}</code>

<code class="nx">complain</code><code class="p">({</code> <code class="nx">language</code><code class="o">:</code> <code class="s">'TypeScript'</code><code class="p">,</code> <code class="nx">organization</code><code class="o">:</code> <code class="s">'Microsoft'</code> <code class="p">});</code>  <code class="c">// OK</code>

<code class="kd">const</code> <code class="nx">ts</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">language</code><code class="o">:</code> <code class="s">'TypeScript'</code><code class="p">,</code>
  <code class="nx">organization</code><code class="o">:</code> <code class="s">'Microsoft'</code><code class="p">,</code>
<code class="p">};</code>
<code class="nx">complain</code><code class="p">(</code><code class="nx">ts</code><code class="p">);</code>
<code class="c">//       ~~ Argument of type '{ language: string; organization: string; }'</code>
<code class="c">//            is not assignable to parameter of type 'GovernedLanguage'</code>
<code class="c">//          Types of property 'language' are incompatible</code>
<code class="c">//            Type 'string' is not assignable to type 'Language'</code></pre>

                <p class="author1">In<a data-primary="as const" data-type="indexterm" id="calibre_link-113"
                    class="calibre9"></a><a data-primary="const assertion" data-type="indexterm" id="calibre_link-191"
                    class="calibre9"></a> the <code class="calibre18">ts</code> object, the type of <code
                    class="calibre18">language</code> is inferred as <code class="calibre18">string</code>. As before,
                  the solution is to add a type declaration (<code
                    class="calibre18">const ts: GovernedLanguage = ...</code>) or use a const assertion (<code
                    class="calibre18">as const</code>).</p>
              </div>
            </section>













            <section class="praise" data-pdf-bookmark="Callbacks" data-type="sect2">
              <div class="praise" id="calibre_link-911">
                <h2 class="calibre31">Callbacks</h2>

                <p class="author1">When<a data-primary="callbacks" data-secondary="type inference and"
                    data-type="indexterm" id="calibre_link-151" class="calibre9"></a> you pass a callback to another
                  function, TypeScript uses context to infer the parameter types of the callback:</p>

                <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">callWithRandomNumbers</code><code class="p">(</code><code class="nx">fn</code><code class="o">:</code> <code class="p">(</code><code class="nx">n1</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">n2</code>: <code class="nx">number</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kd">void</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">fn</code><code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">(),</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">());</code>
<code class="p">}</code>

<code class="nx">callWithRandomNumbers</code><code class="p">((</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="nx">a</code><code class="p">;</code>  <code class="c">// Type is number</code>
  <code class="nx">b</code><code class="p">;</code>  <code class="c">// Type is number</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code><code class="p">);</code>
<code class="p">});</code></pre>

                <p class="author1">The types of <code class="calibre18">a</code> and <code class="calibre18">b</code>
                  are inferred as <code class="calibre18">number</code> because of the type declaration for <code
                    class="calibre18">callWithRandom</code>. If you factor the callback out into a constant, you lose
                  that context and get <code class="calibre18">noImplicitAny</code> errors:</p>

                <pre data-code-language="ts" data-type="programlisting"
                  class="calibre17"><code class="kd">const</code> <code class="nx">fn</code> <code class="o">=</code> <code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
         <code class="c">// ~    Parameter 'a' implicitly has an 'any' type</code>
         <code class="c">//    ~ Parameter 'b' implicitly has an 'any' type</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code><code class="p">);</code>
<code class="p">}</code>
<code class="nx">callWithRandomNumbers</code><code class="p">(</code><code class="nx">fn</code><code class="p">);</code></pre>

                <p class="author1">The solution is either to add type annotations to the parameters:</p>

                <pre data-code-language="ts" data-type="programlisting"
                  class="calibre17"><code class="kd">const</code> <code class="nx">fn</code> <code class="o">=</code> <code class="p">(</code><code class="nx">a</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">b</code>: <code class="nx">number</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code><code class="p">);</code>
<code class="p">}</code>
<code class="nx">callWithRandomNumbers</code><code class="p">(</code><code class="nx">fn</code><code class="p">);</code></pre>

                <p class="author1">or to apply a type declaration to the entire function expression if one is available.
                  See <a href="#calibre_link-797" class="calibre9">Item 12</a>.</p>
              </div>
            </section>













            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-912">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">Be aware of how context is used in type inference.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">If factoring out a variable introduces a type error, consider adding a type
                      declaration.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">If the variable is truly a constant, use a const assertion (<code
                        class="calibre18">as const</code>). But be aware that this may result in errors surfacing at
                      use, rather than definition.<a data-primary="" data-startref="TIcontext03" data-type="indexterm"
                        id="calibre_link-616" class="calibre9"></a><a data-primary="" data-startref="cont03"
                        data-type="indexterm" id="calibre_link-194" class="calibre9"></a></p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>













        <section data-pdf-bookmark="Item 27: Use Functional Constructs and Libraries to Help Types Flow"
          data-type="sect1" class="praise">
          <div class="praise" id="calibre_link-44">
            <h1 class="calibre16">Item 27: Use Functional Constructs and Libraries to Help Types Flow</h1>

            <p class="author1">JavaScript<a data-primary="type inference"
                data-secondary="functional constructs and libraries" data-type="indexterm" id="calibre_link-617"
                class="calibre9"></a><a data-primary="functions" data-secondary="utility libraries versus hand-rolled"
                data-type="indexterm" id="calibre_link-289" class="calibre9"></a><a data-primary="libraries"
                data-secondary="using utility libraries" data-type="indexterm" id="calibre_link-383"
                class="calibre9"></a><a data-primary="type annotations" data-secondary="reducing need for"
                data-type="indexterm" id="calibre_link-558" class="calibre9"></a><a data-primary="Lodash library"
                data-type="indexterm" id="calibre_link-385" class="calibre9"></a> has never included the sort of
              standard library you find in Python, C, or<a data-primary="Java" data-secondary="standard libraries in"
                data-type="indexterm" id="calibre_link-337" class="calibre9"></a> Java. Over the years many libraries
              have tried to fill the gap. jQuery<a data-primary="jQuery" data-secondary="interacting with DOM"
                data-type="indexterm" id="calibre_link-362" class="calibre9"></a> provided helpers not just for
              interacting with the DOM but also for iterating and mapping over objects and arrays. Underscore<a
                data-primary="Underscore library" data-type="indexterm" id="calibre_link-705" class="calibre9"></a>
              focused more on providing general utility functions, and Lodash built on this effort. Today<a
                data-primary="Ramda library" data-type="indexterm" id="calibre_link-479" class="calibre9"></a> libraries
              like Ramda continue to bring ideas from functional programming into the JavaScript world.</p>

            <p class="author1">Some<a data-primary="flatMap" data-type="indexterm" id="calibre_link-268"
                class="calibre9"></a> features from these libraries, such as <code class="calibre18">map</code>, <code
                class="calibre18">flatMap</code>, <code class="calibre18">filter</code>, and <code
                class="calibre18">reduce</code>, have made it into the JavaScript language itself. While these
              constructs (and the other ones provided by Lodash) are helpful in JavaScript and often preferable to a
              hand-rolled loop, this advantage tends to get even more lopsided when you add TypeScript to the mix. This
              is because their type declarations ensure that types flow through these constructs. With hand-rolled
              loops, you’re responsible for the types yourself.</p>

            <p class="author1">For<a data-primary="CSV" data-type="indexterm" id="calibre_link-198"
                class="calibre9"></a> example, consider parsing some CSV data. You could do it in plain JavaScript in a
              somewhat imperative style:</p>

            <pre data-code-language="js" data-type="programlisting" id="calibre_link-913" class="calibre17"><code class="kd">const</code> <code class="nx">csvData</code> <code class="o">=</code> <code class="s">"..."</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">rawRows</code> <code class="o">=</code> <code class="nx">csvData</code><code class="p">.</code><code class="nx">split</code><code class="p">(</code><code class="s">'\n'</code><code class="p">);</code>
<code class="kd">const</code> <code class="nx">headers</code> <code class="o">=</code> <code class="nx">rawRows</code><code class="p">[</code><code class="mi">0</code><code class="p">].</code><code class="nx">split</code><code class="p">(</code><code class="s">','</code><code class="p">);</code>

<code class="kd">const</code> <code class="nx">rows</code> <code class="o">=</code> <code class="nx">rawRows</code><code class="p">.</code><code class="nx">slice</code><code class="p">(</code><code class="mi">1</code><code class="p">).</code><code class="nx">map</code><code class="p">(</code><code class="nx">rowStr</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">row</code> <code class="o">=</code> <code class="p">{};</code>
  <code class="nx">rowStr</code><code class="p">.</code><code class="nx">split</code><code class="p">(</code><code class="s">','</code><code class="p">).</code><code class="nx">forEach</code><code class="p">((</code><code class="nx">val</code><code class="p">,</code> <code class="nx">j</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="nx">row</code><code class="p">[</code><code class="nx">headers</code><code class="p">[</code><code class="nx">j</code><code class="p">]]</code> <code class="o">=</code> <code class="nx">val</code><code class="p">;</code>
  <code class="p">});</code>
  <code class="kd">return</code> <code class="nx">row</code><code class="p">;</code>
<code class="p">});</code></pre>

            <p class="author1">More functionally minded JavaScripters might prefer to build the row objects with <code
                class="calibre18">reduce</code>:</p>

            <pre data-code-language="js" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">rows</code> <code class="o">=</code> <code class="nx">rawRows</code><code class="p">.</code><code class="nx">slice</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code>
    <code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">rowStr</code> <code class="o">=&gt;</code> <code class="nx">rowStr</code><code class="p">.</code><code class="nx">split</code><code class="p">(</code><code class="s">','</code><code class="p">).</code><code class="nx">reduce</code><code class="p">(</code>
        <code class="p">(</code><code class="nx">row</code><code class="p">,</code> <code class="nx">val</code><code class="p">,</code> <code class="nx">i</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="nx">row</code><code class="p">[</code><code class="nx">headers</code><code class="p">[</code><code class="nx">i</code><code class="p">]]</code> <code class="o">=</code> <code class="nx">val</code><code class="p">,</code> <code class="nx">row</code><code class="p">),</code>
        <code class="p">{}));</code></pre>

            <p class="author1">This<a data-primary="zipObject" data-type="indexterm" id="calibre_link-750"
                class="calibre9"></a> version saves three lines (almost 20 non-whitespace characters!) but may be more
              cryptic depending on your sensibilities. Lodash’s <code class="calibre18">zipObject</code> function, which
              forms an object by “zipping” up a keys and values array, can tighten it even further:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">import</code> <code class="nx">_</code> <code class="nx">from</code> <code class="s">'lodash'</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">rows</code> <code class="o">=</code> <code class="nx">rawRows</code><code class="p">.</code><code class="nx">slice</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code>
    <code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">rowStr</code> <code class="o">=&gt;</code> <code class="nx">_</code><code class="p">.</code><code class="nx">zipObject</code><code class="p">(</code><code class="nx">headers</code><code class="p">,</code> <code class="nx">rowStr</code><code class="p">.</code><code class="nx">split</code><code class="p">(</code><code class="s">','</code><code class="p">)));</code></pre>

            <p class="author1">I find this the clearest of all. But is it worth the cost of adding a dependency on a
              third-party library to your project? If you’re not using a bundler and the overhead of doing this is
              significant, then the answer may be “no.”</p>

            <p class="author1">When you add TypeScript to the mix, it starts to tip the balance more strongly in favor
              of the Lodash solution.</p>

            <p class="author1">Both vanilla JS versions of the CSV parser produce the same error in TypeScript:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">rowsA</code> <code class="o">=</code> <code class="nx">rawRows</code><code class="p">.</code><code class="nx">slice</code><code class="p">(</code><code class="mi">1</code><code class="p">).</code><code class="nx">map</code><code class="p">(</code><code class="nx">rowStr</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">row</code> <code class="o">=</code> <code class="p">{};</code>
  <code class="nx">rowStr</code><code class="p">.</code><code class="nx">split</code><code class="p">(</code><code class="s">','</code><code class="p">).</code><code class="nx">forEach</code><code class="p">((</code><code class="nx">val</code><code class="p">,</code> <code class="nx">j</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="nx">row</code><code class="p">[</code><code class="nx">headers</code><code class="p">[</code><code class="nx">j</code><code class="p">]]</code> <code class="o">=</code> <code class="nx">val</code><code class="p">;</code>
 <code class="c">// ~~~~~~~~~~~~~~~ No index signature with a parameter of</code>
 <code class="c">//                 type 'string' was found on type '{}'</code>
  <code class="p">});</code>
  <code class="kd">return</code> <code class="nx">row</code><code class="p">;</code>
<code class="p">});</code>
<code class="kd">const</code> <code class="nx">rowsB</code> <code class="o">=</code> <code class="nx">rawRows</code><code class="p">.</code><code class="nx">slice</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code>
  <code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">rowStr</code> <code class="o">=&gt;</code> <code class="nx">rowStr</code><code class="p">.</code><code class="nx">split</code><code class="p">(</code><code class="s">','</code><code class="p">).</code><code class="nx">reduce</code><code class="p">(</code>
      <code class="p">(</code><code class="nx">row</code><code class="p">,</code> <code class="nx">val</code><code class="p">,</code> <code class="nx">i</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="nx">row</code><code class="p">[</code><code class="nx">headers</code><code class="p">[</code><code class="nx">i</code><code class="p">]]</code> <code class="o">=</code> <code class="nx">val</code><code class="p">,</code> <code class="nx">row</code><code class="p">),</code>
                     <code class="c">// ~~~~~~~~~~~~~~~ No index signature with a parameter of</code>
                     <code class="c">//                 type 'string' was found on type '{}'</code>
      <code class="p">{}));</code></pre>

            <p class="author1">The solution in each case is to provide a type annotation for <code
                class="calibre18">{}</code>, either <code class="calibre18">{[column: string]: string}</code> or <code
                class="calibre18">Record&lt;string, string&gt;</code>.</p>

            <p class="author1">The Lodash version, on the other hand, passes the type checker without modification:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">rows</code> <code class="o">=</code> <code class="nx">rawRows</code><code class="p">.</code><code class="nx">slice</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code>
    <code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">rowStr</code> <code class="o">=&gt;</code> <code class="nx">_</code><code class="p">.</code><code class="nx">zipObject</code><code class="p">(</code><code class="nx">headers</code><code class="p">,</code> <code class="nx">rowStr</code><code class="p">.</code><code class="nx">split</code><code class="p">(</code><code class="s">','</code><code class="p">)));</code>
    <code class="c">// Type is _.Dictionary&lt;string&gt;[]</code></pre>

            <p class="author1"><code class="calibre18">Dictionary</code> is a Lodash type alias. <code
                class="calibre18">Dictionary&lt;string&gt;</code> is the same as <code
                class="calibre18">{[key: string]: string}</code> or <code
                class="calibre18">Record&lt;string, string&gt;</code>. The important thing here is that the type of
              <code class="calibre18">rows</code> is exactly correct, no type annotations needed.
            </p>

            <p class="author1">These advantages get more pronounced as your data munging gets more elaborate. For
              example, suppose you have a list of the rosters for all the NBA teams:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">interface</code> <code class="nx">BasketballPlayer</code> <code class="p">{</code>
  <code class="nx">name</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">team</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">salary</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">declare</code> <code class="kd">const</code> <code class="nx">rosters</code><code class="o">:</code> <code class="p">{[</code><code class="nx">team</code>: <code class="kd">string</code><code class="p">]</code><code class="o">:</code> <code class="nx">BasketballPlayer</code><code class="p">[]};</code></pre>

            <p class="author1">To<a data-primary="Object.values" data-type="indexterm" id="calibre_link-445"
                class="calibre9"></a> build a flat list using a loop, you might use <code
                class="calibre18">concat</code> with an array. This code runs fine but does not type check:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">let</code> <code class="nx">allPlayers</code> <code class="o">=</code> <code class="p">[];</code>
 <code class="c">// ~~~~~~~~~~ Variable 'allPlayers' implicitly has type 'any[]'</code>
 <code class="c">//            in some locations where its type cannot be determined</code>
<code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="nx">players</code> <code class="nx">of</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">values</code><code class="p">(</code><code class="nx">rosters</code><code class="p">))</code> <code class="p">{</code>
  <code class="nx">allPlayers</code> <code class="o">=</code> <code class="nx">allPlayers</code><code class="p">.</code><code class="nx">concat</code><code class="p">(</code><code class="nx">players</code><code class="p">);</code>
            <code class="c">// ~~~~~~~~~~ Variable 'allPlayers' implicitly has an 'any[]' type</code>
<code class="p">}</code></pre>

            <p class="author1">To fix the error you need to add a type annotation to <code
                class="calibre18">allPlayers</code>:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">let</code> <code class="nx">allPlayers</code>: <code class="nx">BasketballPlayer</code><code class="p">[]</code> <code class="o">=</code> <code class="p">[];</code>
<code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="nx">players</code> <code class="nx">of</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">values</code><code class="p">(</code><code class="nx">rosters</code><code class="p">))</code> <code class="p">{</code>
  <code class="nx">allPlayers</code> <code class="o">=</code> <code class="nx">allPlayers</code><code class="p">.</code><code class="nx">concat</code><code class="p">(</code><code class="nx">players</code><code class="p">);</code>  <code class="c">// OK</code>
<code class="p">}</code></pre>

            <p class="author1">But a better solution is to use <code class="calibre18">Array.prototype.flat</code>:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">allPlayers</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">values</code><code class="p">(</code><code class="nx">rosters</code><code class="p">).</code><code class="nx">flat</code><code class="p">();</code>
<code class="c">// OK, type is BasketballPlayer[]</code></pre>

            <p class="author1">The <code class="calibre18">flat</code> method flattens a multidimensional array. Its
              type signature is something like <code class="calibre18">T[][] =&gt; T[]</code>. This version is the most
              concise and requires no type annotations. As an added bonus you can use <code
                class="calibre18">const</code> instead of <code class="calibre18">let</code> to prevent future mutations
              to the <code class="calibre18">allPlayers</code> variable.</p>

            <p class="author1">Say you want to start with <code class="calibre18">allPlayers</code> and make a list of
              the highest-paid players on each team ordered by salary.</p>

            <p class="author1">Here’s a solution without Lodash. It requires a type annotation where you don’t use
              functional constructs:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">const</code> <code class="nx">teamToPlayers</code><code class="o">:</code> <code class="p">{[</code><code class="nx">team</code>: <code class="kd">string</code><code class="p">]</code><code class="o">:</code> <code class="nx">BasketballPlayer</code><code class="p">[]}</code> <code class="o">=</code> <code class="p">{};</code>
<code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="nx">player</code> <code class="nx">of</code> <code class="nx">allPlayers</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="p">{</code><code class="nx">team</code><code class="p">}</code> <code class="o">=</code> <code class="nx">player</code><code class="p">;</code>
  <code class="nx">teamToPlayers</code><code class="p">[</code><code class="nx">team</code><code class="p">]</code> <code class="o">=</code> <code class="nx">teamToPlayers</code><code class="p">[</code><code class="nx">team</code><code class="p">]</code> <code class="o">||</code> <code class="p">[];</code>
  <code class="nx">teamToPlayers</code><code class="p">[</code><code class="nx">team</code><code class="p">].</code><code class="nx">push</code><code class="p">(</code><code class="nx">player</code><code class="p">);</code>
<code class="p">}</code>

<code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="nx">players</code> <code class="nx">of</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">values</code><code class="p">(</code><code class="nx">teamToPlayers</code><code class="p">))</code> <code class="p">{</code>
  <code class="nx">players</code><code class="p">.</code><code class="nx">sort</code><code class="p">((</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">b</code><code class="p">.</code><code class="nx">salary</code> <code class="o">-</code> <code class="nx">a</code><code class="p">.</code><code class="nx">salary</code><code class="p">);</code>
<code class="p">}</code>

<code class="kd">const</code> <code class="nx">bestPaid</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">values</code><code class="p">(</code><code class="nx">teamToPlayers</code><code class="p">).</code><code class="nx">map</code><code class="p">(</code><code class="nx">players</code> <code class="o">=&gt;</code> <code class="nx">players</code><code class="p">[</code><code class="mi">0</code><code class="p">]);</code>
<code class="nx">bestPaid</code><code class="p">.</code><code class="nx">sort</code><code class="p">((</code><code class="nx">playerA</code><code class="p">,</code> <code class="nx">playerB</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">playerB</code><code class="p">.</code><code class="nx">salary</code> <code class="o">-</code> <code class="nx">playerA</code><code class="p">.</code><code class="nx">salary</code><code class="p">);</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">bestPaid</code><code class="p">);</code></pre>

            <p class="author1">Here’s<a data-primary="Curry, Stephen" data-type="indexterm" id="calibre_link-201"
                class="calibre9"></a><a data-primary="Paul, Chris" data-type="indexterm" id="calibre_link-457"
                class="calibre9"></a><a data-primary="James, LeBron" data-type="indexterm" id="calibre_link-332"
                class="calibre9"></a><a data-primary="Westbrook, Russell" data-type="indexterm" id="calibre_link-746"
                class="calibre9"></a><a data-primary="Griffin, Blake" data-type="indexterm" id="calibre_link-303"
                class="calibre9"></a> the output:</p>

            <pre data-type="programlisting" class="calibre17">[
  { team: 'GSW', salary: 37457154, name: 'Stephen Curry' },
  { team: 'HOU', salary: 35654150, name: 'Chris Paul' },
  { team: 'LAL', salary: 35654150, name: 'LeBron James' },
  { team: 'OKC', salary: 35654150, name: 'Russell Westbrook' },
  { team: 'DET', salary: 32088932, name: 'Blake Griffin' },
  ...
]</pre>

            <p class="author1">Here’s the equivalent with Lodash:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">const</code> <code class="nx">bestPaid</code> <code class="o">=</code> <code class="nx">_</code><code class="p">(</code><code class="nx">allPlayers</code><code class="p">)</code>
  <code class="p">.</code><code class="nx">groupBy</code><code class="p">(</code><code class="nx">player</code> <code class="o">=&gt;</code> <code class="nx">player</code><code class="p">.</code><code class="nx">team</code><code class="p">)</code>
  <code class="p">.</code><code class="nx">mapValues</code><code class="p">(</code><code class="nx">players</code> <code class="o">=&gt;</code> <code class="nx">_</code><code class="p">.</code><code class="nx">maxBy</code><code class="p">(</code><code class="nx">players</code><code class="p">,</code> <code class="nx">p</code> <code class="o">=&gt;</code> <code class="nx">p</code><code class="p">.</code><code class="nx">salary</code><code class="p">)</code><code class="o">!</code><code class="p">)</code>
  <code class="p">.</code><code class="nx">values</code><code class="p">()</code>
  <code class="p">.</code><code class="nx">sortBy</code><code class="p">(</code><code class="nx">p</code> <code class="o">=&gt;</code> <code class="o">-</code><code class="nx">p</code><code class="p">.</code><code class="nx">salary</code><code class="p">)</code>
  <code class="p">.</code><code class="nx">value</code><code class="p">()</code>  <code class="c">// Type is BasketballPlayer[]</code></pre>

            <p class="author1">In addition to being half the length, this code is clearer and requires only a single
              non-null assertion (the type checker doesn’t know that the <code class="calibre18">players</code> array
              passed to <code class="calibre18">_.maxBy</code> is non-empty). It makes use of a “chain,” a concept in
              Lodash and<a data-primary="Underscore library" data-type="indexterm" id="calibre_link-706"
                class="calibre9"></a> Underscore that lets you write a sequence of operations in a more natural order.
              Instead of writing:</p>

            <pre data-type="programlisting" class="calibre17">_.a(_.b(_.c(v)))</pre>

            <p class="author1">you write:</p>

            <pre data-type="programlisting" class="calibre17">_(v).a().b().c().value()</pre>

            <p class="author1">The <code class="calibre18">_(v)</code> “wraps” the value, and the <code
                class="calibre18">.value()</code> “unwraps” it.</p>

            <p class="author1">You can inspect each function call in the chain to see the type of the wrapped value.
              It’s always correct.</p>

            <p class="author1">Even some of the quirkier shorthands in Lodash can be modeled accurately in TypeScript.
              For instance, why would you want to use <code class="calibre18">_.map</code> instead of the built-in <code
                class="calibre18">Array.prototype.map</code>? One reason is that instead of passing in a callback you
              can pass in the name of a property. These calls all produce the same result:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">const</code> <code class="nx">namesA</code> <code class="o">=</code> <code class="nx">allPlayers</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">player</code> <code class="o">=&gt;</code> <code class="nx">player</code><code class="p">.</code><code class="nx">name</code><code class="p">)</code>  <code class="c">// Type is string[]</code>
<code class="kd">const</code> <code class="nx">namesB</code> <code class="o">=</code> <code class="nx">_</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">allPlayers</code><code class="p">,</code> <code class="nx">player</code> <code class="o">=&gt;</code> <code class="nx">player</code><code class="p">.</code><code class="nx">name</code><code class="p">)</code>  <code class="c">// Type is string[]</code>
<code class="kd">const</code> <code class="nx">namesC</code> <code class="o">=</code> <code class="nx">_</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">allPlayers</code><code class="p">,</code> <code class="s">'name'</code><code class="p">);</code>  <code class="c">// Type is string[]</code></pre>

            <p class="author1">It’s a testament to the sophistication of TypeScript’s type system that it can model a
              construct like this accurately, but it naturally falls out of the combination of string literal types and
              index types (see <a href="#calibre_link-759" class="calibre9">Item 14</a>). If<a data-primary="C++"
                data-type="indexterm" id="calibre_link-143" class="calibre9"></a> you’re used to C++ or<a
                data-primary="Java" data-secondary="versus TypeScript" data-type="indexterm" id="calibre_link-341"
                class="calibre9"></a> Java, this sort of type inference can feel quite magical!</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">salaries</code> <code class="o">=</code> <code class="nx">_</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">allPlayers</code><code class="p">,</code> <code class="s">'salary'</code><code class="p">);</code>  <code class="c">// Type is number[]</code>
<code class="kd">const</code> <code class="nx">teams</code> <code class="o">=</code> <code class="nx">_</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">allPlayers</code><code class="p">,</code> <code class="s">'team'</code><code class="p">);</code>  <code class="c">// Type is string[]</code>
<code class="kd">const</code> <code class="nx">mix</code> <code class="o">=</code> <code class="nx">_</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">allPlayers</code><code class="p">,</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">&lt;</code> <code class="mi">0.5</code> <code class="o">?</code> <code class="s">'name'</code> <code class="o">:</code> <code class="s">'salary'</code><code class="p">);</code>
  <code class="c">// Type is (string | number)[]</code></pre>

            <p class="author1">It’s not a coincidence that types flow so well through built-in functional constructs and
              those in libraries like Lodash. By avoiding mutation and returning new values from every call, they are
              able to produce new types as well (<a href="#calibre_link-810" class="calibre9">Item 20</a>). And to a
              large extent, the development of TypeScript has been driven by an attempt to accurately model the behavior
              of JavaScript libraries in the wild. Take advantage of all this work and use them!</p>








            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-914">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">Use built-in functional constructs and those in utility libraries like Lodash
                      instead of hand-rolled constructs to improve type flow, increase legibility, and reduce the need
                      for explicit type annotations.<a data-primary="" data-startref="lodash03" data-type="indexterm"
                        id="calibre_link-386" class="calibre9"></a><a data-primary="" data-startref="TAreduc03"
                        data-type="indexterm" id="calibre_link-559" class="calibre9"></a><a data-primary=""
                        data-startref="Lutili03" data-type="indexterm" id="calibre_link-384" class="calibre9"></a><a
                        data-primary="" data-startref="Futility03" data-type="indexterm" id="calibre_link-290"
                        class="calibre9"></a><a data-primary="" data-startref="TIfunc03" data-type="indexterm"
                        id="calibre_link-618" class="calibre9"></a></p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>







      </div>
    </section>
  </div>

  <div data-type="book" class="calibre1" id="calibre_link-813">
    <section data-pdf-bookmark="Chapter 4. Type Design" data-type="chapter" type="chapter" class="praise">
      <div class="praise" id="calibre_link-782">
        <h1 class="calibre14"><span class="calibre">Chapter 4. </span>Type Design</h1>

        <blockquote class="calibre4 pcalibre1 pcalibre">
          <p class="calibre5">Show me your flowcharts and conceal your tables, and I shall continue to be mystified.
            Show me your tables, and I won’t usually need your flowcharts; they’ll be obvious.</p>
          <p data-type="attribution" class="calibre6 pcalibre2">Fred Brooks, <em class="calibre3">The Mythical Man
              Month</em></p>
        </blockquote>

        <p class="author1">The<a data-primary="Brooks, Fred" data-type="indexterm" id="calibre_link-135"
            class="calibre9"></a> language in Fred Brooks’s quote is dated, but the sentiment remains true: code is
          difficult to understand if you can’t see the data or data types on which it operates. This is one of the great
          advantages of a type system: by writing out types, you make them visible to readers of your code. And this
          makes your code understandable.</p>

        <p class="author1">Other chapters cover the nuts and bolts of TypeScript types: using them, inferring them, and
          writing declarations with them. This chapter discusses the design of the types themselves. The examples in
          this chapter are all written with TypeScript in mind, but most of the ideas are more broadly applicable.</p>

        <p class="author1">If you write your types well, then with any luck your flowcharts will be obvious, too.</p>






        <section data-pdf-bookmark="Item 28: Prefer Types That Always Represent Valid States" data-type="sect1"
          class="praise">
          <div class="praise" id="calibre_link-761">
            <h1 class="calibre16">Item 28: Prefer Types That Always Represent Valid States</h1>

            <p class="author1">If<a data-primary="type design"
                data-secondary="types representing valid versus invalid states" data-type="indexterm"
                id="calibre_link-601" class="calibre9"></a><a data-primary="valid states" data-type="indexterm"
                id="calibre_link-721" class="calibre9"></a><a data-primary="invalid states" data-type="indexterm"
                id="calibre_link-330" class="calibre9"></a> you design your types well, your code should be
              straightforward to write. But if you design your types poorly, no amount of cleverness or documentation
              will save you. Your code will be confusing and bug prone.</p>

            <p class="author1">A key to effective type design is crafting types that can only represent a valid state.
              This item walks through a few examples of how this can go wrong and shows you how to fix them.</p>

            <p class="author1">Suppose you’re building a web application that lets you select a page, loads the content
              of that page, and then displays it. You might write the state like this:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">State</code> <code class="p">{</code>
  <code class="nx">pageText</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">isLoading</code>: <code class="nx">boolean</code><code class="p">;</code>
  <code class="nx">error?</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">When you write your code to render the page, you need to consider all of these fields:
            </p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">renderPage</code><code class="p">(</code><code class="nx">state</code>: <code class="nx">State</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">state</code><code class="p">.</code><code class="nx">error</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">return</code> <code class="s">`Error! Unable to load </code><code class="si">${</code><code class="nx">currentPage</code><code class="si">}</code><code class="s">: </code><code class="si">${</code><code class="nx">state</code><code class="p">.</code><code class="nx">error</code><code class="si">}</code><code class="s">`</code><code class="p">;</code>
  <code class="p">}</code> <code class="kd">else</code> <code class="kd">if</code> <code class="p">(</code><code class="nx">state</code><code class="p">.</code><code class="nx">isLoading</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">return</code> <code class="s">`Loading </code><code class="si">${</code><code class="nx">currentPage</code><code class="si">}</code><code class="s">...`</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="kd">return</code> <code class="s">`&lt;h1&gt;</code><code class="si">${</code><code class="nx">currentPage</code><code class="si">}</code><code class="s">&lt;/h1&gt;</code><code class="si">\</code><code class="s">n</code><code class="si">${</code><code class="nx">state</code><code class="p">.</code><code class="nx">pageText</code><code class="si">}</code><code class="s">`</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">Is this right, though? What if <code class="calibre18">isLoading</code> and <code
                class="calibre18">error</code> are both set? What would that mean? Is it better to display the loading
              message or the error message? It’s hard to say! There’s not enough information available.</p>

            <p class="author1">Or what if you’re writing a <code class="calibre18">changePage</code> function? Here’s an
              attempt:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">async</code> <code class="kd">function</code> <code class="nx">changePage</code><code class="p">(</code><code class="nx">state</code>: <code class="nx">State</code><code class="p">,</code> <code class="nx">newPage</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">state</code><code class="p">.</code><code class="nx">isLoading</code> <code class="o">=</code> <code class="kd">true</code><code class="p">;</code>
  <code class="kd">try</code> <code class="p">{</code>
    <code class="kd">const</code> <code class="nx">response</code> <code class="o">=</code> <code class="kd">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">getUrlForPage</code><code class="p">(</code><code class="nx">newPage</code><code class="p">));</code>
    <code class="kd">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">response</code><code class="p">.</code><code class="nx">ok</code><code class="p">)</code> <code class="p">{</code>
      <code class="kd">throw</code> <code class="kd">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s">`Unable to load </code><code class="si">${</code><code class="nx">newPage</code><code class="si">}</code><code class="s">: </code><code class="si">${</code><code class="nx">response</code><code class="p">.</code><code class="nx">statusText</code><code class="si">}</code><code class="s">`</code><code class="p">);</code>
    <code class="p">}</code>
    <code class="kd">const</code> <code class="nx">text</code> <code class="o">=</code> <code class="kd">await</code> <code class="nx">response</code><code class="p">.</code><code class="nx">text</code><code class="p">();</code>
    <code class="nx">state</code><code class="p">.</code><code class="nx">isLoading</code> <code class="o">=</code> <code class="kd">false</code><code class="p">;</code>
    <code class="nx">state</code><code class="p">.</code><code class="nx">pageText</code> <code class="o">=</code> <code class="nx">text</code><code class="p">;</code>
  <code class="p">}</code> <code class="kd">catch</code> <code class="p">(</code><code class="nx">e</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">state</code><code class="p">.</code><code class="nx">error</code> <code class="o">=</code> <code class="s">''</code> <code class="o">+</code> <code class="nx">e</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

            <p class="author1">There are many problems with this! Here are a few:</p>

            <ul class="printings">
              <li class="calibre12">
                <p class="author1">We forgot to set <code class="calibre18">state.isLoading</code> to <code
                    class="calibre18">false</code> in the error case.</p>
              </li>
              <li class="calibre12">
                <p class="author1">We didn’t clear out <code class="calibre18">state.error</code>, so if the previous
                  request failed, then you’ll keep seeing that error message instead of a loading message.</p>
              </li>
              <li class="calibre12">
                <p class="author1">If the user changes pages again while the page is loading, who knows what will
                  happen. They might see a new page and then an error, or the first page and not the second depending on
                  the order in which the responses come back.</p>
              </li>
            </ul>

            <p class="author1">The problem is that the state includes both too little information (which request failed?
              which is loading?) and too much: the <code class="calibre18">State</code> type allows both <code
                class="calibre18">isLoading</code> and <code class="calibre18">error</code> to be set, even though this
              represents an invalid state. This makes both <span class="calibre"><code
                  class="calibre18">render()</code></span> and <code class="calibre18">changePage()</code> impossible to
              implement well.</p>

            <p class="author1">Here’s a better way to represent the application state:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">RequestPending</code> <code class="p">{</code>
  <code class="nx">state</code><code class="o">:</code> <code class="s">'pending'</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">interface</code> <code class="nx">RequestError</code> <code class="p">{</code>
  <code class="nx">state</code><code class="o">:</code> <code class="s">'error'</code><code class="p">;</code>
  <code class="nx">error</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">interface</code> <code class="nx">RequestSuccess</code> <code class="p">{</code>
  <code class="nx">state</code><code class="o">:</code> <code class="s">'ok'</code><code class="p">;</code>
  <code class="nx">pageText</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">type</code> <code class="nx">RequestState</code> <code class="o">=</code> <code class="nx">RequestPending</code> <code class="o">|</code> <code class="nx">RequestError</code> <code class="o">|</code> <code class="nx">RequestSuccess</code><code class="p">;</code>

<code class="kd">interface</code> <code class="nx">State</code> <code class="p">{</code>
  <code class="nx">currentPage</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">requests</code><code class="o">:</code> <code class="p">{[</code><code class="nx">page</code>: <code class="kd">string</code><code class="p">]</code><code class="o">:</code> <code class="nx">RequestState</code><code class="p">};</code>
<code class="p">}</code></pre>

            <p class="author1">This uses a tagged union (also known as a “discriminated union”) to explicitly model the
              different states that a network request can be in. This version of the state is three to four times
              longer, but it has the enormous advantage of not admitting invalid states. The current page is modeled
              explicitly, as is the state of every request that you issue. As a result, the <code
                class="calibre18">renderPage</code> and <code class="calibre18">changePage</code> functions are easy to
              implement:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">renderPage</code><code class="p">(</code><code class="nx">state</code>: <code class="nx">State</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="p">{</code><code class="nx">currentPage</code><code class="p">}</code> <code class="o">=</code> <code class="nx">state</code><code class="p">;</code>
  <code class="kd">const</code> <code class="nx">requestState</code> <code class="o">=</code> <code class="nx">state</code><code class="p">.</code><code class="nx">requests</code><code class="p">[</code><code class="nx">currentPage</code><code class="p">];</code>
  <code class="kd">switch</code> <code class="p">(</code><code class="nx">requestState</code><code class="p">.</code><code class="nx">state</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">case</code> <code class="s">'pending'</code><code class="o">:</code>
      <code class="kd">return</code> <code class="s">`Loading </code><code class="si">${</code><code class="nx">currentPage</code><code class="si">}</code><code class="s">...`</code><code class="p">;</code>
    <code class="kd">case</code> <code class="s">'error'</code><code class="o">:</code>
      <code class="kd">return</code> <code class="s">`Error! Unable to load </code><code class="si">${</code><code class="nx">currentPage</code><code class="si">}</code><code class="s">: </code><code class="si">${</code><code class="nx">requestState</code><code class="p">.</code><code class="nx">error</code><code class="si">}</code><code class="s">`</code><code class="p">;</code>
    <code class="kd">case</code> <code class="s">'ok'</code><code class="o">:</code>
      <code class="kd">return</code> <code class="s">`&lt;h1&gt;</code><code class="si">${</code><code class="nx">currentPage</code><code class="si">}</code><code class="s">&lt;/h1&gt;</code><code class="si">\</code><code class="s">n</code><code class="si">${</code><code class="nx">requestState</code><code class="p">.</code><code class="nx">pageText</code><code class="si">}</code><code class="s">`</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kd">async</code> <code class="kd">function</code> <code class="nx">changePage</code><code class="p">(</code><code class="nx">state</code>: <code class="nx">State</code><code class="p">,</code> <code class="nx">newPage</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">state</code><code class="p">.</code><code class="nx">requests</code><code class="p">[</code><code class="nx">newPage</code><code class="p">]</code> <code class="o">=</code> <code class="p">{</code><code class="nx">state</code><code class="o">:</code> <code class="s">'pending'</code><code class="p">};</code>
  <code class="nx">state</code><code class="p">.</code><code class="nx">currentPage</code> <code class="o">=</code> <code class="nx">newPage</code><code class="p">;</code>
  <code class="kd">try</code> <code class="p">{</code>
    <code class="kd">const</code> <code class="nx">response</code> <code class="o">=</code> <code class="kd">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">getUrlForPage</code><code class="p">(</code><code class="nx">newPage</code><code class="p">));</code>
    <code class="kd">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">response</code><code class="p">.</code><code class="nx">ok</code><code class="p">)</code> <code class="p">{</code>
      <code class="kd">throw</code> <code class="kd">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s">`Unable to load </code><code class="si">${</code><code class="nx">newPage</code><code class="si">}</code><code class="s">: </code><code class="si">${</code><code class="nx">response</code><code class="p">.</code><code class="nx">statusText</code><code class="si">}</code><code class="s">`</code><code class="p">);</code>
    <code class="p">}</code>
    <code class="kd">const</code> <code class="nx">pageText</code> <code class="o">=</code> <code class="kd">await</code> <code class="nx">response</code><code class="p">.</code><code class="nx">text</code><code class="p">();</code>
    <code class="nx">state</code><code class="p">.</code><code class="nx">requests</code><code class="p">[</code><code class="nx">newPage</code><code class="p">]</code> <code class="o">=</code> <code class="p">{</code><code class="nx">state</code><code class="o">:</code> <code class="s">'ok'</code><code class="p">,</code> <code class="nx">pageText</code><code class="p">};</code>
  <code class="p">}</code> <code class="kd">catch</code> <code class="p">(</code><code class="nx">e</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">state</code><code class="p">.</code><code class="nx">requests</code><code class="p">[</code><code class="nx">newPage</code><code class="p">]</code> <code class="o">=</code> <code class="p">{</code><code class="nx">state</code><code class="o">:</code> <code class="s">'error'</code><code class="p">,</code> <code class="nx">error</code><code class="o">:</code> <code class="s">''</code> <code class="o">+</code> <code class="nx">e</code><code class="p">};</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

            <p class="author1">The ambiguity from the first implementation is entirely gone: it’s clear what the current
              page is, and every request is in exactly one state. If the user changes the page after a request has been
              issued, that’s no problem either. The old request still completes, but it doesn’t affect the UI.</p>

            <p class="author1">For a simpler but more dire example, consider the fate of Air France Flight 447, an
              Airbus 330 that disappeared over the Atlantic on June 1, 2009. The Airbus was a fly-by-wire aircraft,
              meaning that the pilots’ control inputs went through a computer system before affecting the physical
              control surfaces of the plane. In the wake of the crash there were many questions raised about the wisdom
              of relying on computers to make such life-and-death decisions. Two years later when the black box
              recorders were recovered, they revealed many factors that led to the crash. But a key one was bad state
              design.</p>

            <p class="author1">The cockpit of the Airbus 330 had a separate set of controls for the pilot and copilot.
              The “side sticks” controlled the angle of attack. Pulling back would send the airplane into a climb, while
              pushing forward would make it dive. The Airbus 330 used a system called “dual input” mode, which let the
              two side sticks move independently. Here’s how you might model its state in TypeScript:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">CockpitControls</code> <code class="p">{</code>
  <code class="c">/** Angle of the left side stick in degrees, 0 = neutral, + = forward */</code>
  <code class="nx">leftSideStick</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="c">/** Angle of the right side stick in degrees, 0 = neutral, + = forward */</code>
  <code class="nx">rightSideStick</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">Suppose you were given this data structure and asked to write a <code
                class="calibre18">getStickSetting</code> function that computed the current stick setting. How would you
              do it?</p>

            <p class="author1">One way would be to assume that the pilot (who sits on the left) is in control:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">getStickSetting</code><code class="p">(</code><code class="nx">controls</code>: <code class="nx">CockpitControls</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">controls</code><code class="p">.</code><code class="nx">leftSideStick</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">But what if the copilot has taken control? Maybe you should use whichever stick is away
              from zero:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">getStickSetting</code><code class="p">(</code><code class="nx">controls</code>: <code class="nx">CockpitControls</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="p">{</code><code class="nx">leftSideStick</code><code class="p">,</code> <code class="nx">rightSideStick</code><code class="p">}</code> <code class="o">=</code> <code class="nx">controls</code><code class="p">;</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">leftSideStick</code> <code class="o">===</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">return</code> <code class="nx">rightSideStick</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="kd">return</code> <code class="nx">leftSideStick</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">But there’s a problem with this implementation: we can only be confident returning the
              left setting if the right one is neutral. So you should check for that:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">getStickSetting</code><code class="p">(</code><code class="nx">controls</code>: <code class="nx">CockpitControls</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="p">{</code><code class="nx">leftSideStick</code><code class="p">,</code> <code class="nx">rightSideStick</code><code class="p">}</code> <code class="o">=</code> <code class="nx">controls</code><code class="p">;</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">leftSideStick</code> <code class="o">===</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">return</code> <code class="nx">rightSideStick</code><code class="p">;</code>
  <code class="p">}</code> <code class="kd">else</code> <code class="kd">if</code> <code class="p">(</code><code class="nx">rightSideStick</code> <code class="o">===</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">return</code> <code class="nx">leftSideStick</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="c">// ???</code>
<code class="p">}</code></pre>

            <p class="author1">What do you do if they’re both non-zero? Hopefully they’re about the same, in which case
              you could just average them:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">getStickSetting</code><code class="p">(</code><code class="nx">controls</code>: <code class="nx">CockpitControls</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="p">{</code><code class="nx">leftSideStick</code><code class="p">,</code> <code class="nx">rightSideStick</code><code class="p">}</code> <code class="o">=</code> <code class="nx">controls</code><code class="p">;</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">leftSideStick</code> <code class="o">===</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">return</code> <code class="nx">rightSideStick</code><code class="p">;</code>
  <code class="p">}</code> <code class="kd">else</code> <code class="kd">if</code> <code class="p">(</code><code class="nx">rightSideStick</code> <code class="o">===</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">return</code> <code class="nx">leftSideStick</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">abs</code><code class="p">(</code><code class="nx">leftSideStick</code> <code class="o">-</code> <code class="nx">rightSideStick</code><code class="p">)</code> <code class="o">&lt;</code> <code class="mi">5</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">return</code> <code class="p">(</code><code class="nx">leftSideStick</code> <code class="o">+</code> <code class="nx">rightSideStick</code><code class="p">)</code> <code class="o">/</code> <code class="mi">2</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="c">// ???</code>
<code class="p">}</code></pre>

            <p class="author1">But what if they’re not? Can you throw an error? Not really: the ailerons need to be set
              at some angle!</p>

            <p class="author1">On Air France 447, the copilot silently pulled back on his side stick as the plane
              entered a storm. It gained altitude but eventually lost speed and entered a stall, a condition in which
              the plane is moving too slowly to effectively generate lift. It began to drop.</p>

            <p class="author1">To escape a stall, pilots are trained to push the controls forward to make the plane dive
              and regain speed. This is exactly what the pilot did. But the copilot was still silently pulling back on
              his side stick. And the Airbus function looked like this:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">getStickSetting</code><code class="p">(</code><code class="nx">controls</code>: <code class="nx">CockpitControls</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="p">(</code><code class="nx">controls</code><code class="p">.</code><code class="nx">leftSideStick</code> <code class="o">+</code> <code class="nx">controls</code><code class="p">.</code><code class="nx">rightSideStick</code><code class="p">)</code> <code class="o">/</code> <code class="mi">2</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">Even though the pilot pushed the stick fully forward, it averaged out to nothing. He had
              no idea why the plane wasn’t diving. By the time the copilot revealed what he’d done, the plane had lost
              too much altitude to recover and it crashed into the ocean, killing all 228 people on board.</p>

            <p class="author1">The point of all this is that there is no good way to implement <code
                class="calibre18">getStickSetting</code> given that input! The function has been set up to fail. In most
              planes the two sets of controls are mechanically connected. If the copilot pulls back, the pilot’s
              controls will also pull back. The state of these controls is simple to express:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">CockpitControls</code> <code class="p">{</code>
  <code class="c">/** Angle of the stick in degrees, 0 = neutral, + = forward */</code>
  <code class="nx">stickAngle</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">And<a data-primary="Brooks, Fred" data-type="indexterm" id="calibre_link-136"
                class="calibre9"></a> now, as in the Fred Brooks quote from the start of the chapter, our flowcharts are
              obvious. You don’t need a <code class="calibre18">getStickSetting</code> function at all.</p>

            <p class="author1">As you design your types, take care to think about which values you are including and
              which you are excluding. If you only allow values that represent valid states, your code will be easier to
              write and TypeScript will have an easier time checking it. This is a very general principle, and several
              of the other items in this chapter will cover specific manifestations of it.</p>








            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-915">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">Types that represent both valid and invalid states are likely to lead to
                      confusing and error-prone code.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Prefer types that only represent valid states. Even if they are longer or harder
                      to express, they will save you time and pain in the end!<a data-primary=""
                        data-startref="invalid04" data-type="indexterm" id="calibre_link-331" class="calibre9"></a><a
                        data-primary="" data-startref="valids04" data-type="indexterm" id="calibre_link-722"
                        class="calibre9"></a><a data-primary="" data-startref="TDvalid04" data-type="indexterm"
                        id="calibre_link-602" class="calibre9"></a></p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>













        <section data-pdf-bookmark="Item 29: Be Liberal in What You Accept and Strict in What You Produce"
          data-type="sect1" class="praise">
          <div class="praise" id="calibre_link-52">
            <h1 class="calibre16">Item 29: Be Liberal in What You Accept and Strict in What You Produce</h1>

            <p class="author1">This<a data-primary="type design" data-secondary="robustness principle"
                data-type="indexterm" id="calibre_link-598" class="calibre9"></a><a data-primary="robustness principle"
                data-type="indexterm" id="calibre_link-495" class="calibre9"></a><a data-primary="Postel&apos;s Law"
                data-type="indexterm" id="calibre_link-459" class="calibre9"></a><a data-primary="functions"
                data-secondary="robustness principle" data-type="indexterm" id="calibre_link-286" class="calibre9"></a>
              idea is known as the <em class="calibre3">robustness principle</em> or <em class="calibre3">Postel’s
                Law</em>, after Jon Postel, who wrote it in the context of TCP:</p>
            <blockquote class="calibre4 pcalibre1 pcalibre">
              <p class="calibre5">TCP implementations should follow a general principle of robustness: be conservative
                in what you do, be liberal in what you accept from others.</p>
            </blockquote>

            <p class="author1">A similar rule applies to the contracts for functions. It’s fine for your functions to be
              broad in what they accept as inputs, but they should generally be more specific in what they produce as
              outputs.</p>

            <p class="author1">As an example, a 3D mapping API might provide a way to position the camera and to
              calculate a viewport for a bounding box:</p>

            <pre data-code-language="ts" data-type="programlisting" id="calibre_link-916"
              class="calibre17"><code class="kd">declare</code> <code class="kd">function</code> <code class="nx">setCamera</code><code class="p">(</code><code class="nx">camera</code>: <code class="nx">CameraOptions</code><code class="p">)</code><code class="o">:</code> <code class="kd">void</code><code class="p">;</code>
<code class="kd">declare</code> <code class="kd">function</code> <code class="nx">viewportForBounds</code><code class="p">(</code><code class="nx">bounds</code>: <code class="nx">LngLatBounds</code><code class="p">)</code><code class="o">:</code> <code class="nx">CameraOptions</code><code class="p">;</code></pre>

            <p class="author1">It is convenient that the result of <code class="calibre18">viewportForBounds</code> can
              be passed directly to <span class="calibre"><code class="calibre18">setCamera</code></span> to position
              the camera.</p>

            <p class="author1">Let’s look at the definitions of these types:</p>

            <pre data-code-language="ts" data-type="programlisting" id="calibre_link-917"
              class="calibre17"><code class="kd">interface</code> <code class="nx">CameraOptions</code> <code class="p">{</code>
  <code class="nx">center?</code>: <code class="nx">LngLat</code><code class="p">;</code>
  <code class="nx">zoom?</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">bearing?</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">pitch?</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">type</code> <code class="nx">LngLat</code> <code class="o">=</code>
  <code class="p">{</code> <code class="nx">lng</code>: <code class="nx">number</code><code class="p">;</code> <code class="nx">lat</code>: <code class="nx">number</code><code class="p">;</code> <code class="p">}</code> <code class="o">|</code>
  <code class="p">{</code> <code class="nx">lon</code>: <code class="nx">number</code><code class="p">;</code> <code class="nx">lat</code>: <code class="nx">number</code><code class="p">;</code> <code class="p">}</code> <code class="o">|</code>
  <code class="p">[</code><code class="kt">number</code><code class="p">,</code> <code class="kt">number</code><code class="p">];</code></pre>

            <p class="author1">The fields in <code class="calibre18">CameraOptions</code> are all optional because you
              might want to set just the center or zoom without changing the bearing or pitch. The <code
                class="calibre18">LngLat</code> type also makes <code class="calibre18">setCamera</code> liberal in what
              it accepts: you can pass in a <code class="calibre18">{lng, lat}</code> object, a <code
                class="calibre18">{lon, lat}</code> object, or a <code class="calibre18">[lng, lat]</code> pair if
              you’re confident you got the order right. These accommodations make the function easy to call.</p>

            <p class="author1">The <code class="calibre18">viewportForBounds</code> function takes in another “liberal”
              type:</p>

            <pre data-code-language="ts" data-type="programlisting" id="calibre_link-918"
              class="calibre17"><code class="kd">type</code> <code class="nx">LngLatBounds</code> <code class="o">=</code>
  <code class="p">{</code><code class="nx">northeast</code>: <code class="nx">LngLat</code><code class="p">,</code> <code class="nx">southwest</code>: <code class="nx">LngLat</code><code class="p">}</code> <code class="o">|</code>
  <code class="p">[</code><code class="nx">LngLat</code><code class="p">,</code> <code class="nx">LngLat</code><code class="p">]</code> <code class="o">|</code>
  <code class="p">[</code><code class="kt">number</code><code class="p">,</code> <code class="kt">number</code><code class="p">,</code> <code class="kt">number</code><code class="p">,</code> <code class="kt">number</code><code class="p">];</code></pre>

            <p class="author1">You can specify the bounds either using named corners, a pair of lat/lngs, or a
              four-tuple if you’re confident you got the order right. Since <code class="calibre18">LngLat</code>
              already accommodates three forms, there are no fewer than 19 possible forms for <code
                class="calibre18">LngLatBounds</code>. Liberal indeed!</p>

            <p class="author1">Now<a data-primary="GeoJSON" data-type="indexterm" id="calibre_link-292"
                class="calibre9"></a> let’s write a function that adjusts the viewport to accommodate a GeoJSON Feature
              and stores the new viewport in the URL (for a definition of <code
                class="calibre18">calculateBoundingBox</code>, see <a href="#calibre_link-799" class="calibre9">Item
                31</a>):</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">focusOnFeature</code><code class="p">(</code><code class="nx">f</code>: <code class="nx">Feature</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">bounds</code> <code class="o">=</code> <code class="nx">calculateBoundingBox</code><code class="p">(</code><code class="nx">f</code><code class="p">);</code>
  <code class="kd">const</code> <code class="nx">camera</code> <code class="o">=</code> <code class="nx">viewportForBounds</code><code class="p">(</code><code class="nx">bounds</code><code class="p">);</code>
  <code class="nx">setCamera</code><code class="p">(</code><code class="nx">camera</code><code class="p">);</code>
  <code class="kd">const</code> <code class="p">{</code><code class="nx">center</code><code class="o">:</code> <code class="p">{</code><code class="nx">lat</code><code class="p">,</code> <code class="nx">lng</code><code class="p">},</code> <code class="nx">zoom</code><code class="p">}</code> <code class="o">=</code> <code class="nx">camera</code><code class="p">;</code>
               <code class="c">// ~~~      Property 'lat' does not exist on type ...</code>
               <code class="c">//      ~~~ Property 'lng' does not exist on type ...</code>
  <code class="nx">zoom</code><code class="p">;</code>  <code class="c">// Type is number | undefined</code>
  <code class="nb">window</code><code class="p">.</code><code class="nx">location</code><code class="p">.</code><code class="nx">search</code> <code class="o">=</code> <code class="s">`?v=@</code><code class="si">${</code><code class="nx">lat</code><code class="si">}</code><code class="s">,</code><code class="si">${</code><code class="nx">lng</code><code class="si">}</code><code class="s">z</code><code class="si">${</code><code class="nx">zoom</code><code class="si">}</code><code class="s">`</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">Whoops! Only the <code class="calibre18">zoom</code> property exists, but its type is
              inferred as <code class="calibre18">number|undefined</code>, which is also problematic. The issue is that
              the type declaration for <code class="calibre18">viewportForBounds</code> indicates that it is liberal not
              just in what it accepts but also in what it <em class="calibre3">produces</em>. The only type-safe way to
              use the <code class="calibre18">camera</code> result is to introduce a code branch for each component of
              the union type (<a href="#calibre_link-43" class="calibre9">Item 22</a>).</p>

            <p class="author1">The<a data-primary="union types" data-secondary="difficulty in using"
                data-type="indexterm" id="calibre_link-709" class="calibre9"></a><a data-primary="parameter types"
                data-type="indexterm" id="calibre_link-455" class="calibre9"></a><a data-primary="return types"
                data-type="indexterm" id="calibre_link-493" class="calibre9"></a> return type with lots of optional
              properties and union types makes <code class="calibre18">viewportForBounds</code> difficult to use. Its
              broad parameter type is convenient, but its broad return type is not. A more convenient API would be
              strict in what it produces.</p>

            <p class="author1">One way to do this is to distinguish a canonical format for coordinates. Following
              JavaScript’s convention of distinguishing “Array” and “Array-like” (<a href="#calibre_link-21"
                class="calibre9">Item 16</a>), you can draw a distinction between <code class="calibre18">LngLat</code>
              and <code class="calibre18">LngLatLike</code>. You can also distinguish between a fully defined <code
                class="calibre18">Camera</code> type and the partial version accepted by <code
                class="calibre18">setCamera</code>:</p>

            <pre data-code-language="ts" data-type="programlisting" id="calibre_link-919"
              class="calibre17"><code class="kd">interface</code> <code class="nx">LngLat</code> <code class="p">{</code> <code class="nx">lng</code>: <code class="nx">number</code><code class="p">;</code> <code class="nx">lat</code>: <code class="nx">number</code><code class="p">;</code> <code class="p">};</code>
<code class="kd">type</code> <code class="nx">LngLatLike</code> <code class="o">=</code> <code class="nx">LngLat</code> <code class="o">|</code> <code class="p">{</code> <code class="nx">lon</code>: <code class="nx">number</code><code class="p">;</code> <code class="nx">lat</code>: <code class="nx">number</code><code class="p">;</code> <code class="p">}</code> <code class="o">|</code> <code class="p">[</code><code class="kt">number</code><code class="p">,</code> <code class="kt">number</code><code class="p">];</code>

<code class="kd">interface</code> <code class="nx">Camera</code> <code class="p">{</code>
  <code class="nx">center</code>: <code class="nx">LngLat</code><code class="p">;</code>
  <code class="nx">zoom</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">bearing</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">pitch</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">interface</code> <code class="nx">CameraOptions</code> <code class="kd">extends</code> <code class="nx">Omit</code><code class="o">&lt;</code><code class="nx">Partial</code><code class="o">&lt;</code><code class="nx">Camera</code><code class="o">&gt;</code><code class="p">,</code> <code class="s">'center'</code><code class="o">&gt;</code> <code class="p">{</code>
  <code class="nx">center?</code>: <code class="nx">LngLatLike</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">type</code> <code class="nx">LngLatBounds</code> <code class="o">=</code>
  <code class="p">{</code><code class="nx">northeast</code>: <code class="nx">LngLatLike</code><code class="p">,</code> <code class="nx">southwest</code>: <code class="nx">LngLatLike</code><code class="p">}</code> <code class="o">|</code>
  <code class="p">[</code><code class="nx">LngLatLike</code><code class="p">,</code> <code class="nx">LngLatLike</code><code class="p">]</code> <code class="o">|</code>
  <code class="p">[</code><code class="kt">number</code><code class="p">,</code> <code class="kt">number</code><code class="p">,</code> <code class="kt">number</code><code class="p">,</code> <code class="kt">number</code><code class="p">];</code>

<code class="kd">declare</code> <code class="kd">function</code> <code class="nx">setCamera</code><code class="p">(</code><code class="nx">camera</code>: <code class="nx">CameraOptions</code><code class="p">)</code><code class="o">:</code> <code class="kd">void</code><code class="p">;</code>
<code class="kd">declare</code> <code class="kd">function</code> <code class="nx">viewportForBounds</code><code class="p">(</code><code class="nx">bounds</code>: <code class="nx">LngLatBounds</code><code class="p">)</code><code class="o">:</code> <code class="nx">Camera</code><code class="p">;</code></pre>

            <p class="author1">The loose <code class="calibre18">CameraOptions</code> type adapts the stricter <code
                class="calibre18">Camera</code> type (<a href="#calibre_link-759" class="calibre9">Item 14</a>).</p>

            <p class="author1">Using <code class="calibre18">Partial&lt;Camera&gt;</code> as the parameter type in <code
                class="calibre18">setCamera</code> would not work here since you do want to allow <code
                class="calibre18">LngLatLike</code> objects for the <code class="calibre18">center</code> property. And
              you can’t write "<code class="calibre18">CameraOptions extends Partial&lt;Camera&gt;</code>" since <code
                class="calibre18">LngLatLike</code> is a superset of <code class="calibre18">LngLat</code>, not a subset
              (<a href="#calibre_link-47" class="calibre9">Item 7</a>). If this seems too complicated, you could also
              write the type out explicitly at the cost of some repetition:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">CameraOptions</code> <code class="p">{</code>
  <code class="nx">center?</code>: <code class="nx">LngLatLike</code><code class="p">;</code>
  <code class="nx">zoom?</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">bearing?</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">pitch?</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">In either case, with these new type declarations the <code
                class="calibre18">focusOnFeature</code> function passes the type checker:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">focusOnFeature</code><code class="p">(</code><code class="nx">f</code>: <code class="nx">Feature</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">bounds</code> <code class="o">=</code> <code class="nx">calculateBoundingBox</code><code class="p">(</code><code class="nx">f</code><code class="p">);</code>
  <code class="kd">const</code> <code class="nx">camera</code> <code class="o">=</code> <code class="nx">viewportForBounds</code><code class="p">(</code><code class="nx">bounds</code><code class="p">);</code>
  <code class="nx">setCamera</code><code class="p">(</code><code class="nx">camera</code><code class="p">);</code>
  <code class="kd">const</code> <code class="p">{</code><code class="nx">center</code><code class="o">:</code> <code class="p">{</code><code class="nx">lat</code><code class="p">,</code> <code class="nx">lng</code><code class="p">},</code> <code class="nx">zoom</code><code class="p">}</code> <code class="o">=</code> <code class="nx">camera</code><code class="p">;</code>  <code class="c">// OK</code>
  <code class="nx">zoom</code><code class="p">;</code>  <code class="c">// Type is number</code>
  <code class="nb">window</code><code class="p">.</code><code class="nx">location</code><code class="p">.</code><code class="nx">search</code> <code class="o">=</code> <code class="s">`?v=@</code><code class="si">${</code><code class="nx">lat</code><code class="si">}</code><code class="s">,</code><code class="si">${</code><code class="nx">lng</code><code class="si">}</code><code class="s">z</code><code class="si">${</code><code class="nx">zoom</code><code class="si">}</code><code class="s">`</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">This time the type of <code class="calibre18">zoom</code> is <code
                class="calibre18">number</code>, rather than <code class="calibre18">number|undefined</code>. The <code
                class="calibre18">viewportForBounds</code> function is now much easier to use. If there were any other
              functions that produced bounds, you would also need to introduce a canonical form and a distinction
              between <code class="calibre18">LngLatBounds</code> and <code class="calibre18">LngLatBoundsLike</code>.
            </p>

            <p class="author1">Is allowing 19 possible forms of bounding box a good design? Perhaps not. But if you’re
              writing type declarations for a library that does this, you need to model its behavior. Just don’t have 19
              return types!</p>








            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-920">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">Input types tend to be broader than output types. Optional properties and union
                      types are more common in parameter types than return types.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">To reuse types between parameters and return types, introduce a canonical form
                      (for return types) and a looser form (for parameters).<a data-primary=""
                        data-startref="TDrobuts04" data-type="indexterm" id="calibre_link-599" class="calibre9"></a><a
                        data-primary="" data-startref="robust04" data-type="indexterm" id="calibre_link-496"
                        class="calibre9"></a><a data-primary="" data-startref="postel04" data-type="indexterm"
                        id="calibre_link-460" class="calibre9"></a><a data-primary="" data-startref="Frobust04"
                        data-type="indexterm" id="calibre_link-287" class="calibre9"></a></p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>













        <section data-pdf-bookmark="Item 30: Don’t Repeat Type Information in Documentation" data-type="sect1"
          class="praise">
          <div class="praise" id="calibre_link-9">
            <h1 class="calibre16">Item 30: Don’t Repeat Type Information in Documentation</h1>

            <p class="author1">What’s<a data-primary="type design" data-secondary="type information in documentation"
                data-type="indexterm" id="calibre_link-600" class="calibre9"></a><a
                data-primary="documentation, type information in" data-type="indexterm" id="calibre_link-215"
                class="calibre9"></a> wrong with this code?</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="c">/**</code>
<code class="c"> * Returns a string with the foreground color.</code>
<code class="c"> * Takes zero or one arguments. With no arguments, returns the</code>
<code class="c"> * standard foreground color. With one argument, returns the foreground color</code>
<code class="c"> * for a particular page.</code>
<code class="c"> */</code>
<code class="kd">function</code> <code class="nx">getForegroundColor</code><code class="p">(</code><code class="nx">page?</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">page</code> <code class="o">===</code> <code class="s">'login'</code> <code class="o">?</code> <code class="p">{</code><code class="nx">r</code>: <code class="nx">127</code><code class="p">,</code> <code class="nx">g</code>: <code class="nx">127</code><code class="p">,</code> <code class="nx">b</code>: <code class="nx">127</code><code class="p">}</code> <code class="o">:</code> <code class="p">{</code><code class="nx">r</code>: <code class="nx">0</code><code class="p">,</code> <code class="nx">g</code>: <code class="nx">0</code><code class="p">,</code> <code class="nx">b</code>: <code class="nx">0</code><code class="p">};</code>
<code class="p">}</code></pre>

            <p class="author1">The code and the comment disagree! Without more context it’s hard to say which is right,
              but something is clearly amiss. As a professor of mine used to say, “when your code and your comments
              disagree, they’re both wrong!”</p>

            <p class="author1">Let’s assume that the code represents the desired behavior. There are a few issues with
              this comment:</p>

            <ul class="printings">
              <li class="calibre12">
                <p class="author1">It says that the function returns the color as a <code
                    class="calibre18">string</code> when it actually returns an <code class="calibre18">{r, g, b}</code>
                  object.</p>
              </li>
              <li class="calibre12">
                <p class="author1">It explains that the function takes zero or one arguments, which is already clear
                  from the type signature.</p>
              </li>
              <li class="calibre12">
                <p class="author1">It’s needlessly wordy: the comment is longer than the function declaration <em
                    class="calibre3">and</em> implementation!</p>
              </li>
            </ul>

            <p class="author1">TypeScript’s type annotation system is designed to be compact, descriptive, and readable.
              Its developers are language experts with decades of experience. It’s almost certainly a better way to
              express the types of your function’s inputs and outputs than your prose!</p>

            <p class="author1">And because your type annotations are checked by the TypeScript compiler, they’ll never
              get out of sync with the implementation. Perhaps <code class="calibre18">getForegroundColor</code> used to
              return a string but was later changed to return an object. The person who made the change might have
              forgotten to update the long comment.</p>

            <p class="author1">Nothing stays in sync unless it’s forced to. With type annotations, TypeScript’s type
              checker is that force! If you put type information in annotations and not in documentation, you greatly
              increase your confidence that it will remain correct as the code evolves.</p>

            <p class="author1">A better comment might look like this:</p>

            <pre data-code-language="ts" data-type="programlisting" id="calibre_link-921" class="calibre17"><code class="c">/** Get the foreground color for the application or a specific page. */</code>
<code class="kd">function</code> <code class="nx">getForegroundColor</code><code class="p">(</code><code class="nx">page?</code>: <code class="kd">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">Color</code> <code class="p">{</code>
  <code class="c">// ...</code>
<code class="p">}</code></pre>

            <p class="author1">If you want to describe a particular parameter, use an <code
                class="calibre18">@param</code> JSDoc annotation. See <a href="#calibre_link-49" class="calibre9">Item
                48</a> for more on this.</p>

            <p class="author1">Comments about a lack of mutation are also suspect. Don’t just say that you don’t modify
              a parameter:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="c">/** Does not modify nums */</code>
<code class="kd">function</code> <code class="nx">sort</code><code class="p">(</code><code class="nx">nums</code>: <code class="nx">number</code><code class="p">[])</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">}</code></pre>

            <p class="author1">Instead, declare it <code class="calibre18">readonly</code> (<a href="#calibre_link-814"
                class="calibre9">Item 17</a>) and let TypeScript enforce the contract:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">function</code> <code class="nx">sort</code><code class="p">(</code><code class="nx">nums</code>: <code class="nx">readonly</code> <code class="kt">number</code><code class="p">[])</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">}</code></pre>

            <p class="author1">What’s<a data-primary="variables" data-secondary="including units in variable names"
                data-type="indexterm" id="calibre_link-740" class="calibre9"></a> true for comments is also true for
              variable names. Avoid putting types in them: rather than naming a variable <code
                class="calibre18">ageNum</code>, name it <code class="calibre18">age</code> and make sure it’s really a
              <code class="calibre18">number</code>.
            </p>

            <p class="author1">An exception to this is for numbers with units. If it’s not clear what the units are, you
              may want to include them in a variable or property name. For instance, <code
                class="calibre18">timeMs</code> is a much clearer name than just <code class="calibre18">time</code>,
              and <code class="calibre18">temperatureC</code> is a much clearer name than <code
                class="calibre18">temperature</code>. <a href="#calibre_link-762" class="calibre9">Item 37</a> describes
              “brands,” which provide a more type-safe approach to modeling units.</p>








            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-922">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">Avoid repeating type information in comments and variable names. In the best case
                      it is duplicative of type declarations, and in the worst it will lead to conflicting information.
                    </p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Consider including units in variable names if they aren’t clear from the type
                      (e.g., <code class="calibre18">timeMs</code> or <code class="calibre18">temperatureC</code>).</p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>













        <section data-pdf-bookmark="Item 31: Push Null Values to the Perimeter of Your Types" data-type="sect1"
          class="praise">
          <div class="praise" id="calibre_link-799">
            <h1 class="calibre16">Item 31: Push Null Values to the Perimeter of Your Types</h1>

            <p class="author1">When<a data-primary="type design" data-secondary="null values" data-type="indexterm"
                id="calibre_link-596" class="calibre9"></a><a data-primary="null values" data-type="indexterm"
                id="calibre_link-432" class="calibre9"></a><a data-primary="values"
                data-secondary="null values versus non-null values" data-type="indexterm" id="calibre_link-729"
                class="calibre9"></a><a data-primary="strictNullChecks" data-type="indexterm" id="calibre_link-510"
                class="calibre9"></a><a data-primary="non-null values" data-type="indexterm" id="calibre_link-428"
                class="calibre9"></a> you first turn on <code class="calibre18">strictNullChecks</code>, it may seem as
              though you have to add scores of if statements checking for <code class="calibre18">null</code> and <code
                class="calibre18">undefined</code> values throughout your code. This is often because the relationships
              between null and non-null values are implicit: when variable A is non-null, you know that variable B is
              also non-null and vice versa. These implicit relationships are confusing both for human readers of your
              code and for the type checker.</p>

            <p class="author1">Values are easier to work with when they’re either completely null or completely
              non-null, rather than a mix. You can model this by pushing the null values out to the perimeter of your
              structures.</p>

            <p class="author1">Suppose you want to calculate the min and max of a list of numbers. We’ll call this the
              “extent.” Here’s an attempt:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">extent</code><code class="p">(</code><code class="nx">nums</code>: <code class="nx">number</code><code class="p">[])</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">min</code><code class="p">,</code> <code class="nx">max</code><code class="p">;</code>
  <code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="nx">num</code> <code class="nx">of</code> <code class="nx">nums</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">min</code><code class="p">)</code> <code class="p">{</code>
      <code class="nx">min</code> <code class="o">=</code> <code class="nx">num</code><code class="p">;</code>
      <code class="nx">max</code> <code class="o">=</code> <code class="nx">num</code><code class="p">;</code>
    <code class="p">}</code> <code class="kd">else</code> <code class="p">{</code>
      <code class="nx">min</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">min</code><code class="p">(</code><code class="nx">min</code><code class="p">,</code> <code class="nx">num</code><code class="p">);</code>
      <code class="nx">max</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">max</code><code class="p">(</code><code class="nx">max</code><code class="p">,</code> <code class="nx">num</code><code class="p">);</code>
    <code class="p">}</code>
  <code class="p">}</code>
  <code class="kd">return</code> <code class="p">[</code><code class="nx">min</code><code class="p">,</code> <code class="nx">max</code><code class="p">];</code>
<code class="p">}</code></pre>

            <p class="author1">The code type checks (without <code class="calibre18">strictNullChecks</code>) and has an
              inferred return type of <code class="calibre18">number[]</code>, which seems fine. But it has a bug and a
              design flaw:</p>

            <ul class="printings">
              <li class="calibre12">
                <p class="author1">If the min or max is zero, it may get overridden. For example, <code
                    class="calibre18">extent([0, 1, 2])</code> will return <code class="calibre18">[1, 2]</code> rather
                  than <code class="calibre18">[0, 2]</code>.</p>
              </li>
              <li class="calibre12">
                <p class="author1">If the <code class="calibre18">nums</code> array is empty, the function will return
                  <code class="calibre18">[undefined, undefined]</code>. This sort of object with several <code
                    class="calibre18">undefined</code>s will be difficult for clients to work with and is exactly the
                  sort of type that this item discourages. We know from reading the source code that <code
                    class="calibre18">min</code> and <code class="calibre18">max</code> will either both be <code
                    class="calibre18">undefined</code> or neither, but that information isn’t represented in the type
                  system.
                </p>
              </li>
            </ul>

            <p class="author1">Turning on <code class="calibre18">strictNullChecks</code> makes both of these issues
              more apparent:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">extent</code><code class="p">(</code><code class="nx">nums</code>: <code class="nx">number</code><code class="p">[])</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">min</code><code class="p">,</code> <code class="nx">max</code><code class="p">;</code>
  <code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="nx">num</code> <code class="nx">of</code> <code class="nx">nums</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">min</code><code class="p">)</code> <code class="p">{</code>
      <code class="nx">min</code> <code class="o">=</code> <code class="nx">num</code><code class="p">;</code>
      <code class="nx">max</code> <code class="o">=</code> <code class="nx">num</code><code class="p">;</code>
    <code class="p">}</code> <code class="kd">else</code> <code class="p">{</code>
      <code class="nx">min</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">min</code><code class="p">(</code><code class="nx">min</code><code class="p">,</code> <code class="nx">num</code><code class="p">);</code>
      <code class="nx">max</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">max</code><code class="p">(</code><code class="nx">max</code><code class="p">,</code> <code class="nx">num</code><code class="p">);</code>
                  <code class="c">// ~~~ Argument of type 'number | undefined' is not</code>
                  <code class="c">//     assignable to parameter of type 'number'</code>
    <code class="p">}</code>
  <code class="p">}</code>
  <code class="kd">return</code> <code class="p">[</code><code class="nx">min</code><code class="p">,</code> <code class="nx">max</code><code class="p">];</code>
<code class="p">}</code></pre>

            <p class="author1">The return type of <code class="calibre18">extent</code> is now inferred as <code
                class="calibre18">(number | undefined)[]</code>, which makes the design flaw more apparent. This is
              likely to manifest as a type error wherever you call <code class="calibre18">extent</code>:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="p">[</code><code class="nx">min</code><code class="p">,</code> <code class="nx">max</code><code class="p">]</code> <code class="o">=</code> <code class="nx">extent</code><code class="p">([</code><code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">]);</code>
<code class="kd">const</code> <code class="nx">span</code> <code class="o">=</code> <code class="nx">max</code> <code class="o">-</code> <code class="nx">min</code><code class="p">;</code>
          <code class="c">// ~~~   ~~~ Object is possibly 'undefined'</code></pre>

            <p class="author1">The error in the implementation of <code class="calibre18">extent</code> comes about
              because you’ve excluded <code class="calibre18">undefined</code> as a value for <code
                class="calibre18">min</code> but not <code class="calibre18">max</code>. The two are initialized
              together, but this information isn’t present in the type system. You could make it go away by adding a
              check for <code class="calibre18">max</code>, too, but this would be doubling down on the bug.</p>

            <p class="author1">A better solution is to put the min and max in the same object and make this object
              either fully <code class="calibre18">null</code> or fully non-<code class="calibre18">null</code>:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">extent</code><code class="p">(</code><code class="nx">nums</code>: <code class="nx">number</code><code class="p">[])</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">result</code><code class="o">:</code> <code class="p">[</code><code class="kt">number</code><code class="p">,</code> <code class="kt">number</code><code class="p">]</code> <code class="o">|</code> <code class="nx">null</code><code class="o"> = </code><code class="kd">null</code><code class="p">;</code>
  <code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="nx">num</code> <code class="nx">of</code> <code class="nx">nums</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">result</code><code class="p">)</code> <code class="p">{</code>
      <code class="nx">result</code> <code class="o">=</code> <code class="p">[</code><code class="nx">num</code><code class="p">,</code> <code class="nx">num</code><code class="p">];</code>
    <code class="p">}</code> <code class="kd">else</code> <code class="p">{</code>
      <code class="nx">result</code> <code class="o">=</code> <code class="p">[</code><code class="nb">Math</code><code class="p">.</code><code class="nx">min</code><code class="p">(</code><code class="nx">num</code><code class="p">,</code> <code class="nx">result</code><code class="p">[</code><code class="mi">0</code><code class="p">]),</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">max</code><code class="p">(</code><code class="nx">num</code><code class="p">,</code> <code class="nx">result</code><code class="p">[</code><code class="mi">1</code><code class="p">])];</code>
    <code class="p">}</code>
  <code class="p">}</code>
  <code class="kd">return</code> <code class="nx">result</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">The return type is now <code class="calibre18">[number, number] | null</code>, which is
              easier for clients to work with. The min and max can be retrieved with either a non-null assertion:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">const</code> <code class="p">[</code><code class="nx">min</code><code class="p">,</code> <code class="nx">max</code><code class="p">]</code> <code class="o">=</code> <code class="nx">extent</code><code class="p">([</code><code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">])</code><code class="o">!</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">span</code> <code class="o">=</code> <code class="nx">max</code> <code class="o">-</code> <code class="nx">min</code><code class="p">;</code>  <code class="c">// OK</code></pre>

            <p class="author1">or a single check:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">range</code> <code class="o">=</code> <code class="nx">extent</code><code class="p">([</code><code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">]);</code>
<code class="kd">if</code> <code class="p">(</code><code class="nx">range</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="p">[</code><code class="nx">min</code><code class="p">,</code> <code class="nx">max</code><code class="p">]</code> <code class="o">=</code> <code class="nx">range</code><code class="p">;</code>
  <code class="kd">const</code> <code class="nx">span</code> <code class="o">=</code> <code class="nx">max</code> <code class="o">-</code> <code class="nx">min</code><code class="p">;</code>  <code class="c">// OK</code>
<code class="p">}</code></pre>

            <p class="author1">By using a single object to track the extent, we’ve improved our design, helped
              TypeScript understand the relationship between null values, and fixed the bug: the <code
                class="calibre18">if (!result)</code> check is now problem free.</p>

            <p class="author1">A mix of null and non-null values can also lead to problems in classes. For instance,
              suppose you have a class that represents both a user and their posts on a forum:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">class</code> <code class="nx">UserPosts</code> <code class="p">{</code>
  <code class="nx">user</code>: <code class="nx">UserInfo</code> <code class="o">|</code> <code class="kd">null</code><code class="p">;</code>
  <code class="nx">posts</code>: <code class="nx">Post</code><code class="p">[]</code> <code class="o">|</code> <code class="kd">null</code><code class="p">;</code>

  <code class="kd">constructor</code><code class="p">()</code> <code class="p">{</code>
    <code class="kd">this</code><code class="p">.</code><code class="nx">user</code> <code class="o">=</code> <code class="kd">null</code><code class="p">;</code>
    <code class="kd">this</code><code class="p">.</code><code class="nx">posts</code> <code class="o">=</code> <code class="kd">null</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="kd">async</code> <code class="nx">init</code><code class="p">(</code><code class="nx">userId</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">return</code> <code class="nx">Promise</code><code class="p">.</code><code class="nx">all</code><code class="p">([</code>
      <code class="kd">async</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="kd">this</code><code class="p">.</code><code class="nx">user</code> <code class="o">=</code> <code class="kd">await</code> <code class="nx">fetchUser</code><code class="p">(</code><code class="nx">userId</code><code class="p">),</code>
      <code class="kd">async</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="kd">this</code><code class="p">.</code><code class="nx">posts</code> <code class="o">=</code> <code class="kd">await</code> <code class="nx">fetchPostsForUser</code><code class="p">(</code><code class="nx">userId</code><code class="p">)</code>
    <code class="p">]);</code>
  <code class="p">}</code>

  <code class="nx">getUserName() {</code>
    <code class="c">// ...?</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

            <p class="author1">While the two network requests are loading, the <code class="calibre18">user</code> and
              <code class="calibre18">posts</code> properties will be <code class="calibre18">null</code>. At any time,
              they might both be <code class="calibre18">null</code>, one might be <code class="calibre18">null</code>,
              or they might both be non-<code class="calibre18">null</code>. There are four possibilities. This
              complexity will seep into every method on the class. This design is almost certain to lead to confusion, a
              proliferation of <code class="calibre18">null</code> checks, and bugs.
            </p>

            <p class="author1">A better design would wait until all the data used by the class is available:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">class</code> <code class="nx">UserPosts</code> <code class="p">{</code>
  <code class="nx">user</code>: <code class="nx">UserInfo</code><code class="p">;</code>
  <code class="nx">posts</code>: <code class="nx">Post</code><code class="p">[];</code>

  <code class="kd">constructor</code><code class="p">(</code><code class="nx">user</code>: <code class="nx">UserInfo</code><code class="p">,</code> <code class="nx">posts</code>: <code class="nx">Post</code><code class="p">[])</code> <code class="p">{</code>
    <code class="kd">this</code><code class="p">.</code><code class="nx">user</code> <code class="o">=</code> <code class="nx">user</code><code class="p">;</code>
    <code class="kd">this</code><code class="p">.</code><code class="nx">posts</code> <code class="o">=</code> <code class="nx">posts</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="kd">static</code> <code class="kd">async</code> <code class="nx">init</code><code class="p">(</code><code class="nx">userId</code>: <code class="kd">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">Promise</code><code class="o">&lt;</code><code class="nx">UserPosts</code><code class="o">&gt;</code> <code class="p">{</code>
    <code class="kd">const</code> <code class="p">[</code><code class="nx">user</code><code class="p">,</code> <code class="nx">posts</code><code class="p">]</code> <code class="o">=</code> <code class="kd">await</code> <code class="nx">Promise</code><code class="p">.</code><code class="nx">all</code><code class="p">([</code>
      <code class="nx">fetchUser</code><code class="p">(</code><code class="nx">userId</code><code class="p">),</code>
      <code class="nx">fetchPostsForUser</code><code class="p">(</code><code class="nx">userId</code><code class="p">)</code>
    <code class="p">]);</code>
    <code class="kd">return</code> <code class="kd">new</code> <code class="nx">UserPosts</code><code class="p">(</code><code class="nx">user</code><code class="p">,</code> <code class="nx">posts</code><code class="p">);</code>
  <code class="p">}</code>

  <code class="nx">getUserName() {</code>
    <code class="kd">return</code> <code class="kd">this</code><code class="p">.</code><code class="nx">user</code><code class="p">.</code><code class="nx">name</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

            <p class="author1">Now the <code class="calibre18">UserPosts</code> class is fully non-<code
                class="calibre18">null</code>, and it’s easy to write correct methods on it. Of course, if you need to
              perform operations while data is partially loaded, then you’ll need to deal with the multiplicity of <code
                class="calibre18">null</code> and non-<code class="calibre18">null</code> states.</p>

            <p class="author1">(Don’t be tempted to replace nullable properties<a data-primary="Promises"
                data-type="indexterm" id="calibre_link-464" class="calibre9"></a> with Promises. This tends to lead to
              even more confusing code and forces all your methods to be async. Promises clarify the code that loads
              data but tend to have the opposite effect on the class that uses that data.)</p>








            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-923">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">Avoid designs in which one value being <code class="calibre18">null</code> or not
                      <code class="calibre18">null</code> is implicitly related to another value being <code
                        class="calibre18">null</code> or not <code class="calibre18">null</code>.
                    </p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Push <code class="calibre18">null</code> values to the perimeter of your API by
                      making larger objects either <code class="calibre18">null</code> or fully non-<code
                        class="calibre18">null</code>. This will make code clearer both for human readers and for the
                      type checker.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Consider creating a fully non-<code class="calibre18">null</code> class and
                      constructing it when all values are available.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">While <code class="calibre18">strictNullChecks</code> may flag many issues in
                      your code, it’s indispensable for surfacing the behavior of functions with respect to null
                      values.<a data-primary="" data-startref="nnull04" data-type="indexterm" id="calibre_link-429"
                        class="calibre9"></a><a data-primary="" data-startref="strict04" data-type="indexterm"
                        id="calibre_link-511" class="calibre9"></a><a data-primary="" data-startref="Vnull04"
                        data-type="indexterm" id="calibre_link-730" class="calibre9"></a><a data-primary=""
                        data-startref="null04" data-type="indexterm" id="calibre_link-433" class="calibre9"></a><a
                        data-primary="" data-startref="TDnull04" data-type="indexterm" id="calibre_link-597"
                        class="calibre9"></a></p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>













        <section data-pdf-bookmark="Item 32: Prefer Unions of Interfaces to Interfaces of Unions" data-type="sect1"
          class="praise">
          <div class="praise" id="calibre_link-811">
            <h1 class="calibre16">Item 32: Prefer Unions of Interfaces to Interfaces of Unions</h1>

            <p class="author1">If<a data-primary="type design"
                data-secondary="unions of interfaces versus interfaces of unions" data-type="indexterm"
                id="calibre_link-603" class="calibre9"></a><a data-primary="tagged unions"
                data-secondary="unions of interfaces versus interfaces of unions" data-type="indexterm"
                id="calibre_link-530" class="calibre9"></a><a data-primary="interface construct"
                data-secondary="unions of interfaces versus interfaces of unions" data-type="indexterm"
                id="calibre_link-328" class="calibre9"></a><a data-primary="union types"
                data-secondary="unions of interfaces versus interfaces of unions" data-type="indexterm"
                id="calibre_link-712" class="calibre9"></a> you create an interface whose properties are union types,
              you should ask whether the type would make more sense as a union of more precise interfaces.</p>

            <p class="author1">Suppose you’re building a vector drawing program and want to define an interface for
              layers with specific geometry types:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Layer</code> <code class="p">{</code>
  <code class="nx">layout</code>: <code class="nx">FillLayout</code> <code class="o">|</code> <code class="nx">LineLayout</code> <code class="o">|</code> <code class="nx">PointLayout</code><code class="p">;</code>
  <code class="nx">paint</code>: <code class="nx">FillPaint</code> <code class="o">|</code> <code class="nx">LinePaint</code> <code class="o">|</code> <code class="nx">PointPaint</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">The <code class="calibre18">layout</code> field controls how and where the shapes are
              drawn (rounded corners? straight?), while the <code class="calibre18">paint</code> field controls styles
              (is the line blue? thick? thin? dashed?).</p>

            <p class="author1">Would it make sense to have a layer whose <code class="calibre18">layout</code> is <code
                class="calibre18">LineLayout</code> but whose <code class="calibre18">paint</code> property is <code
                class="calibre18">FillPaint</code>? Probably not. Allowing this possibility makes using the library more
              error-prone and makes this interface difficult to work with.</p>

            <p class="author1">A better way to model this is with separate interfaces for each type of layer:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">interface</code> <code class="nx">FillLayer</code> <code class="p">{</code>
  <code class="nx">layout</code>: <code class="nx">FillLayout</code><code class="p">;</code>
  <code class="nx">paint</code>: <code class="nx">FillPaint</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">interface</code> <code class="nx">LineLayer</code> <code class="p">{</code>
  <code class="nx">layout</code>: <code class="nx">LineLayout</code><code class="p">;</code>
  <code class="nx">paint</code>: <code class="nx">LinePaint</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">interface</code> <code class="nx">PointLayer</code> <code class="p">{</code>
  <code class="nx">layout</code>: <code class="nx">PointLayout</code><code class="p">;</code>
  <code class="nx">paint</code>: <code class="nx">PointPaint</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">type</code> <code class="nx">Layer</code> <code class="o">=</code> <code class="nx">FillLayer</code> <code class="o">|</code> <code class="nx">LineLayer</code> <code class="o">|</code> <code class="nx">PointLayer</code><code class="p">;</code></pre>

            <p class="author1">By defining <code class="calibre18">Layer</code> in this way, you’ve excluded the
              possibility of mixed <code class="calibre18">layout</code> and <code class="calibre18">paint</code>
              properties. This is an example of following <a href="#calibre_link-761" class="calibre9">Item 28</a>’s
              advice to prefer types that only represent valid states.</p>

            <p class="author1">The most common example of this pattern is the “tagged union” (or “discriminated union”).
              In this case one of the properties is a union of string literal types:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Layer</code> <code class="p">{</code>
  <code class="nx">type</code>: <code class="s">'fill'</code> <code class="o">|</code> <code class="s">'line'</code> <code class="o">|</code> <code class="s">'point'</code><code class="p">;</code>
  <code class="nx">layout</code>: <code class="nx">FillLayout</code> <code class="o">|</code> <code class="nx">LineLayout</code> <code class="o">|</code> <code class="nx">PointLayout</code><code class="p">;</code>
  <code class="nx">paint</code>: <code class="nx">FillPaint</code> <code class="o">|</code> <code class="nx">LinePaint</code> <code class="o">|</code> <code class="nx">PointPaint</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">As before, would it make sense to have <code class="calibre18">type: 'fill'</code> but
              then a <code class="calibre18">LineLayout</code> and <code class="calibre18">PointPaint</code>? Certainly
              not. Convert <code class="calibre18">Layer</code> to a union of interfaces to exclude this possibility:
            </p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">interface</code> <code class="nx">FillLayer</code> <code class="p">{</code>
  <code class="nx">type</code>: <code class="s">'fill'</code><code class="p">;</code>
  <code class="nx">layout</code>: <code class="nx">FillLayout</code><code class="p">;</code>
  <code class="nx">paint</code>: <code class="nx">FillPaint</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">interface</code> <code class="nx">LineLayer</code> <code class="p">{</code>
  <code class="nx">type</code>: <code class="s">'line'</code><code class="p">;</code>
  <code class="nx">layout</code>: <code class="nx">LineLayout</code><code class="p">;</code>
  <code class="nx">paint</code>: <code class="nx">LinePaint</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">interface</code> <code class="nx">PointLayer</code> <code class="p">{</code>
  <code class="nx">type</code>: <code class="s">'paint'</code><code class="p">;</code>
  <code class="nx">layout</code>: <code class="nx">PointLayout</code><code class="p">;</code>
  <code class="nx">paint</code>: <code class="nx">PointPaint</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">type</code> <code class="nx">Layer</code> <code class="o">=</code> <code class="nx">FillLayer</code> <code class="o">|</code> <code class="nx">LineLayer</code> <code class="o">|</code> <code class="nx">PointLayer</code><code class="p">;</code></pre>

            <p class="author1">The <code class="calibre18">type</code> property is the “tag” and can be used to
              determine which type of <code class="calibre18">Layer</code> you’re working with at runtime. TypeScript is
              also able to narrow the type of <code class="calibre18">Layer</code> based on the tag:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">drawLayer</code><code class="p">(</code><code class="nx">layer</code>: <code class="nx">Layer</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">layer</code><code class="p">.</code><code class="nx">type</code> <code class="o">===</code> <code class="s">'fill'</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">const</code> <code class="p">{</code><code class="nx">paint</code><code class="p">}</code> <code class="o">=</code> <code class="nx">layer</code><code class="p">;</code>  <code class="c">// Type is FillPaint</code>
    <code class="kd">const</code> <code class="p">{</code><code class="nx">layout</code><code class="p">}</code> <code class="o">=</code> <code class="nx">layer</code><code class="p">;</code>  <code class="c">// Type is FillLayout</code>
  <code class="p">}</code> <code class="kd">else</code> <code class="kd">if</code> <code class="p">(</code><code class="nx">layer</code><code class="p">.</code><code class="nx">type</code> <code class="o">===</code> <code class="s">'line'</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">const</code> <code class="p">{</code><code class="nx">paint</code><code class="p">}</code> <code class="o">=</code> <code class="nx">layer</code><code class="p">;</code>  <code class="c">// Type is LinePaint</code>
    <code class="kd">const</code> <code class="p">{</code><code class="nx">layout</code><code class="p">}</code> <code class="o">=</code> <code class="nx">layer</code><code class="p">;</code>  <code class="c">// Type is LineLayout</code>
  <code class="p">}</code> <code class="kd">else</code> <code class="p">{</code>
    <code class="kd">const</code> <code class="p">{</code><code class="nx">paint</code><code class="p">}</code> <code class="o">=</code> <code class="nx">layer</code><code class="p">;</code>  <code class="c">// Type is PointPaint</code>
    <code class="kd">const</code> <code class="p">{</code><code class="nx">layout</code><code class="p">}</code> <code class="o">=</code> <code class="nx">layer</code><code class="p">;</code>  <code class="c">// Type is PointLayout</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

            <p class="author1">By correctly modeling the relationship between the properties in this type, you help
              TypeScript check your code’s correctness. The same code involving the initial <code
                class="calibre18">Layer</code> definition would have been cluttered with type assertions.</p>

            <p class="author1">Because they work so well with TypeScript’s type checker, tagged unions are ubiquitous in
              TypeScript code. Recognize this pattern and apply it when you can. If you can represent a data type in
              TypeScript with a tagged union, it’s usually a good idea to do so. If you think of optional fields as a
              union of their type and <code class="calibre18">undefined</code>, then they fit this pattern as well.
              Consider this type:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Person</code> <code class="p">{</code>
  <code class="nx">name</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="c">// These will either both be present or not be present</code>
  <code class="nx">placeOfBirth?</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">dateOfBirth?</code>: <code class="nx">Date</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">The comment with type information is a strong sign that there might be a problem (<a
                href="#calibre_link-9" class="calibre9">Item 30</a>). There is a relationship between the <code
                class="calibre18">placeOfBirth</code> and <code class="calibre18">dateOfBirth</code> fields that you
              haven’t told TypeScript about.</p>

            <p class="author1">A better way to model this is to move both of these properties into a single object. This
              is akin to moving <code class="calibre18">null</code> values to the perimeter (<a href="#calibre_link-799"
                class="calibre9">Item 31</a>):</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Person</code> <code class="p">{</code>
  <code class="nx">name</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">birth</code><code class="o">?:</code> <code class="p">{</code>
    <code class="nx">place</code>: <code class="kd">string</code><code class="p">;</code>
    <code class="nx">date</code>: <code class="nx">Date</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

            <p class="author1">Now<a data-primary="Turing, Alan" data-type="indexterm" id="calibre_link-554"
                class="calibre9"></a> TypeScript complains about values with a place but no date of birth:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">alanT</code>: <code class="kd">Person</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">name</code><code class="o">:</code> <code class="s">'Alan Turing'</code><code class="p">,</code>
  <code class="nx">birth</code><code class="o">:</code> <code class="p">{</code>
<code class="c">// ~~~~ Property 'date' is missing in type</code>
<code class="c">//      '{ place: string; }' but required in type</code>
<code class="c">//      '{ place: string; date: Date; }'</code>
    <code class="nx">place</code><code class="o">:</code> <code class="s">'London'</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

            <p class="author1">Additionally, a function that takes a <code class="calibre18">Person</code> object only
              needs to do a single check:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">eulogize</code><code class="p">(</code><code class="nx">p</code>: <code class="kd">Person</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">p</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code>
  <code class="kd">const</code> <code class="p">{</code><code class="nx">birth</code><code class="p">}</code> <code class="o">=</code> <code class="nx">p</code><code class="p">;</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">birth</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s">`was born on </code><code class="si">${</code><code class="nx">birth</code><code class="p">.</code><code class="nx">date</code><code class="si">}</code><code class="s"> in </code><code class="si">${</code><code class="nx">birth</code><code class="p">.</code><code class="nx">place</code><code class="si">}</code><code class="s">.`</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

            <p class="author1">If the structure of the type is outside your control (e.g., it’s coming from an API),
              then you can still model the relationship between these fields using a now-familiar union of interfaces:
            </p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">interface</code> <code class="nx">Name</code> <code class="p">{</code>
  <code class="nx">name</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">interface</code> <code class="nx">PersonWithBirth</code> <code class="kd">extends</code> <code class="nx">Name</code> <code class="p">{</code>
  <code class="nx">placeOfBirth</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">dateOfBirth</code>: <code class="nx">Date</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">type</code> <code class="nx">Person</code> <code class="o">=</code> <code class="nx">Name</code> <code class="o">|</code> <code class="nx">PersonWithBirth</code><code class="p">;</code></pre>

            <p class="author1">Now you get some of the same benefits as with the nested object:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">eulogize</code><code class="p">(</code><code class="nx">p</code>: <code class="kd">Person</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="s">'placeOfBirth'</code> <code class="kd">in</code> <code class="nx">p</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">p</code> <code class="c">// Type is PersonWithBirth</code>
    <code class="kd">const</code> <code class="p">{</code><code class="nx">dateOfBirth</code><code class="p">}</code> <code class="o">=</code> <code class="nx">p</code>  <code class="c">// OK, type is Date</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

            <p class="author1">In both cases, the type definition makes the relationship between the properties more
              clear.</p>








            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-924">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">Interfaces with multiple properties that are union types are often a mistake
                      because they obscure the relationships between these properties.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Unions of interfaces are more precise and can be understood by TypeScript.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Consider adding a “tag” to your structure to facilitate TypeScript’s control flow
                      analysis. Because they are so well supported, tagged unions are ubiquitous in TypeScript code.<a
                        data-primary="" data-startref="union04" data-type="indexterm" id="calibre_link-713"
                        class="calibre9"></a><a data-primary="" data-startref="inter04" data-type="indexterm"
                        id="calibre_link-329" class="calibre9"></a><a data-primary="" data-startref="tunion04"
                        data-type="indexterm" id="calibre_link-531" class="calibre9"></a><a data-primary=""
                        data-startref="TDunion04" data-type="indexterm" id="calibre_link-604" class="calibre9"></a></p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>













        <section data-pdf-bookmark="Item 33: Prefer More Precise Alternatives to String Types" data-type="sect1"
          class="praise">
          <div class="praise" id="calibre_link-812">
            <h1 class="calibre16">Item 33: Prefer More Precise Alternatives to String Types</h1>

            <p class="author1">The<a data-primary="type design" data-secondary="alternatives to string types"
                data-type="indexterm" id="calibre_link-585" class="calibre9"></a><a
                data-primary="string types, alternatives to" data-type="indexterm" id="calibre_link-514"
                class="calibre9"></a> domain of the <code class="calibre18">string</code> type is big: <code
                class="calibre18">"x"</code> and <code class="calibre18">"y"</code> are in it, but so is the complete
              text of <em class="calibre3">Moby Dick</em> (it starts <code class="calibre18">"Call me Ishmael…"</code>
              and is about 1.2 million characters long). When you declare a variable of type <code
                class="calibre18">string</code>, you should ask whether a narrower type would be more appropriate.</p>

            <p class="author1">Suppose you’re building a music collection and want to define a type for an album. Here’s
              an attempt:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Album</code> <code class="p">{</code>
  <code class="nx">artist</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">title</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">releaseDate</code>: <code class="kd">string</code><code class="p">;</code>  <code class="c">// YYYY-MM-DD</code>
  <code class="nx">recordingType</code>: <code class="kd">string</code><code class="p">;</code>  <code class="c">// E.g., "live" or "studio"</code>
<code class="p">}</code></pre>

            <p class="author1">The prevalence of <code class="calibre18">string</code> types and the type information in
              comments (see <a href="#calibre_link-9" class="calibre9">Item 30</a>) are strong indications that this
              <code class="calibre18">interface</code> isn’t quite right. Here’s<a data-primary="Davis, Miles"
                data-type="indexterm" id="calibre_link-202" class="calibre9"></a> what can go wrong:
            </p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">kindOfBlue</code>: <code class="nx">Album</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">artist</code><code class="o">:</code> <code class="s">'Miles Davis'</code><code class="p">,</code>
  <code class="nx">title</code><code class="o">:</code> <code class="s">'Kind of Blue'</code><code class="p">,</code>
  <code class="nx">releaseDate</code><code class="o">:</code> <code class="s">'August 17th, 1959'</code><code class="p">,</code>  <code class="c">// Oops!</code>
  <code class="nx">recordingType</code><code class="o">:</code> <code class="s">'Studio'</code><code class="p">,</code>  <code class="c">// Oops!</code>
<code class="p">};</code>  <code class="c">// OK</code></pre>

            <p class="author1">The <code class="calibre18">releaseDate</code> field is incorrectly formatted (according
              to the comment) and <code class="calibre18">"Studio"</code> is capitalized where it should be lowercase.
              But these values <em class="calibre3">are</em> both strings, so this object is assignable to <code
                class="calibre18">Album</code> and the type checker doesn’t complain.</p>

            <p class="author1">These broad <code class="calibre18">string</code> types can mask errors for valid <code
                class="calibre18">Album</code> objects, too. For example:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">function</code> <code class="nx">recordRelease</code><code class="p">(</code><code class="nx">title</code>: <code class="kd">string</code><code class="p">,</code> <code class="nx">date</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">}</code>
<code class="nx">recordRelease</code><code class="p">(</code><code class="nx">kindOfBlue</code><code class="p">.</code><code class="nx">releaseDate</code><code class="p">,</code> <code class="nx">kindOfBlue</code><code class="p">.</code><code class="nx">title</code><code class="p">);</code>  <code class="c">// OK, should be error</code></pre>

            <p class="author1">The parameters are reversed in the call to <code class="calibre18">recordRelease</code>
              but both are strings, so the type checker doesn’t complain. Because of the prevalence of <code
                class="calibre18">string</code> types, code like this is sometimes called “stringly typed.”</p>

            <p class="author1">Can you make the types narrower to prevent these sorts of issues? While the complete text
              of <em class="calibre3">Moby Dick</em> would be a ponderous artist name or album title, it’s at least
              plausible. So <code class="calibre18">string</code> is appropriate for these fields. For the <code
                class="calibre18">releaseDate</code> field it’s better to just use a <code class="calibre18">Date</code>
              object and avoid issues around formatting. Finally, for the <code class="calibre18">recordingType</code>
              field, you can define a union type with just two values (you could also use an <code
                class="calibre18">enum</code>, but I generally recommend avoiding these; see <a href="#calibre_link-19"
                class="calibre9">Item 53</a>):</p>

            <pre data-code-language="ts" data-type="programlisting" id="calibre_link-925" class="calibre17"><code class="kd">type</code> <code class="nx">RecordingType</code> <code class="o">=</code> <code class="s">'studio'</code> <code class="o">|</code> <code class="s">'live'</code><code class="p">;</code>

<code class="kd">interface</code> <code class="nx">Album</code> <code class="p">{</code>
  <code class="nx">artist</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">title</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">releaseDate</code>: <code class="nx">Date</code><code class="p">;</code>
  <code class="nx">recordingType</code>: <code class="nx">RecordingType</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">With these changes TypeScript is able to do a more thorough check for errors:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">kindOfBlue</code>: <code class="nx">Album</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">artist</code><code class="o">:</code> <code class="s">'Miles Davis'</code><code class="p">,</code>
  <code class="nx">title</code><code class="o">:</code> <code class="s">'Kind of Blue'</code><code class="p">,</code>
  <code class="nx">releaseDate</code>: <code class="nx">new</code> <code class="nb">Date</code><code class="p">(</code><code class="s">'1959-08-17'</code><code class="p">),</code>
  <code class="nx">recordingType</code><code class="o">:</code> <code class="s">'Studio'</code>
<code class="c">// ~~~~~~~~~~~~ Type '"Studio"' is not assignable to type 'RecordingType'</code>
<code class="p">};</code></pre>

            <p class="author1">There are advantages to this approach beyond stricter checking. First, explicitly
              defining the type ensures that its meaning won’t get lost as it’s passed around. If you wanted to find
              albums of just a certain recording type, for instance, you might define a function like this:</p>

            <pre data-code-language="ts" data-type="programlisting" id="calibre_link-926" class="calibre17"><code class="kd">function</code> <code class="nx">getAlbumsOfType</code><code class="p">(</code><code class="nx">recordingType</code>: <code class="kd">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">Album</code><code class="p">[]</code> <code class="p">{</code>
  <code class="c">// ...</code>
<code class="p">}</code></pre>

            <p class="author1">How does the caller of this function know what <code
                class="calibre18">recordingType</code> is expected to be? It’s just a <code
                class="calibre18">string</code>. The comment explaining that it’s <code
                class="calibre18">"studio"</code> or <code class="calibre18">"live"</code> is hidden in the definition
              of <code class="calibre18">Album</code>, where the user might not think to look.</p>

            <p class="author1">Second, explicitly defining a type allows you attach documentation to it (see <a
                href="#calibre_link-49" class="calibre9">Item 48</a>):</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="c">/** What type of environment was this recording made in?  */</code>
<code class="kd">type</code> <code class="nx">RecordingType</code> <code class="o">=</code> <code class="s">'live'</code> <code class="o">|</code> <code class="s">'studio'</code><code class="p">;</code></pre>

            <p class="author1">When you change <code class="calibre18">getAlbumsOfType</code> to take a <code
                class="calibre18">RecordingType</code>, the caller is able to click through and see the documentation
              (see <a data-type="xref" href="#calibre_link-815" class="calibre9">Figure&nbsp;4-1</a>).</p>

            <figure class="calibre28">
              <div class="figure" id="calibre_link-815">
                <img alt="efts 04in01" src="images/000030.png" class="calibre29" />
                <h6 class="calibre30"><span class="calibre">Figure 4-1. </span>Using a named type instead of string
                  makes it possible to attach documentation to the type that is surfaced in your editor.</h6>
              </div>
            </figure>

            <p class="author1">Another<a data-primary="named types" data-type="indexterm" id="calibre_link-409"
                class="calibre9"></a> common misuse of <code class="calibre18">string</code> is in function parameters.
              Say you want to write a function that pulls out all the values for a single field in an array. The<a
                data-primary="Underscore library" data-type="indexterm" id="calibre_link-707" class="calibre9"></a>
              Underscore library calls this “pluck”:</p>

            <pre data-code-language="js" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">pluck</code><code class="p">(</code><code class="nx">records</code><code class="p">,</code> <code class="nx">key</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">record</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">record</code> <code class="o">=&gt;</code> <code class="nx">record</code><code class="p">[</code><code class="nx">key</code><code class="p">]);</code>
<code class="p">}</code></pre>

            <p class="author1">How would you type this? Here’s an initial attempt:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">pluck</code><code class="p">(</code><code class="nx">record</code>: <code class="nx">any</code><code class="p">[],</code> <code class="nx">key</code>: <code class="kd">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">any</code><code class="p">[]</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">record</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">r</code> <code class="o">=&gt;</code> <code class="nx">r</code><code class="p">[</code><code class="nx">key</code><code class="p">]);</code>
<code class="p">}</code></pre>

            <p class="author1">This<a data-primary="any types" data-secondary="versus inaccurate models"
                data-secondary-sortas="inaccurae models" data-type="indexterm" id="calibre_link-91"
                class="calibre9"></a> type checks but isn’t great. The <code class="calibre18">any</code> types are
              problematic, particularly on the return value (see <a href="#calibre_link-45" class="calibre9">Item
                38</a>). The first step to improving the type signature is introducing a generic type parameter:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">pluck</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">record</code>: <code class="nx">T</code><code class="p">[],</code> <code class="nx">key</code>: <code class="kd">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">any</code><code class="p">[]</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">record</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">r</code> <code class="o">=&gt;</code> <code class="nx">r</code><code class="p">[</code><code class="nx">key</code><code class="p">]);</code>
                      <code class="c">// ~~~~~~ Element implicitly has an 'any' type</code>
                      <code class="c">//        because type '{}' has no index signature</code>
<code class="p">}</code></pre>

            <p class="author1">TypeScript<a data-primary="keyof T" data-type="indexterm" id="calibre_link-374"
                class="calibre9"></a> is now complaining that the <code class="calibre18">string</code> type for <code
                class="calibre18">key</code> is too broad. And it’s right to do so: if you pass in an array of <code
                class="calibre18">Album</code>s then there are only four valid values for <code
                class="calibre18">key</code> (“artist,” “title,” “releaseDate,” and “recordingType”), as opposed to the
              vast set of strings. This is precisely what the <code class="calibre18">keyof Album</code> type is:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">K</code> <code class="o">=</code> <code class="nx">keyof</code> <code class="nx">Album</code><code class="p">;</code>
<code class="c">// Type is "artist" | "title" | "releaseDate" | "recordingType"</code></pre>

            <p class="author1">So the fix is to replace <code class="calibre18">string</code> with <code
                class="calibre18">keyof T</code>:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">pluck</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">record</code>: <code class="nx">T</code><code class="p">[],</code> <code class="nx">key</code>: <code class="nx">keyof</code> <code class="nx">T</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">record</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">r</code> <code class="o">=&gt;</code> <code class="nx">r</code><code class="p">[</code><code class="nx">key</code><code class="p">]);</code>
<code class="p">}</code></pre>

            <p class="author1">This passes the type checker. We’ve also let TypeScript infer the return type. How does
              it do? If you mouse over <code class="calibre18">pluck</code> in your editor, the inferred type is:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">function</code> <code class="nx">pluck</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">record</code>: <code class="nx">T</code><code class="p">[],</code> <code class="nx">key</code>: <code class="nx">keyof</code> <code class="nx">T</code><code class="p">)</code><code class="o">:</code> <code class="nx">T</code><code class="p">[</code><code class="nx">keyof</code> <code class="nx">T</code><code class="p">][]</code></pre>

            <p class="author1"><code class="calibre18">T[keyof T]</code> is the type of any possible value in <code
                class="calibre18">T</code>. If you’re passing in a single string as the <code
                class="calibre18">key</code>, this is too broad. For example:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">const</code> <code class="nx">releaseDates</code> <code class="o">=</code> <code class="nx">pluck</code><code class="p">(</code><code class="nx">albums</code><code class="p">,</code> <code class="s">'releaseDate'</code><code class="p">);</code> <code class="c">// Type is (string | Date)[]</code></pre>

            <p class="author1">The type should be <code class="calibre18">Date[]</code>, not <code
                class="calibre18">(string | Date)[]</code>. While <code class="calibre18">keyof T</code> is much
              narrower than <code class="calibre18">string</code>, it’s <em class="calibre3">still</em> too broad. To
              narrow it further, we need to introduce a second generic parameter that is a subset of <code
                class="calibre18">keyof T</code> (probably a single value):</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">pluck</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">K</code> <code class="kd">extends</code> <code class="nx">keyof</code> <code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">record</code>: <code class="nx">T</code><code class="p">[],</code> <code class="nx">key</code>: <code class="nx">K</code><code class="p">)</code><code class="o">:</code> <code class="nx">T</code><code class="p">[</code><code class="nx">K</code><code class="p">][]</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">record</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">r</code> <code class="o">=&gt;</code> <code class="nx">r</code><code class="p">[</code><code class="nx">key</code><code class="p">]);</code>
<code class="p">}</code></pre>

            <p class="author1">(For more on <code class="calibre18">extends</code> in this context, see <a
                href="#calibre_link-759" class="calibre9">Item 14</a>.)</p>

            <p class="author1">The type signature is now completely correct. We can check this by calling <code
                class="calibre18">pluck</code> in a few different ways:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="nx">pluck</code><code class="p">(</code><code class="nx">albums</code><code class="p">,</code> <code class="s">'releaseDate'</code><code class="p">);</code> <code class="c">// Type is Date[]</code>
<code class="nx">pluck</code><code class="p">(</code><code class="nx">albums</code><code class="p">,</code> <code class="s">'artist'</code><code class="p">);</code>  <code class="c">// Type is string[]</code>
<code class="nx">pluck</code><code class="p">(</code><code class="nx">albums</code><code class="p">,</code> <code class="s">'recordingType'</code><code class="p">);</code>  <code class="c">// Type is RecordingType[]</code>
<code class="nx">pluck</code><code class="p">(</code><code class="nx">albums</code><code class="p">,</code> <code class="s">'recordingDate'</code><code class="p">);</code>
           <code class="c">// ~~~~~~~~~~~~~~~ Argument of type '"recordingDate"' is not</code>
           <code class="c">//                 assignable to parameter of type ...</code></pre>

            <p class="author1">The language service is even able to offer autocomplete on the keys of <code
                class="calibre18">Album</code> (as shown in <a data-type="xref" href="#calibre_link-816"
                class="calibre9">Figure&nbsp;4-2</a>).</p>

            <figure class="width">
              <div class="figure" id="calibre_link-816">
                <img alt="efts 04in02" src="images/000032.png" class="calibre50" />
                <h6 class="calibre30"><span class="calibre">Figure 4-2. </span>Using a parameter type of keyof Album
                  instead of string results in better autocomplete in your editor.</h6>
              </div>
            </figure>

            <p class="author1"><code class="calibre18">string</code> has some of the same problems as <code
                class="calibre18">any</code>: when used inappropriately, it permits invalid values and hides
              relationships between types. This thwarts the type checker and can hide real bugs. TypeScript’s ability<a
                data-primary="type safety" data-secondary="subsets of string and" data-type="indexterm"
                id="calibre_link-634" class="calibre9"></a> to define subsets of <code class="calibre18">string</code>
              is a powerful way to bring type safety to JavaScript code. Using more precise types will both catch errors
              and improve the readability of your code.</p>








            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-927">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">Avoid “stringly typed” code. Prefer more appropriate types where not every <code
                        class="calibre18">string</code> is a possibility.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Prefer a union of string literal types to <code class="calibre18">string</code>
                      if that more accurately describes the domain of a variable. You’ll get stricter type checking and
                      improve the development experience.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Prefer <code class="calibre18">keyof T</code> to <code
                        class="calibre18">string</code> for function parameters that are expected to be properties of an
                      object.<a data-primary="" data-startref="TDalt04" data-type="indexterm" id="calibre_link-586"
                        class="calibre9"></a><a data-primary="" data-startref="STalt04" data-type="indexterm"
                        id="calibre_link-515" class="calibre9"></a></p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>













        <section data-pdf-bookmark="Item 34: Prefer Incomplete Types to Inaccurate Types" data-type="sect1"
          class="praise">
          <div class="praise" id="calibre_link-928">
            <h1 class="calibre16">Item 34: Prefer Incomplete Types to Inaccurate Types</h1>

            <p class="author1">In<a data-primary="type design" data-secondary="incomplete versus inaccurate types"
                data-type="indexterm" id="calibre_link-590" class="calibre9"></a> writing type declarations you’ll
              inevitably find situations where you can model behavior in a more precise or less precise way. Precision
              in types is generally a good thing because it will help your users catch bugs and take advantage of the
              tooling that TypeScript provides. But take care as you increase the precision of your type declarations:
              it’s easy to make mistakes, and incorrect types can be worse than no types at all.</p>

            <p class="author1">Suppose<a data-primary="GeoJSON" data-type="indexterm" id="calibre_link-293"
                class="calibre9"></a> you are writing type declarations for GeoJSON, a format we’ve seen before in <a
                href="#calibre_link-799" class="calibre9">Item 31</a>. A<a data-primary="Geometry" data-type="indexterm"
                id="calibre_link-298" class="calibre9"></a> GeoJSON Geometry can be one of a few types, each of which
              have differently shaped coordinate arrays:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">interface</code> <code class="nx">Point</code> <code class="p">{</code>
  <code class="nx">type</code>: <code class="s">'Point'</code><code class="p">;</code>
  <code class="nx">coordinates</code>: <code class="nx">number</code><code class="p">[];</code>
<code class="p">}</code>
<code class="kd">interface</code> <code class="nx">LineString</code> <code class="p">{</code>
  <code class="nx">type</code>: <code class="s">'LineString'</code><code class="p">;</code>
  <code class="nx">coordinates</code>: <code class="nx">number</code><code class="p">[][];</code>
<code class="p">}</code>
<code class="kd">interface</code> <code class="nx">Polygon</code> <code class="p">{</code>
  <code class="nx">type</code>: <code class="s">'Polygon'</code><code class="p">;</code>
  <code class="nx">coordinates</code>: <code class="nx">number</code><code class="p">[][][];</code>
<code class="p">}</code>
<code class="kd">type</code> <code class="nx">Geometry</code> <code class="o">=</code> <code class="nx">Point</code> <code class="o">|</code> <code class="nx">LineString</code> <code class="o">|</code> <code class="nx">Polygon</code><code class="p">;</code>  <code class="c">// Also several others</code></pre>

            <p class="author1">This is fine, but <code class="calibre18">number[]</code> for a coordinate is a bit
              imprecise. Really these are latitudes and longitudes, so perhaps a tuple type would be better:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">GeoPosition</code> <code class="o">=</code> <code class="p">[</code><code class="kt">number</code><code class="p">,</code> <code class="kt">number</code><code class="p">];</code>
<code class="kd">interface</code> <code class="nx">Point</code> <code class="p">{</code>
  <code class="nx">type</code>: <code class="s">'Point'</code><code class="p">;</code>
  <code class="nx">coordinates</code>: <code class="nx">GeoPosition</code><code class="p">;</code>
<code class="p">}</code>
<code class="c">// Etc.</code></pre>

            <p class="author1">You publish your more precise types to the world and wait for the adulation to roll in.
              Unfortunately, a user complains that your new types have broken everything. Even though you’ve only ever
              used latitude and longitude, a position in GeoJSON is allowed to have a third element, an elevation, and
              potentially more. In an attempt to make the type declarations more precise, you’ve gone too far and made
              the types inaccurate! To continue using your type declarations, your user will have to introduce type
              assertions or silence the type checker entirely with <code class="calibre18">as any</code>.<a
                data-primary="" data-startref="geojsona04" data-type="indexterm" id="calibre_link-294"
                class="calibre9"></a></p>

            <p class="author1">As another example, consider trying to write type declarations for a Lisp-like language
              defined in<a data-primary="JSON" data-type="indexterm" id="calibre_link-369" class="calibre9"></a> JSON:
            </p>

            <pre data-type="programlisting" class="calibre17">12
"red"
["+", 1, 2]  // 3
["/", 20, 2]  // 10
["case", ["&gt;", 20, 10], "red", "blue"]  // "red"
["rgb", 255, 0, 127]  // "#FF007F"</pre>

            <p class="author1">The<a data-primary="Mapbox library" data-type="indexterm" id="calibre_link-391"
                class="calibre9"></a> Mapbox library uses a system like this to determine the appearance of map features
              across many devices. There’s a whole spectrum of precision with which you could try to type this:</p>
            <ol class="calibre51">
              <li class="calibre52">
                <p class="author1">Allow anything.</p>
              </li>
              <li class="calibre52">
                <p class="author1">Allow strings, numbers, and arrays.</p>
              </li>
              <li class="calibre52">
                <p class="author1">Allow strings, numbers, and arrays starting with known function names.</p>
              </li>
              <li class="calibre52">
                <p class="author1">Make sure each function gets the correct number of arguments.</p>
              </li>
              <li class="calibre52">
                <p class="author1">Make sure each function gets the correct type of arguments.</p>
              </li>

            </ol>

            <p class="author1">The first two options are straightforward:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">type</code> <code class="nx">Expression1</code> <code class="o">=</code> <code class="nx">any</code><code class="p">;</code>
<code class="kd">type</code> <code class="nx">Expression2</code> <code class="o">=</code> <code class="kt">number</code> <code class="o">|</code> <code class="kt">string</code> <code class="o">|</code> <code class="nx">any</code><code class="p">[];</code></pre>

            <p class="author1">Beyond this, you should introduce a test set of expressions that are valid and
              expressions that are not. As you make your types more precise, this will help prevent regressions (see <a
                href="#calibre_link-768" class="calibre9">Item 52</a>):</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">tests</code>: <code class="nx">Expression2</code><code class="p">[]</code> <code class="o">=</code> <code class="p">[</code>
  <code class="mi">10</code><code class="p">,</code>
  <code class="s">"red"</code><code class="p">,</code>
  <code class="kd">true</code><code class="p">,</code>
<code class="c">// ~~~ Type 'true' is not assignable to type 'Expression2'</code>
  <code class="p">[</code><code class="s">"+"</code><code class="p">,</code> <code class="mi">10</code><code class="p">,</code> <code class="mi">5</code><code class="p">],</code>
  <code class="p">[</code><code class="s">"case"</code><code class="p">,</code> <code class="p">[</code><code class="s">"&gt;"</code><code class="p">,</code> <code class="mi">20</code><code class="p">,</code> <code class="mi">10</code><code class="p">],</code> <code class="s">"red"</code><code class="p">,</code> <code class="s">"blue"</code><code class="p">,</code> <code class="s">"green"</code><code class="p">],</code>  <code class="c">// Too many values</code>
  <code class="p">[</code><code class="s">"**"</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">31</code><code class="p">],</code>  <code class="c">// Should be an error: no "**" function</code>
  <code class="p">[</code><code class="s">"rgb"</code><code class="p">,</code> <code class="mi">255</code><code class="p">,</code> <code class="mi">128</code><code class="p">,</code> <code class="mi">64</code><code class="p">],</code>
  <code class="p">[</code><code class="s">"rgb"</code><code class="p">,</code> <code class="mi">255</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">127</code><code class="p">,</code> <code class="mi">0</code><code class="p">]</code>  <code class="c">// Too many values</code>
<code class="p">];</code></pre>

            <p class="author1">To go to the next level of precision you can use a union of string literal types as the
              first element of a tuple:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">FnName</code> <code class="o">=</code> <code class="s">'+'</code> <code class="o">|</code> <code class="s">'-'</code> <code class="o">|</code> <code class="s">'*'</code> <code class="o">|</code> <code class="s">'/'</code> <code class="o">|</code> <code class="s">'&gt;'</code> <code class="o">|</code> <code class="s">'&lt;'</code> <code class="o">|</code> <code class="s">'case'</code> <code class="o">|</code> <code class="s">'rgb'</code><code class="p">;</code>
<code class="kd">type</code> <code class="nx">CallExpression</code> <code class="o">=</code> <code class="p">[</code><code class="nx">FnName</code><code class="p">,</code> <code class="p">...</code><code class="nx">any</code><code class="p">[]];</code>
<code class="kd">type</code> <code class="nx">Expression3</code> <code class="o">=</code> <code class="kt">number</code> <code class="o">|</code> <code class="kt">string</code> <code class="o">|</code> <code class="nx">CallExpression</code><code class="p">;</code>

<code class="kd">const</code> <code class="nx">tests</code>: <code class="nx">Expression3</code><code class="p">[]</code> <code class="o">=</code> <code class="p">[</code>
  <code class="mi">10</code><code class="p">,</code>
  <code class="s">"red"</code><code class="p">,</code>
  <code class="kd">true</code><code class="p">,</code>
<code class="c">// ~~~ Type 'true' is not assignable to type 'Expression3'</code>
  <code class="p">[</code><code class="s">"+"</code><code class="p">,</code> <code class="mi">10</code><code class="p">,</code> <code class="mi">5</code><code class="p">],</code>
  <code class="p">[</code><code class="s">"case"</code><code class="p">,</code> <code class="p">[</code><code class="s">"&gt;"</code><code class="p">,</code> <code class="mi">20</code><code class="p">,</code> <code class="mi">10</code><code class="p">],</code> <code class="s">"red"</code><code class="p">,</code> <code class="s">"blue"</code><code class="p">,</code> <code class="s">"green"</code><code class="p">],</code>
  <code class="p">[</code><code class="s">"**"</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">31</code><code class="p">],</code>
<code class="c">// ~~~~~~~~~~~ Type '"**"' is not assignable to type 'FnName'</code>
  <code class="p">[</code><code class="s">"rgb"</code><code class="p">,</code> <code class="mi">255</code><code class="p">,</code> <code class="mi">128</code><code class="p">,</code> <code class="mi">64</code><code class="p">]</code>
<code class="p">];</code></pre>

            <p class="author1">There’s one new caught error and no regressions. Pretty good!</p>

            <p class="author1">What<a data-primary="recursive types" data-type="indexterm" id="calibre_link-490"
                class="calibre9"></a> if you want to make sure that each function gets the correct number of arguments?
              This gets trickier since the type now needs to be recursive to reach down into all the function calls. As
              of TypeScript 3.6, to make this work you needed to introduce at least one <code
                class="calibre18">interface</code>. Since <code class="calibre18">interface</code>s can’t be unions,
              you’ll have to write the call expressions using <code class="calibre18">interface</code> instead. This is
              a bit awkward since fixed-length arrays are most easily expressed as tuple types. But you <em
                class="calibre3">can</em> do it:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">Expression4</code> <code class="o">=</code> <code class="kt">number</code> <code class="o">|</code> <code class="kt">string</code> <code class="o">|</code> <code class="nx">CallExpression</code><code class="p">;</code>

<code class="kd">type</code> <code class="nx">CallExpression</code> <code class="o">=</code> <code class="nx">MathCall</code> <code class="o">|</code> <code class="nx">CaseCall</code> <code class="o">|</code> <code class="nx">RGBCall</code><code class="p">;</code>

<code class="kd">interface</code> <code class="nx">MathCall</code> <code class="p">{</code>
  <code class="mi">0</code><code class="o">:</code> <code class="s">'+'</code> <code class="o">|</code> <code class="s">'-'</code> <code class="o">|</code> <code class="s">'/'</code> <code class="o">|</code> <code class="s">'*'</code> <code class="o">|</code> <code class="s">'&gt;'</code> <code class="o">|</code> <code class="s">'&lt;'</code><code class="p">;</code>
  <code class="nx">1</code>: <code class="nx">Expression4</code><code class="p">;</code>
  <code class="nx">2</code>: <code class="nx">Expression4</code><code class="p">;</code>
  <code class="nx">length</code>: <code class="nx">3</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">interface</code> <code class="nx">CaseCall</code> <code class="p">{</code>
  <code class="mi">0</code><code class="o">:</code> <code class="s">'case'</code><code class="p">;</code>
  <code class="nx">1</code>: <code class="nx">Expression4</code><code class="p">;</code>
  <code class="nx">2</code>: <code class="nx">Expression4</code><code class="p">;</code>
  <code class="nx">3</code>: <code class="nx">Expression4</code><code class="p">;</code>
  <code class="nx">length</code>: <code class="nx">4</code> <code class="o">|</code> <code class="mi">6</code> <code class="o">|</code> <code class="mi">8</code> <code class="o">|</code> <code class="mi">10</code> <code class="o">|</code> <code class="mi">12</code> <code class="o">|</code> <code class="mi">14</code> <code class="o">|</code> <code class="mi">16</code> <code class="c">// etc.</code>
<code class="p">}</code>

<code class="kd">interface</code> <code class="nx">RGBCall</code> <code class="p">{</code>
  <code class="mi">0</code><code class="o">:</code> <code class="s">'rgb'</code><code class="p">;</code>
  <code class="nx">1</code>: <code class="nx">Expression4</code><code class="p">;</code>
  <code class="nx">2</code>: <code class="nx">Expression4</code><code class="p">;</code>
  <code class="nx">3</code>: <code class="nx">Expression4</code><code class="p">;</code>
  <code class="nx">length</code>: <code class="nx">4</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">const</code> <code class="nx">tests</code>: <code class="nx">Expression4</code><code class="p">[]</code> <code class="o">=</code> <code class="p">[</code>
  <code class="mi">10</code><code class="p">,</code>
  <code class="s">"red"</code><code class="p">,</code>
  <code class="kd">true</code><code class="p">,</code>
<code class="c">// ~~~ Type 'true' is not assignable to type 'Expression4'</code>
  <code class="p">[</code><code class="s">"+"</code><code class="p">,</code> <code class="mi">10</code><code class="p">,</code> <code class="mi">5</code><code class="p">],</code>
  <code class="p">[</code><code class="s">"case"</code><code class="p">,</code> <code class="p">[</code><code class="s">"&gt;"</code><code class="p">,</code> <code class="mi">20</code><code class="p">,</code> <code class="mi">10</code><code class="p">],</code> <code class="s">"red"</code><code class="p">,</code> <code class="s">"blue"</code><code class="p">,</code> <code class="s">"green"</code><code class="p">],</code>
<code class="c">// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</code>
<code class="c">//  Type '["case", ["&gt;", ...], ...]' is not assignable to type 'string'</code>
  <code class="p">[</code><code class="s">"**"</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">31</code><code class="p">],</code>
<code class="c">// ~~~~~~~~~~~~ Type '["**", number, number]' is not assignable to type 'string</code>
  <code class="p">[</code><code class="s">"rgb"</code><code class="p">,</code> <code class="mi">255</code><code class="p">,</code> <code class="mi">128</code><code class="p">,</code> <code class="mi">64</code><code class="p">],</code>
  <code class="p">[</code><code class="s">"rgb"</code><code class="p">,</code> <code class="mi">255</code><code class="p">,</code> <code class="mi">128</code><code class="p">,</code> <code class="mi">64</code><code class="p">,</code> <code class="mi">73</code><code class="p">]</code>
<code class="c">// ~~~~~~~~~~~~~~~~~~~~~~~~ Type '["rgb", number, number, number, number]'</code>
<code class="c">//                          is not assignable to type 'string'</code>
<code class="p">];</code></pre>

            <p class="author1">Now all the invalid expressions produce errors. And it’s interesting that you can express
              something like “an array of even length” using a TypeScript <code class="calibre18">interface</code>. But
              these error messages aren’t very good, and the error about <code class="calibre18">**</code> has gotten
              quite a bit worse since the previous typings.</p>

            <p class="author1">Is this an improvement over the previous, less precise types? The fact that you get
              errors for some incorrect usages is a win, but the errors will make this type more difficult to work with.
              Language services are as much a part of the TypeScript experience as type checking (see <a
                href="#calibre_link-775" class="calibre9">Item 6</a>), so it’s a good idea to look at the error messages
              resulting from your type declarations and try autocomplete in situations where it should work. If your new
              type declarations are more precise but break autocomplete, then they’ll make for a less enjoyable
              TypeScript development experience.</p>

            <p class="author1">The complexity of this type declaration has also increased the odds that a bug will creep
              in. For example, <code class="calibre18">Expression4</code> requires that all math operators take two
              parameters, but the<a data-primary="Mapbox library" data-type="indexterm" id="calibre_link-392"
                class="calibre9"></a> Mapbox expression spec says that <code class="calibre18">+</code> and <code
                class="calibre18">*</code> can take more. Also, <code class="calibre18">-</code> can take a single
              parameter, in which case it negates its input. <code class="calibre18">Expression4</code> incorrectly
              flags errors in all of these:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"> <code class="kd">const</code> <code class="nx">okExpressions</code>: <code class="nx">Expression4</code><code class="p">[]</code> <code class="o">=</code> <code class="p">[</code>
   <code class="p">[</code><code class="s">'-'</code><code class="p">,</code> <code class="mi">12</code><code class="p">],</code>
<code class="c">// ~~~~~~~~~ Type '["-", number]' is not assignable to type 'string'</code>
   <code class="p">[</code><code class="s">'+'</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">],</code>
<code class="c">// ~~~~~~~~~~~~~~ Type '["+", number, ...]' is not assignable to type 'string'</code>
   <code class="p">[</code><code class="s">'*'</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">],</code>
<code class="c">// ~~~~~~~~~~~~~~ Type '["*", number, ...]' is not assignable to type 'string'</code>
 <code class="p">];</code></pre>

            <p class="author1">Once again, in trying to be more precise we’ve overshot and become inaccurate. These
              inaccuracies can be corrected, but you’ll want to expand your test set to convince yourself that you
              haven’t missed anything else. Complex code generally requires more tests, and the same is true of types.
            </p>

            <p class="author1">As you refine types, it can be helpful to think of the “uncanny valley” metaphor.
              Refining very imprecise types like <code class="calibre18">any</code> is usually helpful. But as your
              types get more precise, the expectation that they’ll also be accurate increases. You’ll start to rely on
              the types more, and so inaccuracies will produce bigger problems.</p>








            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-929">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">Avoid the uncanny valley of type safety: incorrect types are often worse than no
                      types.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">If<a data-primary="unknown types" data-secondary="versus inaccurate models"
                        data-secondary-sortas="inaccurate models" data-type="indexterm" id="calibre_link-715"
                        class="calibre9"></a> you cannot model a type accurately, do not model it inaccurately!
                      Acknowledge the gaps using <code class="calibre18">any</code> or <code
                        class="calibre18">unknown</code>.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Pay attention to error messages and autocomplete as you make typings increasingly
                      precise. It’s not just about correctness: developer experience matters, too.<a data-primary=""
                        data-startref="TDincomplete04" data-type="indexterm" id="calibre_link-591" class="calibre9"></a>
                    </p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>













        <section data-pdf-bookmark="Item 35: Generate Types from APIs and Specs, Not Data" data-type="sect1"
          class="praise">
          <div class="praise" id="calibre_link-30">
            <h1 class="calibre16">Item 35: Generate Types from APIs and Specs, Not Data</h1>

            <p class="author1">The<a data-primary="type design" data-secondary="generating types from specifications"
                data-type="indexterm" id="calibre_link-588" class="calibre9"></a> other items in this chapter have
              discussed the many benefits of designing your types well and shown what can go wrong if you don’t. A
              well-designed type makes TypeScript a pleasure to use, while a poorly designed one can make it miserable.
              But this does put quite a bit of pressure on type design. Wouldn’t it be nice if you didn’t have to do
              this yourself?</p>

            <p class="author1">At least some of your types are likely to come from outside your program: file formats,
              APIs, or specs. In these cases you may be able to avoid writing types by generating them instead. If you
              do this, the key is to generate types from specifications, rather than from example data. When you
              generate types from a spec, TypeScript will help ensure that you haven’t missed any cases. When you
              generate types from data, you’re only considering the examples you’ve seen. You might be missing important
              edge cases that could break your program.</p>

            <p class="author1">In <a href="#calibre_link-799" class="calibre9">Item 31</a> we wrote a function to
              calculate the bounding box of a<a data-primary="GeoJSON" data-type="indexterm" id="calibre_link-295"
                class="calibre9"></a> GeoJSON Feature. Here’s what it looked like:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">calculateBoundingBox</code><code class="p">(</code><code class="nx">f</code>: <code class="nx">GeoJSONFeature</code><code class="p">)</code><code class="o">:</code> <code class="nx">BoundingBox</code><code class="o"> | </code><code class="nx">null</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">box</code>: <code class="nx">BoundingBox</code> <code class="o">|</code> <code class="nx">null</code><code class="o"> = </code><code class="kd">null</code><code class="p">;</code>

  <code class="kd">const</code> <code class="nx">helper</code> <code class="o">=</code> <code class="p">(</code><code class="nx">coords</code>: <code class="nx">any</code><code class="p">[])</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="c">// ...</code>
  <code class="p">};</code>

  <code class="kd">const</code> <code class="p">{</code><code class="nx">geometry</code><code class="p">}</code> <code class="o">=</code> <code class="nx">f</code><code class="p">;</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">geometry</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">helper</code><code class="p">(</code><code class="nx">geometry</code><code class="p">.</code><code class="nx">coordinates</code><code class="p">);</code>
  <code class="p">}</code>

  <code class="kd">return</code> <code class="nx">box</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">The <code class="calibre18">GeoJSONFeature</code> type was never explicitly defined. You
              could write it using some of the examples from <a href="#calibre_link-799" class="calibre9">Item 31</a>.
              But a better approach is to use the formal GeoJSON spec.<sup class="calibre44"><a data-type="noteref"
                  href="#calibre_link-817" id="calibre_link-818" class="calibre45">1</a></sup> Fortunately for us, there
              are already TypeScript type declarations for it on DefinitelyTyped. You can add these in the usual way:
            </p>
            <pre data-type="programlisting" class="calibre17">$ <strong class="calibre32">npm install --save-dev @types/geojson</strong>
+ @types/geojson@7946.0.7</pre>

            <p class="author1">When you plug in the GeoJSON declarations, TypeScript immediately flags an error:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">import</code> <code class="p">{</code><code class="nx">Feature</code><code class="p">}</code> <code class="nx">from</code> <code class="s">'geojson'</code><code class="p">;</code>

<code class="kd">function</code> <code class="nx">calculateBoundingBox</code><code class="p">(</code><code class="nx">f</code>: <code class="nx">Feature</code><code class="p">)</code><code class="o">:</code> <code class="nx">BoundingBox</code><code class="o"> | </code><code class="nx">null</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">box</code>: <code class="nx">BoundingBox</code> <code class="o">|</code> <code class="nx">null</code><code class="o"> = </code><code class="kd">null</code><code class="p">;</code>

  <code class="kd">const</code> <code class="nx">helper</code> <code class="o">=</code> <code class="p">(</code><code class="nx">coords</code>: <code class="nx">any</code><code class="p">[])</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="c">// ...</code>
  <code class="p">};</code>

  <code class="kd">const</code> <code class="p">{</code><code class="nx">geometry</code><code class="p">}</code> <code class="o">=</code> <code class="nx">f</code><code class="p">;</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">geometry</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">helper</code><code class="p">(</code><code class="nx">geometry</code><code class="p">.</code><code class="nx">coordinates</code><code class="p">);</code>
                 <code class="c">// ~~~~~~~~~~~</code>
                 <code class="c">// Property 'coordinates' does not exist on type 'Geometry'</code>
                 <code class="c">//   Property 'coordinates' does not exist on type</code>
                 <code class="c">//   'GeometryCollection'</code>
  <code class="p">}</code>

  <code class="kd">return</code> <code class="nx">box</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">The problem is that your code assumes a geometry will have a <code
                class="calibre18">coordinates</code> property. This is true for many geometries, including points,
              lines, and polygons. But a GeoJSON geometry can also be a <code
                class="calibre18">GeometryCollection</code>, a heterogeneous collection of other geometries. Unlike the
              other geometry types, it does not have a <code class="calibre18">coordinates</code> property.</p>

            <p class="author1">If you call <code class="calibre18">calculateBoundingBox</code> on a Feature whose
              geometry is a <code class="calibre18">GeometryCollection</code>, it will throw an error about not being
              able to read property <code class="calibre18">0</code> of <code class="calibre18">undefined</code>. This
              is a real bug! And we caught it using type definitions from a spec.</p>

            <p class="author1">One option for fixing it is to explicitly disallow <code
                class="calibre18">GeometryCollection</code>s, as shown here:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="p">{</code><code class="nx">geometry</code><code class="p">}</code> <code class="o">=</code> <code class="nx">f</code><code class="p">;</code>
<code class="kd">if</code> <code class="p">(</code><code class="nx">geometry</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">geometry</code><code class="p">.</code><code class="nx">type</code> <code class="o">===</code> <code class="s">'GeometryCollection'</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">throw</code> <code class="kd">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s">'GeometryCollections are not supported.'</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="nx">helper</code><code class="p">(</code><code class="nx">geometry</code><code class="p">.</code><code class="nx">coordinates</code><code class="p">);</code>  <code class="c">// OK</code>
<code class="p">}</code></pre>

            <p class="author1">TypeScript is able to refine the type of <code class="calibre18">geometry</code> based on
              the check, so the reference to <code class="calibre18">geometry.coordinates</code> is allowed. If nothing
              else, this results in a clearer error message for the user.</p>

            <p class="author1">But<a data-primary="Geometry" data-type="indexterm" id="calibre_link-299"
                class="calibre9"></a> the better solution is to support all the types of geometry! You can do this by
              pulling out another helper function:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">geometryHelper</code> <code class="o">=</code> <code class="p">(</code><code class="nx">g</code>: <code class="nx">Geometry</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">geometry</code><code class="p">.</code><code class="nx">type</code> <code class="o">===</code> <code class="s">'GeometryCollection'</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">geometry</code><code class="p">.</code><code class="nx">geometries</code><code class="p">.</code><code class="nx">forEach</code><code class="p">(</code><code class="nx">geometryHelper</code><code class="p">);</code>
  <code class="p">}</code> <code class="kd">else</code> <code class="p">{</code>
    <code class="nx">helper</code><code class="p">(</code><code class="nx">geometry</code><code class="p">.</code><code class="nx">coordinates</code><code class="p">);</code>  <code class="c">// OK</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kd">const</code> <code class="p">{</code><code class="nx">geometry</code><code class="p">}</code> <code class="o">=</code> <code class="nx">f</code><code class="p">;</code>
<code class="kd">if</code> <code class="p">(</code><code class="nx">geometry</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">geometryHelper</code><code class="p">(</code><code class="nx">geometry</code><code class="p">);</code>
<code class="p">}</code></pre>

            <p class="author1">Had you written type declarations for GeoJSON yourself, you would have based them off of
              your understanding and experience with the format. This might not have included <code
                class="calibre18">GeometryCollection</code>s and would have led to a false sense of security about your
              code’s correctness. Using types based on a spec gives you confidence that your code will work with all
              values, not just the ones you’ve seen.</p>

            <p class="author1">Similar considerations apply to API calls: if you can generate types from the
              specification of an API, then it is usually a good idea to do so. This works particularly well with APIs
              that are typed themselves, such as GraphQL.</p>

            <p class="author1">A GraphQL API comes with a schema that specifies all the possible queries and interfaces
              using a type system somewhat similar to TypeScript. You write queries that request specific fields in
              these interfaces. For example, to get information about a repository using the GitHub GraphQL API you
              might write:</p>

            <pre data-type="programlisting" class="calibre17">query {
  repository(owner: "Microsoft", name: "TypeScript") {
    createdAt
    description
  }
}</pre>

            <p class="author1">The result is:</p>

            <pre data-code-language="json" data-type="programlisting" class="calibre17"><code class="p">{</code>
  <code class="nt">"data"</code><code class="p">:</code> <code class="p">{</code>
    <code class="nt">"repository"</code><code class="p">:</code> <code class="p">{</code>
      <code class="nt">"createdAt"</code><code class="p">:</code> <code class="s">"2014-06-17T15:28:39Z"</code><code class="p">,</code>
      <code class="nt">"description"</code><code class="p">:</code>
        <code class="s">"TypeScript is a superset of JavaScript that compiles to JavaScript."</code>
    <code class="p">}</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

            <p class="author1">The beauty of this approach is that you can generate TypeScript types <em
                class="calibre3">for your specific query</em>. As with the GeoJSON example, this helps ensure that you
              model the relationships between types and their nullability accurately.</p>

            <p class="author1">Here’s a query to get the open source license for a GitHub repository:</p>

            <pre data-type="programlisting" class="calibre17">query getLicense($owner:String!, $name:String!){
  repository(owner:$owner, name:$name) {
    description
    licenseInfo {
      spdxId
      name
    }
  }
}</pre>

            <p class="author1"><code class="calibre18">$owner</code> and <code class="calibre18">$name</code> are
              GraphQL variables which are themselves typed. The type syntax is similar enough to TypeScript that it can
              be confusing to go back and forth. <code class="calibre18">String</code> is a GraphQL type&mdash;it would
              be <code class="calibre18">string</code> in TypeScript (see <a href="#calibre_link-757"
                class="calibre9">Item 10</a>). And while TypeScript types are not nullable, types in GraphQL are. The
              <code class="calibre18">!</code> after the type indicates that it is guaranteed to not be null.
            </p>

            <p class="author1">There are many tools to help you go from a GraphQL query to TypeScript types. One is
              Apollo. Here’s how you use it:</p>
            <pre data-type="programlisting" class="calibre17">$ <strong class="calibre32">apollo client:codegen \
    --endpoint https://api.github.com/graphql \
    --includes license.graphql \
    --target typescript</strong>
Loading Apollo Project
Generating query files with 'typescript' target - wrote 2 files</pre>

            <p class="author1">You need a GraphQL schema to generate types for a query. Apollo gets this from the <code
                class="calibre18">api.github.com/graphql</code> endpoint. The output looks like this:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">export</code> <code class="kd">interface</code> <code class="nx">getLicense_repository_licenseInfo</code> <code class="p">{</code>
  <code class="nx">__typename</code><code class="o">:</code> <code class="s">"License"</code><code class="p">;</code>
  <code class="c">/** Short identifier specified by &lt;https://spdx.org/licenses&gt; */</code>
  <code class="nx">spdxId</code>: <code class="kd">string</code> <code class="o">|</code> <code class="kd">null</code><code class="p">;</code>
  <code class="c">/** The license full name specified by &lt;https://spdx.org/licenses&gt; */</code>
  <code class="nx">name</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">export</code> <code class="kd">interface</code> <code class="nx">getLicense_repository</code> <code class="p">{</code>
  <code class="nx">__typename</code><code class="o">:</code> <code class="s">"Repository"</code><code class="p">;</code>
  <code class="c">/** The description of the repository. */</code>
  <code class="nx">description</code>: <code class="kd">string</code> <code class="o">|</code> <code class="kd">null</code><code class="p">;</code>
  <code class="c">/** The license associated with the repository */</code>
  <code class="nx">licenseInfo</code>: <code class="nx">getLicense_repository_licenseInfo</code> <code class="o">|</code> <code class="kd">null</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">export</code> <code class="kd">interface</code> <code class="nx">getLicense</code> <code class="p">{</code>
  <code class="c">/** Lookup a given repository by the owner and repository name. */</code>
  <code class="nx">repository</code>: <code class="nx">getLicense_repository</code> <code class="o">|</code> <code class="kd">null</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">export</code> <code class="kd">interface</code> <code class="nx">getLicenseVariables</code> <code class="p">{</code>
  <code class="nx">owner</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">name</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">The important bits to note here are that:</p>

            <ul class="printings">
              <li class="calibre12">
                <p class="author1">Interfaces are generated for both the query parameters (<code
                    class="calibre18">getLicenseVariables</code>) and the response (<code
                    class="calibre18">getLicense</code>).</p>
              </li>
              <li class="calibre12">
                <p class="author1">Nullability information is transferred from the schema to the response interfaces.
                  The <code class="calibre18">repository</code>, <code class="calibre18">description</code>, <code
                    class="calibre18">licenseInfo</code>, and <code class="calibre18">spdxId</code> fields are nullable,
                  whereas the license <code class="calibre18">name</code> and the query variables are not.</p>
              </li>
              <li class="calibre12">
                <p class="author1">Documentation is transferred as JSDoc so that it appears in your editor (<a
                    href="#calibre_link-49" class="calibre9">Item 48</a>). These comments come from the GraphQL schema
                  itself.</p>
              </li>
            </ul>

            <p class="author1">This type information helps ensure that you use the API correctly. If your queries
              change, the types will change. If the schema changes, then so will your types. There is no risk that your
              types and reality diverge since they are both coming from a single source of truth: the GraphQL schema.
            </p>

            <p class="author1">What if there’s no spec or official schema available? Then you’ll have to generate types
              from data. Tools like <code class="calibre18">quicktype</code> can help with this. But be aware that your
              types may not match reality: there may be edge cases that you’ve missed.</p>

            <p class="author1">Even if you’re not aware of it, you are already benefiting from code generation.
              TypeScript’s type declarations for the browser DOM API are generated from the official interfaces (see <a
                href="#calibre_link-26" class="calibre9">Item 55</a>). This ensures that they correctly model a
              complicated system and helps TypeScript catch errors and misunderstandings in your own code.</p>








            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-930">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">Consider<a data-primary="type safety" data-secondary="ensuring"
                        data-type="indexterm" id="calibre_link-630" class="calibre9"></a> generating types for API calls
                      and data formats to get type safety all the way to the edge of your code.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Prefer generating code from specs rather than data. Rare cases matter!<a
                        data-primary="" data-startref="TDspec04" data-type="indexterm" id="calibre_link-589"
                        class="calibre9"></a><a data-primary="" data-startref="geojsonb04" data-type="indexterm"
                        id="calibre_link-296" class="calibre9"></a></p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>













        <section data-pdf-bookmark="Item 36: Name Types Using the Language of Your Problem Domain" data-type="sect1"
          class="praise">
          <div class="praise" id="calibre_link-22">
            <h1 class="calibre16">Item 36: Name Types Using the Language of Your Problem Domain</h1>
            <blockquote class="calibre4 pcalibre1 pcalibre">
              <p class="calibre5">There are only two hard problems in Computer Science: cache invalidation and naming
                things.</p>
              <p data-type="attribution" class="calibre6 pcalibre2">Phil Karlton</p>
            </blockquote>

            <p class="author1">This<a data-primary="Karlton, Phil" data-type="indexterm" id="calibre_link-372"
                class="calibre9"></a><a data-primary="type design" data-secondary="naming types" data-type="indexterm"
                id="calibre_link-592" class="calibre9"></a><a data-primary="properties" data-secondary="naming"
                data-type="indexterm" id="calibre_link-469" class="calibre9"></a><a data-primary="variables"
                data-secondary="naming" data-type="indexterm" id="calibre_link-741" class="calibre9"></a><a
                data-primary="names and naming" data-type="indexterm" id="calibre_link-410" class="calibre9"></a> book
              has had much to say about the <em class="calibre3">shape</em> of types and the sets of values in their
              domains, but much less about what you <em class="calibre3">name</em> your types. But this is an important
              part of type design, too. Well-chosen type, property, and variable names can clarify intent and raise the
              level of abstraction of your code and types. Poorly chosen types can obscure your code and lead to
              incorrect mental models.</p>

            <p class="author1">Suppose you’re building out a database of animals. You create an interface to represent
              one:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Animal</code> <code class="p">{</code>
  <code class="nx">name</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">endangered</code>: <code class="nx">boolean</code><code class="p">;</code>
  <code class="nx">habitat</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">const</code> <code class="nx">leopard</code>: <code class="nx">Animal</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">name</code><code class="o">:</code> <code class="s">'Snow Leopard'</code><code class="p">,</code>
  <code class="nx">endangered</code>: <code class="nx">false</code><code class="p">,</code>
  <code class="nx">habitat</code><code class="o">:</code> <code class="s">'tundra'</code><code class="p">,</code>
<code class="p">};</code></pre>

            <p class="author1">There are a few issues here:</p>

            <ul class="printings">
              <li class="calibre12">
                <p class="author1"><code class="calibre18">name</code> is a very general term. What sort of name are you
                  expecting? A scientific name? A common name?</p>
              </li>
              <li class="calibre12">
                <p class="author1">The boolean <code class="calibre18">endangered</code> field is also ambiguous. What
                  if an animal is extinct? Is the intent here “endangered or worse?” Or does it literally mean
                  endangered?</p>
              </li>
              <li class="calibre12">
                <p class="author1">The <code class="calibre18">habitat</code> field is very ambiguous, not just because
                  of the overly broad <code class="calibre18">string</code> type (<a href="#calibre_link-812"
                    class="calibre9">Item 33</a>) but also because it’s unclear what’s meant by “habitat.”</p>
              </li>
              <li class="calibre12">
                <p class="author1">The variable name is <code class="calibre18">leopard</code>, but the value of the
                  <code class="calibre18">name</code> property is “Snow Leopard.” Is this distinction meaningful?
                </p>
              </li>
            </ul>

            <p class="author1">Here’s a type declaration and value with less ambiguity:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Animal</code> <code class="p">{</code>
  <code class="nx">commonName</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">genus</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">species</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">status</code>: <code class="nx">ConservationStatus</code><code class="p">;</code>
  <code class="nx">climates</code>: <code class="nx">KoppenClimate</code><code class="p">[];</code>
<code class="p">}</code>
<code class="kd">type</code> <code class="nx">ConservationStatus</code> <code class="o">=</code> <code class="s">'EX'</code> <code class="o">|</code> <code class="s">'EW'</code> <code class="o">|</code> <code class="s">'CR'</code> <code class="o">|</code> <code class="s">'EN'</code> <code class="o">|</code> <code class="s">'VU'</code> <code class="o">|</code> <code class="s">'NT'</code> <code class="o">|</code> <code class="s">'LC'</code><code class="p">;</code>
<code class="kd">type</code> <code class="nx">KoppenClimate</code> <code class="o">=</code> <code class="o">|</code>
  <code class="s">'Af'</code> <code class="o">|</code> <code class="s">'Am'</code> <code class="o">|</code> <code class="s">'As'</code> <code class="o">|</code> <code class="s">'Aw'</code> <code class="o">|</code>
  <code class="s">'BSh'</code> <code class="o">|</code> <code class="s">'BSk'</code> <code class="o">|</code> <code class="s">'BWh'</code> <code class="o">|</code> <code class="s">'BWk'</code> <code class="o">|</code>
  <code class="s">'Cfa'</code> <code class="o">|</code> <code class="s">'Cfb'</code> <code class="o">|</code> <code class="s">'Cfc'</code> <code class="o">|</code> <code class="s">'Csa'</code> <code class="o">|</code> <code class="s">'Csb'</code> <code class="o">|</code> <code class="s">'Csc'</code> <code class="o">|</code> <code class="s">'Cwa'</code> <code class="o">|</code> <code class="s">'Cwb'</code> <code class="o">|</code> <code class="s">'Cwc'</code> <code class="o">|</code>
  <code class="s">'Dfa'</code> <code class="o">|</code> <code class="s">'Dfb'</code> <code class="o">|</code> <code class="s">'Dfc'</code> <code class="o">|</code> <code class="s">'Dfd'</code> <code class="o">|</code>
  <code class="s">'Dsa'</code> <code class="o">|</code> <code class="s">'Dsb'</code> <code class="o">|</code> <code class="s">'Dsc'</code> <code class="o">|</code> <code class="s">'Dwa'</code> <code class="o">|</code> <code class="s">'Dwb'</code> <code class="o">|</code> <code class="s">'Dwc'</code> <code class="o">|</code> <code class="s">'Dwd'</code> <code class="o">|</code>
  <code class="s">'EF'</code> <code class="o">|</code> <code class="s">'ET'</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">snowLeopard</code>: <code class="nx">Animal</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">commonName</code><code class="o">:</code> <code class="s">'Snow Leopard'</code><code class="p">,</code>
  <code class="nx">genus</code><code class="o">:</code> <code class="s">'Panthera'</code><code class="p">,</code>
  <code class="nx">species</code><code class="o">:</code> <code class="s">'Uncia'</code><code class="p">,</code>
  <code class="nx">status</code><code class="o">:</code> <code class="s">'VU'</code><code class="p">,</code>  <code class="c">// vulnerable</code>
  <code class="nx">climates</code><code class="o">:</code> <code class="p">[</code><code class="s">'ET'</code><code class="p">,</code> <code class="s">'EF'</code><code class="p">,</code> <code class="s">'Dfd'</code><code class="p">],</code>  <code class="c">// alpine or subalpine</code>
<code class="p">};</code></pre>

            <p class="author1">This makes a number of improvements:</p>

            <ul class="printings">
              <li class="calibre12">
                <p class="author1"><code class="calibre18">name</code> has been replaced with more specific terms: <code
                    class="calibre18">commonName</code>, <code class="calibre18">genus</code>, and <code
                    class="calibre18">species</code>.</p>
              </li>
              <li class="calibre12">
                <p class="author1"><code class="calibre18">endangered</code> has become <code
                    class="calibre18">conservationStatus</code> and uses a standard classification system from the IUCN.
                </p>
              </li>
              <li class="calibre12">
                <p class="author1"><code class="calibre18">habitat</code> has become <code
                    class="calibre18">climates</code> and uses another standard taxonomy, the Köppen climate
                  classification.</p>
              </li>
            </ul>

            <p class="author1">If you needed more information about the fields in the first version of this type, you’d
              have to go find the person who wrote them and ask. In all likelihood, they’ve left the company or don’t
              remember. Worse yet, you might run <code class="calibre18">git blame</code> to find out who wrote these
              lousy types, only to find that it was you!</p>

            <p class="author1">The situation is much improved with the second version. If you want to learn more about
              the Köppen climate classification system or track down what the precise meaning of a conservation status
              is, then there are myriad resources online to help you.</p>

            <p class="author1">Every domain has specialized vocabulary to describe its subject. Rather than inventing
              your own terms, try to reuse terms from the domain of your problem. These vocabularies have often been
              honed over years, decades, or centuries and are well understood by people in the field. Using these terms
              will help you communicate with users and increase the clarity of your types.</p>

            <p class="author1">Take care to use domain vocabulary accurately: co-opting the language of a domain to mean
              something different is even more confusing than inventing your own.</p>

            <p class="author1">Here are a few other rules to keep in mind as you name types, properties, and variables:
            </p>

            <ul class="printings">
              <li class="calibre12">
                <p class="author1">Make distinctions meaningful. In writing and speech it can be tedious to use the same
                  word over and over. We introduce synonyms to break the monotony. This makes prose more enjoyable to
                  read, but it has the opposite effect on code. If you use two different terms, make sure you’re drawing
                  a meaningful distinction. If not, you should use the same term.</p>
              </li>
              <li class="calibre12">
                <p class="author1">Avoid vague, meaningless names like “data,” “info,” “thing,” “item,” “object,” or the
                  ever-popular “entity.” If Entity has a specific meaning in your domain, fine. But if you’re using it
                  because you don’t want to think of a more meaningful name, then you’ll eventually run into trouble.
                </p>
              </li>
              <li class="calibre12">
                <p class="author1">Name things for what they are, not for what they contain or how they are computed.
                  <code class="calibre18">Directory</code> is more meaningful than <code
                    class="calibre18">INodeList</code>. It allows you to think about a directory as a concept, rather
                  than in terms of its implementation. Good names can increase your level of abstraction and decrease
                  your risk of inadvertent collisions.
                </p>
              </li>
            </ul>








            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-931">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">Reuse names from the domain of your problem where possible to increase the
                      readability and level of abstraction of your code.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Avoid using different names for the same thing: make distinctions in names
                      meaningful.<a data-primary="" data-startref="names04" data-type="indexterm" id="calibre_link-411"
                        class="calibre9"></a><a data-primary="" data-startref="Vname04" data-type="indexterm"
                        id="calibre_link-742" class="calibre9"></a><a data-primary="" data-startref="Pname04"
                        data-type="indexterm" id="calibre_link-470" class="calibre9"></a><a data-primary=""
                        data-startref="TDname04" data-type="indexterm" id="calibre_link-593" class="calibre9"></a></p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>













        <section data-pdf-bookmark="Item 37: Consider “Brands” for Nominal Typing" data-type="sect1" class="praise">
          <div class="praise" id="calibre_link-762">
            <h1 class="calibre16">Item 37: Consider “Brands” for Nominal Typing</h1>

            <p class="author1"><a href="#calibre_link-10" class="calibre9">Item 4</a> discussed<a data-primary="classes"
                data-secondary="nominal typing" data-type="indexterm" id="calibre_link-155" class="calibre9"></a><a
                data-primary="type design" data-secondary="nominal typing" data-type="indexterm" id="calibre_link-594"
                class="calibre9"></a><a data-primary="nominal typing" data-type="indexterm" id="calibre_link-425"
                class="calibre9"></a><a data-primary="brands" data-type="indexterm" id="calibre_link-133"
                class="calibre9"></a><a data-primary="TypeScript" data-secondary="structural typing"
                data-type="indexterm" id="calibre_link-689" class="calibre9"></a><a data-primary="structural typing"
                data-type="indexterm" id="calibre_link-518" class="calibre9"></a><a data-primary="JavaScript"
                data-secondary="duck typing" data-type="indexterm" id="calibre_link-344" class="calibre9"></a><a
                data-primary="duck typing" data-type="indexterm" id="calibre_link-228" class="calibre9"></a><a
                data-primary="properties" data-secondary="modeling outside of type system" data-type="indexterm"
                id="calibre_link-467" class="calibre9"></a> structural (“duck”) typing and how it can sometimes lead to
              surprising results:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">interface</code> <code class="nx">Vector2D</code> <code class="p">{</code>
  <code class="nx">x</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">y</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">function</code> <code class="nx">calculateNorm</code><code class="p">(</code><code class="nx">p</code>: <code class="nx">Vector2D</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">sqrt</code><code class="p">(</code><code class="nx">p</code><code class="p">.</code><code class="nx">x</code> <code class="o">*</code> <code class="nx">p</code><code class="p">.</code><code class="nx">x</code> <code class="o">+</code> <code class="nx">p</code><code class="p">.</code><code class="nx">y</code> <code class="o">*</code> <code class="nx">p</code><code class="p">.</code><code class="nx">y</code><code class="p">);</code>
<code class="p">}</code>

<code class="nx">calculateNorm</code><code class="p">({</code><code class="nx">x</code>: <code class="nx">3</code><code class="p">,</code> <code class="nx">y</code>: <code class="nx">4</code><code class="p">});</code>  <code class="c">// OK, result is 5</code>
<code class="kd">const</code> <code class="nx">vec3D</code> <code class="o">=</code> <code class="p">{</code><code class="nx">x</code>: <code class="nx">3</code><code class="p">,</code> <code class="nx">y</code>: <code class="nx">4</code><code class="p">,</code> <code class="nx">z</code>: <code class="nx">1</code><code class="p">};</code>
<code class="nx">calculateNorm</code><code class="p">(</code><code class="nx">vec3D</code><code class="p">);</code>  <code class="c">// OK! result is also 5</code></pre>

            <p class="author1">What if you’d like <code class="calibre18">calculateNorm</code> to reject 3D vectors?
              This goes against the structural typing model of TypeScript but is certainly more mathematically correct.
            </p>

            <p class="author1">One way to achieve this is with <em class="calibre3">nominal typing</em>. With nominal
              typing, a value is a <code class="calibre18">Vector2D</code> because you say it is, not because it has the
              right shape. To approximate this in TypeScript, you can introduce a “brand” (think cows, not Coca-Cola):
            </p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Vector2D</code> <code class="p">{</code>
  <code class="nx">_brand</code><code class="o">:</code> <code class="s">'2d'</code><code class="p">;</code>
  <code class="nx">x</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">y</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">function</code> <code class="nx">vec2D</code><code class="p">(</code><code class="nx">x</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">y</code>: <code class="nx">number</code><code class="p">)</code><code class="o">:</code> <code class="nx">Vector2D</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="p">{</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">,</code> <code class="nx">_brand</code><code class="o">:</code> <code class="s">'2d'</code><code class="p">};</code>
<code class="p">}</code>
<code class="kd">function</code> <code class="nx">calculateNorm</code><code class="p">(</code><code class="nx">p</code>: <code class="nx">Vector2D</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">sqrt</code><code class="p">(</code><code class="nx">p</code><code class="p">.</code><code class="nx">x</code> <code class="o">*</code> <code class="nx">p</code><code class="p">.</code><code class="nx">x</code> <code class="o">+</code> <code class="nx">p</code><code class="p">.</code><code class="nx">y</code> <code class="o">*</code> <code class="nx">p</code><code class="p">.</code><code class="nx">y</code><code class="p">);</code>  <code class="c">// Same as before</code>
<code class="p">}</code>

<code class="nx">calculateNorm</code><code class="p">(</code><code class="nx">vec2D</code><code class="p">(</code><code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">));</code> <code class="c">// OK, returns 5</code>
<code class="kd">const</code> <code class="nx">vec3D</code> <code class="o">=</code> <code class="p">{</code><code class="nx">x</code>: <code class="nx">3</code><code class="p">,</code> <code class="nx">y</code>: <code class="nx">4</code><code class="p">,</code> <code class="nx">z</code>: <code class="nx">1</code><code class="p">};</code>
<code class="nx">calculateNorm</code><code class="p">(</code><code class="nx">vec3D</code><code class="p">);</code>
           <code class="c">// ~~~~~ Property '_brand' is missing in type...</code></pre>

            <p class="author1">The brand ensures that the vector came from the right place. Granted there’s nothing
              stopping you from adding <code class="calibre18">_brand: '2d'</code> to the <code
                class="calibre18">vec3D</code> value. But this is moving from the accidental into the malicious. This
              sort of brand is typically enough to catch inadvertent misuses of functions.</p>

            <p class="author1">Interestingly, you can get many of the same benefits as explicit brands while operating
              only in the type system. This removes runtime overhead and also lets you brand built-in types like <code
                class="calibre18">string</code> or <code class="calibre18">number</code> where you can’t attach
              additional properties.</p>

            <p class="author1">For instance, what if you have a function that operates on the filesystem and requires an
              absolute (as opposed to a relative) path? This is easy to check at runtime (does the path start with “/”?)
              but not so easy in the type system.</p>

            <p class="author1">Here’s an approach with brands:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">AbsolutePath</code> <code class="o">=</code> <code class="kt">string</code> <code class="o">&amp;</code> <code class="p">{</code><code class="nx">_brand</code><code class="o">:</code> <code class="s">'abs'</code><code class="p">};</code>
<code class="kd">function</code> <code class="nx">listAbsolutePath</code><code class="p">(</code><code class="nx">path</code>: <code class="nx">AbsolutePath</code><code class="p">)</code> <code class="p">{</code>
  <code class="c">// ...</code>
<code class="p">}</code>
<code class="kd">function</code> <code class="nx">isAbsolutePath</code><code class="p">(</code><code class="nx">path</code>: <code class="kd">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">path</code> <code class="nx">is</code> <code class="nx">AbsolutePath</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">path</code><code class="p">.</code><code class="nx">startsWith</code><code class="p">(</code><code class="s">'/'</code><code class="p">);</code>
<code class="p">}</code></pre>

            <p class="author1">You can’t construct an object that is a <code class="calibre18">string</code> and has a
              <code class="calibre18">_brand</code> property. This is purely a game with the type system.
            </p>

            <p class="author1">If you have a <code class="calibre18">string</code> path that could be either absolute or
              relative, you can check using the type guard, which will refine its type:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">f</code><code class="p">(</code><code class="nx">path</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">isAbsolutePath</code><code class="p">(</code><code class="nx">path</code><code class="p">))</code> <code class="p">{</code>
    <code class="nx">listAbsolutePath</code><code class="p">(</code><code class="nx">path</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="nx">listAbsolutePath</code><code class="p">(</code><code class="nx">path</code><code class="p">);</code>
                <code class="c">// ~~~~ Argument of type 'string' is not assignable</code>
                <code class="c">//      to parameter of type 'AbsolutePath'</code>
<code class="p">}</code></pre>

            <p class="author1">This sort of approach could be helpful in documenting which functions expect absolute or
              relative paths and which type of path each variable holds. It is not an ironclad guarantee, though: <code
                class="calibre18">path as AbsolutePath</code> will succeed for any <code
                class="calibre18">string</code>. But if you avoid these sorts of assertions, then the only way to get an
              <code class="calibre18">AbsolutePath</code> is to be given one or to check, which is exactly what you
              want.
            </p>

            <p class="author1">This approach can be used to model many properties that cannot be expressed within the
              type system. For example, using binary search to find an element in a list:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">binarySearch</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">xs</code>: <code class="nx">T</code><code class="p">[],</code> <code class="nx">x</code>: <code class="nx">T</code><code class="p">)</code><code class="o">:</code> <code class="kd">boolean</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">low</code> <code class="o">=</code> <code class="mi">0</code><code class="p">,</code> <code class="nx">high</code> <code class="o">=</code> <code class="nx">xs</code><code class="p">.</code><code class="nx">length</code> <code class="o">-</code> <code class="mi">1</code><code class="p">;</code>
  <code class="kd">while</code> <code class="p">(</code><code class="nx">high</code> <code class="o">&gt;=</code> <code class="nx">low</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">const</code> <code class="nx">mid</code> <code class="o">=</code> <code class="nx">low</code> <code class="o">+</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">floor</code><code class="p">((</code><code class="nx">high</code> <code class="o">-</code> <code class="nx">low</code><code class="p">)</code> <code class="o">/</code> <code class="mi">2</code><code class="p">);</code>
    <code class="kd">const</code> <code class="nx">v</code> <code class="o">=</code> <code class="nx">xs</code><code class="p">[</code><code class="nx">mid</code><code class="p">];</code>
    <code class="kd">if</code> <code class="p">(</code><code class="nx">v</code> <code class="o">===</code> <code class="nx">x</code><code class="p">)</code> <code class="kd">return</code> <code class="kd">true</code><code class="p">;</code>
    <code class="p">[</code><code class="nx">low</code><code class="p">,</code> <code class="nx">high</code><code class="p">]</code> <code class="o">=</code> <code class="nx">x</code> <code class="o">&gt;</code> <code class="nx">v</code> <code class="o">?</code> <code class="p">[</code><code class="nx">mid</code> <code class="o">+</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">high</code><code class="p">]</code> <code class="o">:</code> <code class="p">[</code><code class="nx">low</code><code class="p">,</code> <code class="nx">mid</code> <code class="o">-</code> <code class="mi">1</code><code class="p">];</code>
  <code class="p">}</code>
  <code class="kd">return</code> <code class="kd">false</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">This works if the list is sorted, but will result in false negatives if it is not. You
              can’t represent a sorted list in TypeScript’s type system. But you can create a brand:</p>

            <pre data-code-language="ts" data-type="programlisting" id="calibre_link-932" class="calibre17"><code class="kd">type</code> <code class="nx">SortedList</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">T</code><code class="p">[]</code> <code class="o">&amp;</code> <code class="p">{</code><code class="nx">_brand</code><code class="o">:</code> <code class="s">'sorted'</code><code class="p">};</code>

<code class="kd">function</code> <code class="nx">isSorted</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">xs</code>: <code class="nx">T</code><code class="p">[])</code><code class="o">:</code> <code class="nx">xs</code> <code class="nx">is</code> <code class="nx">SortedList</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="p">{</code>
  <code class="kd">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">xs</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">if</code> <code class="p">(</code><code class="nx">xs</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code> <code class="o">&gt;</code> <code class="nx">xs</code><code class="p">[</code><code class="nx">i</code> <code class="o">-</code> <code class="mi">1</code><code class="p">])</code> <code class="p">{</code>
      <code class="kd">return</code> <code class="kd">false</code><code class="p">;</code>
    <code class="p">}</code>
  <code class="p">}</code>
  <code class="kd">return</code> <code class="kd">true</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="nx">binarySearch</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">xs</code>: <code class="nx">SortedList</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">,</code> <code class="nx">x</code>: <code class="nx">T</code><code class="p">)</code><code class="o">:</code> <code class="kd">boolean</code> <code class="p">{</code>
  <code class="c">// ...</code>
<code class="p">}</code></pre>

            <p class="author1">In order to call this version of <code class="calibre18">binarySearch</code>, you either
              need to be given a <code class="calibre18">SortedList</code> (i.e., have a proof that the list is sorted)
              or prove that it’s sorted yourself using <code class="calibre18">isSorted</code>. The linear scan isn’t
              great, but at least you’ll be safe!</p>

            <p class="author1">This is a helpful perspective to have on the type checker in general. In order to call a
              method on an object, for instance, you either need to be given a non-<code class="calibre18">null</code>
              object or prove that it’s non-<code class="calibre18">null</code> yourself with a conditional.</p>

            <p class="author1">You can also brand <code class="calibre18">number</code> types&mdash;for example, to
              attach units:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">type</code> <code class="nx">Meters</code> <code class="o">=</code> <code class="kt">number</code> <code class="o">&amp;</code> <code class="p">{</code><code class="nx">_brand</code><code class="o">:</code> <code class="s">'meters'</code><code class="p">};</code>
<code class="kd">type</code> <code class="nx">Seconds</code> <code class="o">=</code> <code class="kt">number</code> <code class="o">&amp;</code> <code class="p">{</code><code class="nx">_brand</code><code class="o">:</code> <code class="s">'seconds'</code><code class="p">};</code>

<code class="kd">const</code> <code class="nx">meters</code> <code class="o">=</code> <code class="p">(</code><code class="nx">m</code>: <code class="nx">number</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">m</code> <code class="kd">as</code> <code class="nx">Meters</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">seconds</code> <code class="o">=</code> <code class="p">(</code><code class="nx">s</code>: <code class="nx">number</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">s</code> <code class="kd">as</code> <code class="nx">Seconds</code><code class="p">;</code>

<code class="kd">const</code> <code class="nx">oneKm</code> <code class="o">=</code> <code class="nx">meters</code><code class="p">(</code><code class="mi">1000</code><code class="p">);</code>  <code class="c">// Type is Meters</code>
<code class="kd">const</code> <code class="nx">oneMin</code> <code class="o">=</code> <code class="nx">seconds</code><code class="p">(</code><code class="mi">60</code><code class="p">);</code>  <code class="c">// Type is Seconds</code></pre>

            <p class="author1">This can be awkward in practice since arithmetic operations make the numbers forget their
              brands:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">const</code> <code class="nx">tenKm</code> <code class="o">=</code> <code class="nx">oneKm</code> <code class="o">*</code> <code class="mi">10</code><code class="p">;</code>  <code class="c">// Type is number</code>
<code class="kd">const</code> <code class="nx">v</code> <code class="o">=</code> <code class="nx">oneKm</code> <code class="o">/</code> <code class="nx">oneMin</code><code class="p">;</code>  <code class="c">// Type is number</code></pre>

            <p class="author1">If your code involves lots of numbers with mixed units, however, this may still be an
              attractive approach to documenting the expected types of numeric parameters.</p>








            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-933">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">TypeScript uses structural (“duck”) typing, which can sometimes lead to
                      surprising results. If you need nominal typing, consider attaching “brands” to your values to
                      distinguish them.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">In some cases you may be able to attach brands entirely in the type system,
                      rather than at runtime. You can use this technique to model properties outside of TypeScript’s
                      type system.<a data-primary="" data-startref="Pmodel04" data-type="indexterm"
                        id="calibre_link-468" class="calibre9"></a><a data-primary="" data-startref="duck04"
                        data-type="indexterm" id="calibre_link-229" class="calibre9"></a><a data-primary=""
                        data-startref="JSduch04" data-type="indexterm" id="calibre_link-345" class="calibre9"></a><a
                        data-primary="" data-startref="struct04" data-type="indexterm" id="calibre_link-519"
                        class="calibre9"></a><a data-primary="" data-startref="TSstruct04" data-type="indexterm"
                        id="calibre_link-690" class="calibre9"></a><a data-primary="" data-startref="brand04"
                        data-type="indexterm" id="calibre_link-134" class="calibre9"></a><a data-primary=""
                        data-startref="nominal04" data-type="indexterm" id="calibre_link-426" class="calibre9"></a><a
                        data-primary="" data-startref="TDnominal04" data-type="indexterm" id="calibre_link-595"
                        class="calibre9"></a></p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>







        <div data-type="footnotes" class="calibre46">
          <p data-type="footnote" id="calibre_link-817" class="calibre47"><sup class="calibre48"><a
                href="#calibre_link-818" class="calibre49">1</a></sup> GeoJSON is also known as RFC 7946. The very
            readable spec is at <a href="http://geojson.org" class="calibre9"><em
                class="calibre3">http://geojson.org</em></a>.</p>
        </div>
      </div>
    </section>
  </div>

  <div data-type="book" class="calibre1" id="calibre_link-38">
    <section data-pdf-bookmark="Chapter 5. Working with any" data-type="chapter" type="chapter" class="praise">
      <div class="praise" id="calibre_link-774">
        <h1 class="calibre14"><span class="calibre">Chapter 5. </span>Working with any</h1>


        <p class="author1">Type systems<a data-primary="type system" data-secondary="as optional and gradual"
            data-secondary-sortas="optional and gradual" data-type="indexterm" id="calibre_link-654"
            class="calibre9"></a> were traditionally binary affairs: either a language had a fully static type system or
          a fully dynamic one. TypeScript blurs the line, because its type system is <em class="calibre3">optional</em>
          and <em class="calibre3">gradual</em>. You can add types to parts of your program but not others.</p>

        <p class="author1">This is essential for migrating existing JavaScript codebases to TypeScript bit by bit (<a
            data-type="xref" href="#calibre_link-39" class="calibre9">Chapter&nbsp;8</a>). Key to this is the <code
            class="calibre18">any</code> type, which effectively disables type checking for parts of your code. It is
          both powerful and prone to abuse. Learning to use <code class="calibre18">any</code> wisely is essential for
          writing effective TypeScript. This chapter walks you through how to limit the downsides of <code
            class="calibre18">any</code> while still retaining its benefits.</p>






        <section data-pdf-bookmark="Item 38: Use the Narrowest Possible Scope for any Types" data-type="sect1"
          class="praise">
          <div class="praise" id="calibre_link-45">
            <h1 class="calibre16">Item 38: Use the Narrowest Possible Scope for any Types</h1>

            <p class="author1">Consider<a data-primary="any types" data-secondary="using narrow scope for"
                data-type="indexterm" id="calibre_link-98" class="calibre9"></a><a data-primary="functions"
                data-secondary="avoid returning any types from" data-type="indexterm" id="calibre_link-280"
                class="calibre9"></a><a data-primary="type safety"
                data-secondary="avoid returning any types from functions" data-type="indexterm" id="calibre_link-628"
                class="calibre9"></a> this code:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">processBar</code><code class="p">(</code><code class="nx">b</code>: <code class="nx">Bar</code><code class="p">)</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">}</code>

<code class="kd">function</code> <code class="nx">f() {</code>
  <code class="kd">const</code> <code class="nx">x</code> <code class="o">=</code> <code class="nx">expressionReturningFoo</code><code class="p">();</code>
  <code class="nx">processBar</code><code class="p">(</code><code class="nx">x</code><code class="p">);</code>
  <code class="c">//         ~ Argument of type 'Foo' is not assignable to</code>
  <code class="c">//           parameter of type 'Bar'</code>
<code class="p">}</code></pre>

            <p class="author1">If you somehow know from context that <code class="calibre18">x</code> is assignable to
              <code class="calibre18">Bar</code> in addition to <code class="calibre18">Foo</code>, you can force
              TypeScript to accept this code in two ways:
            </p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">f1() {</code>
  <code class="kd">const</code> <code class="nx">x</code>: <code class="nx">any</code> <code class="o">=</code> <code class="nx">expressionReturningFoo</code><code class="p">();</code>  <code class="c">// Don't do this</code>
  <code class="nx">processBar</code><code class="p">(</code><code class="nx">x</code><code class="p">);</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="nx">f2() {</code>
  <code class="kd">const</code> <code class="nx">x</code> <code class="o">=</code> <code class="nx">expressionReturningFoo</code><code class="p">();</code>
  <code class="nx">processBar</code><code class="p">(</code><code class="nx">x</code> <code class="kd">as</code> <code class="nx">any</code><code class="p">);</code>  <code class="c">// Prefer this</code>
<code class="p">}</code></pre>

            <p class="author1">Of these, the second form is vastly preferable. Why? Because the <code
                class="calibre18">any</code> type is scoped to a single expression in a function argument. It has no
              effect outside this argument or this line. If code after the <code class="calibre18">processBar</code>
              call references <code class="calibre18">x</code>, its type will still be <code
                class="calibre18">Foo</code>, and it will still be able to trigger type errors, whereas in the first
              example its type is <code class="calibre18">any</code> until it goes out of scope at the end of the
              function.</p>

            <p class="author1">The stakes become significantly higher if you <em class="calibre3">return</em> <code
                class="calibre18">x</code> from this function. Look what happens:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">f1() {</code>
  <code class="kd">const</code> <code class="nx">x</code>: <code class="nx">any</code> <code class="o">=</code> <code class="nx">expressionReturningFoo</code><code class="p">();</code>
  <code class="nx">processBar</code><code class="p">(</code><code class="nx">x</code><code class="p">);</code>
  <code class="kd">return</code> <code class="nx">x</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="nx">g() {</code>
  <code class="kd">const</code> <code class="nx">foo</code> <code class="o">=</code> <code class="nx">f1</code><code class="p">();</code>  <code class="c">// Type is any</code>
  <code class="nx">foo</code><code class="p">.</code><code class="nx">fooMethod</code><code class="p">();</code>  <code class="c">// This call is unchecked!</code>
<code class="p">}</code></pre>

            <p class="author1">An <code class="calibre18">any</code> return type is “contagious” in that it can spread
              throughout a codebase. As a result of our changes to <code class="calibre18">f</code>, an <code
                class="calibre18">any</code> type has quietly appeared in <code class="calibre18">g</code>. This would
              not have happened with the more narrowly scoped <code class="calibre18">any</code> in <code
                class="calibre18">f2</code>.</p>

            <p class="author1">(This<a data-primary="type annotations" data-secondary="using explicit with any types"
                data-type="indexterm" id="calibre_link-560" class="calibre9"></a> is a good reason to consider including
              explicit return type annotations, even when the return type can be inferred. It prevents an <code
                class="calibre18">any</code> type from “escaping.” See discussion in <a href="#calibre_link-11"
                class="calibre9">Item 19</a>.)</p>

            <p class="author1">We<a data-primary="@ts-ignore" data-type="indexterm" id="calibre_link-68"
                class="calibre9"></a> used <code class="calibre18">any</code> here to silence an error that we believed
              to be incorrect. Another way to do this is with <code class="calibre18">@ts-ignore</code>:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">f1() {</code>
  <code class="kd">const</code> <code class="nx">x</code> <code class="o">=</code> <code class="nx">expressionReturningFoo</code><code class="p">();</code>
  <code class="c">// @ts-ignore</code>
  <code class="nx">processBar</code><code class="p">(</code><code class="nx">x</code><code class="p">);</code>
  <code class="kd">return</code> <code class="nx">x</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">This silences an error on the next line, leaving the type of <code
                class="calibre18">x</code> unchanged. Try not to lean too heavily on <code
                class="calibre18">@ts-ignore</code>: the type checker usually has a good reason to complain. It also
              means that if the error on the next line changes to something more problematic, you won’t know.</p>

            <p class="author1">You may also run into situations where you get a type error for just one property in a
              larger object:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">config</code>: <code class="nx">Config</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">a</code>: <code class="nx">1</code><code class="p">,</code>
  <code class="nx">b</code>: <code class="nx">2</code><code class="p">,</code>
  <code class="nx">c</code><code class="o">:</code> <code class="p">{</code>
    <code class="nx">key</code>: <code class="nx">value</code>
 <code class="c">// ~~~ Property ... missing in type 'Bar' but required in type 'Foo'</code>
  <code class="p">}</code>
<code class="p">};</code></pre>

            <p class="author1">You can silence errors like this by throwing an <code class="calibre18">as any</code>
              around the whole <code class="calibre18">config</code> object:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">const</code> <code class="nx">config</code>: <code class="nx">Config</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">a</code>: <code class="nx">1</code><code class="p">,</code>
  <code class="nx">b</code>: <code class="nx">2</code><code class="p">,</code>
  <code class="nx">c</code><code class="o">:</code> <code class="p">{</code>
    <code class="nx">key</code>: <code class="nx">value</code>
  <code class="p">}</code>
<code class="p">}</code> <code class="kd">as</code> <code class="nx">any</code><code class="p">;</code>  <code class="c">// Don't do this!</code></pre>

            <p class="author1">But this has the side effect of disabling type checking for the other properties (<code
                class="calibre18">a</code> and <code class="calibre18">b</code>) as well. Using a more narrowly scoped
              <code class="calibre18">any</code> limits the damage:
            </p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">config</code>: <code class="nx">Config</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">a</code>: <code class="nx">1</code><code class="p">,</code>
  <code class="nx">b</code>: <code class="nx">2</code><code class="p">,</code>  <code class="c">// These properties are still checked</code>
  <code class="nx">c</code><code class="o">:</code> <code class="p">{</code>
    <code class="nx">key</code>: <code class="nx">value</code> <code class="kd">as</code> <code class="nx">any</code>
  <code class="p">}</code>
<code class="p">};</code></pre>








            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-934">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">Make your uses of <code class="calibre18">any</code> as narrowly scoped as
                      possible to avoid undesired loss of type safety elsewhere in your code.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Never return an <code class="calibre18">any</code> type from a function. This
                      will silently lead to the loss of type safety for any client calling the function.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Consider <code class="calibre18">@ts-ignore</code> as an alternative to <code
                        class="calibre18">any</code> if you need to silence one error.<a data-primary=""
                        data-startref="ATnarrow05" data-type="indexterm" id="calibre_link-99" class="calibre9"></a><a
                        data-primary="" data-startref="TSavoid05" data-type="indexterm" id="calibre_link-629"
                        class="calibre9"></a><a data-primary="" data-startref="Favoid05" data-type="indexterm"
                        id="calibre_link-281" class="calibre9"></a></p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>













        <section data-pdf-bookmark="Item 39: Prefer More Precise Variants of any to Plain any" data-type="sect1"
          class="praise">
          <div class="praise" id="calibre_link-50">
            <h1 class="calibre16">Item 39: Prefer More Precise Variants of any to Plain any</h1>

            <p class="author1">The<a data-primary="any types" data-secondary="plain any versus more precise variants"
                data-type="indexterm" id="calibre_link-92" class="calibre9"></a><a data-primary="any[ ] types"
                data-type="indexterm" id="calibre_link-100" class="calibre9"></a><a data-primary="() =&gt; any"
                data-type="indexterm" id="calibre_link-60" class="calibre9"></a><a data-primary="{[id: string]: any}"
                data-type="indexterm" id="calibre_link-77" class="calibre9"></a> <code class="calibre18">any</code> type
              encompasses all values that can be expressed in JavaScript. This is a vast set! It includes not just all
              numbers and strings, but all arrays, objects, regular expressions, functions, classes, and DOM elements,
              not to mention <code class="calibre18">null</code> and <code class="calibre18">undefined</code>. When you
              use an <code class="calibre18">any</code> type, ask whether you really had something more specific in
              mind. Would it be OK to pass in a regular expression or a function?</p>

            <p class="author1">Often the answer is “no,” in which case you might be able to retain some type safety by
              using a more specific type:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">getLengthBad</code><code class="p">(</code><code class="nx">array</code>: <code class="nx">any</code><code class="p">)</code> <code class="p">{</code>  <code class="c">// Don't do this!</code>
  <code class="kd">return</code> <code class="nx">array</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="nx">getLength</code><code class="p">(</code><code class="nx">array</code>: <code class="nx">any</code><code class="p">[])</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">array</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">The latter version, which uses <code class="calibre18">any[]</code> instead of <code
                class="calibre18">any</code>, is better in three ways:</p>

            <ul class="printings">
              <li class="calibre12">
                <p class="author1">The reference to <code class="calibre18">array.length</code> in the function body is
                  type checked.</p>
              </li>
              <li class="calibre12">
                <p class="author1">The function’s return type is inferred as <code class="calibre18">number</code>
                  instead of <code class="calibre18">any</code>.</p>
              </li>
              <li class="calibre12">
                <p class="author1">Calls to <code class="calibre18">getLength</code> will be checked to ensure that the
                  parameter is an array:</p>
              </li>
            </ul>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="nx">getLengthBad</code><code class="p">(</code><code class="sr">/123/</code><code class="p">);</code>  <code class="c">// No error, returns undefined</code>
<code class="nx">getLength</code><code class="p">(</code><code class="sr">/123/</code><code class="p">);</code>
       <code class="c">// ~~~~~ Argument of type 'RegExp' is not assignable</code>
       <code class="c">//       to parameter of type 'any[]'</code></pre>

            <p class="author1">If<a data-primary="{[key: string]: any} type" data-type="indexterm" id="calibre_link-79"
                class="calibre9"></a> you expect a parameter to be an array of arrays but don’t care about the type, you
              can use <code class="calibre18">any[][]</code>. If you expect some sort of object but don’t know what the
              values will be, you can use <code class="calibre18">{[key: string]: any}</code>:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">hasTwelveLetterKey</code><code class="p">(</code><code class="nx">o</code><code class="o">:</code> <code class="p">{[</code><code class="nx">key</code>: <code class="kd">string</code><code class="p">]</code><code class="o">:</code> <code class="nx">any</code><code class="p">})</code> <code class="p">{</code>
  <code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="nx">key</code> <code class="kd">in</code> <code class="nx">o</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">if</code> <code class="p">(</code><code class="nx">key</code><code class="p">.</code><code class="nx">length</code> <code class="o">===</code> <code class="mi">12</code><code class="p">)</code> <code class="p">{</code>
      <code class="kd">return</code> <code class="kd">true</code><code class="p">;</code>
    <code class="p">}</code>
  <code class="p">}</code>
  <code class="kd">return</code> <code class="kd">false</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">You could also use the <code class="calibre18">object</code> type in this situation,
              which includes all non-primitive types. This is slightly different in that, while you can still enumerate
              keys, you can’t access the values of any of them:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">hasTwelveLetterKey</code><code class="p">(</code><code class="nx">o</code>: <code class="nx">object</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="nx">key</code> <code class="kd">in</code> <code class="nx">o</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">if</code> <code class="p">(</code><code class="nx">key</code><code class="p">.</code><code class="nx">length</code> <code class="o">===</code> <code class="mi">12</code><code class="p">)</code> <code class="p">{</code>
      <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">key</code><code class="p">,</code> <code class="nx">o</code><code class="p">[</code><code class="nx">key</code><code class="p">]);</code>
                   <code class="c">//  ~~~~~~ Element implicitly has an 'any' type</code>
                   <code class="c">//         because type '{}' has no index signature</code>
      <code class="kd">return</code> <code class="kd">true</code><code class="p">;</code>
    <code class="p">}</code>
  <code class="p">}</code>
  <code class="kd">return</code> <code class="kd">false</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">If this sort of type fits your needs, you might also be interested in the <code
                class="calibre18">unknown</code> type. See <a href="#calibre_link-40" class="calibre9">Item 42</a>.</p>

            <p class="author1">Avoid using <code class="calibre18">any</code> if you expect a function type. You have
              several options here depending on how specific you want to get:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">Fn0</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">any</code><code class="p">;</code>  <code class="c">// any function callable with no params</code>
<code class="kd">type</code> <code class="nx">Fn1</code> <code class="o">=</code> <code class="p">(</code><code class="nx">arg</code>: <code class="nx">any</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">any</code><code class="p">;</code>  <code class="c">// With one param</code>
<code class="kd">type</code> <code class="nx">FnN</code> <code class="o">=</code> <code class="p">(...</code><code class="nx">args</code>: <code class="nx">any</code><code class="p">[])</code> <code class="o">=&gt;</code> <code class="nx">any</code><code class="p">;</code>  <code class="c">// With any number of params</code>
                                     <code class="c">// same as "Function" type</code></pre>

            <p class="author1">All of these are more precise than <code class="calibre18">any</code> and hence
              preferable to it. Note the use of <code class="calibre18">any[]</code> as the type for the rest parameter
              in the last example. <code class="calibre18">any</code> would also work here but would be less precise:
            </p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">const</code> <code class="nx">numArgsBad</code> <code class="o">=</code> <code class="p">(...</code><code class="nx">args</code>: <code class="nx">any</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">args</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="c">// Returns any</code>
<code class="kd">const</code> <code class="nx">numArgsGood</code> <code class="o">=</code> <code class="p">(...</code><code class="nx">args</code>: <code class="nx">any</code><code class="p">[])</code> <code class="o">=&gt;</code> <code class="nx">args</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code>  <code class="c">// Returns number</code></pre>

            <p class="author1">This is perhaps the most common use of the <code class="calibre18">any[]</code> type.</p>








            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-935">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">When you use <code class="calibre18">any</code>, think about whether any
                      JavaScript value is truly permissible.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Prefer more precise forms of <code class="calibre18">any</code> such as <code
                        class="calibre18">any[]</code> or <code class="calibre18">{[id: string]: any}</code> or <code
                        class="calibre18">() =&gt; any</code> if they more accurately model your data.<a data-primary=""
                        data-startref="idstring05" data-type="indexterm" id="calibre_link-78" class="calibre9"></a><a
                        data-primary="" data-type="indexterm" id="calibre_link-936" class="calibre9"></a><a
                        data-primary="" data-startref="fatany05" data-type="indexterm" id="calibre_link-61"
                        class="calibre9"></a><a data-primary="" data-startref="ATplain05" data-type="indexterm"
                        id="calibre_link-93" class="calibre9"></a><a data-startref="any05" data-type="indexterm"
                        id="calibre_link-101" class="calibre9"></a></p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>













        <section data-pdf-bookmark="Item 40: Hide Unsafe Type Assertions in Well-Typed Functions" data-type="sect1"
          class="praise">
          <div class="praise" id="calibre_link-937">
            <h1 class="calibre16">Item 40: Hide Unsafe Type Assertions in Well-Typed Functions</h1>

            <p class="author1">There<a data-primary="any types" data-secondary="hiding unsafe type assertions"
                data-type="indexterm" id="calibre_link-90" class="calibre9"></a><a data-primary="type safety"
                data-secondary="hiding unsafe type assertions" data-type="indexterm" id="calibre_link-631"
                class="calibre9"></a><a data-primary="unsafe casts" data-type="indexterm" id="calibre_link-718"
                class="calibre9"></a><a data-primary="type assertion" data-secondary="hiding unsafe type assertions"
                data-type="indexterm" id="calibre_link-565" class="calibre9"></a><a data-primary="functions"
                data-secondary="hiding unsafe type assertions in" data-type="indexterm" id="calibre_link-283"
                class="calibre9"></a> are many functions whose type signatures are easy to write but whose
              implementations are quite difficult to write in type-safe code. And while writing type-safe
              implementations is a noble goal, it may not be worth the difficulty to deal with edge cases that you know
              don’t come up in your code. If a reasonable attempt at a type-safe implementation doesn’t work, use an
              unsafe type assertion hidden inside a function with the right type signature. Unsafe assertions hidden
              inside well-typed functions are much better than unsafe assertions scattered throughout your code.</p>

            <p class="author1">Suppose<a data-primary="React library" data-secondary="useMemo hook"
                data-type="indexterm" id="calibre_link-486" class="calibre9"></a> you want to make a function cache its
              last call. This is a common technique for eliminating expensive function calls with frameworks like
              React.<sup class="calibre44"><a data-type="noteref" href="#calibre_link-41" id="calibre_link-53"
                  class="calibre45">1</a></sup> It would be nice to write a general <code
                class="calibre18">cacheLast</code> wrapper that adds this behavior to any function. Its declaration is
              easy to write:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">declare</code> <code class="kd">function</code> <code class="nx">cacheLast</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kd">extends</code> <code class="nb">Function</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">fn</code>: <code class="nx">T</code><code class="p">)</code><code class="o">:</code> <code class="nx">T</code><code class="p">;</code></pre>

            <p class="author1">Here’s an attempt at an implementation:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">cacheLast</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kd">extends</code> <code class="nb">Function</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">fn</code>: <code class="nx">T</code><code class="p">)</code><code class="o">:</code> <code class="nx">T</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">lastArgs</code>: <code class="nx">any</code><code class="p">[]</code><code class="o">|</code><code class="nx">null</code><code class="o"> = </code><code class="kd">null</code><code class="p">;</code>
  <code class="kd">let</code> <code class="nx">lastResult</code>: <code class="nx">any</code><code class="p">;</code>
  <code class="kd">return</code> <code class="kd">function</code><code class="p">(...</code><code class="nx">args</code>: <code class="nx">any</code><code class="p">[])</code> <code class="p">{</code>
      <code class="c">// ~~~~~~~~~~~~~~~~~~~~~~~~~~</code>
      <code class="c">//          Type '(...args: any[]) =&gt; any' is not assignable to type 'T'</code>
    <code class="kd">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">lastArgs</code> <code class="o">||</code> <code class="o">!</code><code class="nx">shallowEqual</code><code class="p">(</code><code class="nx">lastArgs</code><code class="p">,</code> <code class="nx">args</code><code class="p">))</code> <code class="p">{</code>
      <code class="nx">lastResult</code> <code class="o">=</code> <code class="nx">fn</code><code class="p">(...</code><code class="nx">args</code><code class="p">);</code>
      <code class="nx">lastArgs</code> <code class="o">=</code> <code class="nx">args</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="kd">return</code> <code class="nx">lastResult</code><code class="p">;</code>
  <code class="p">};</code>
<code class="p">}</code></pre>

            <p class="author1">The error makes sense: TypeScript has no reason to believe that this very loose function
              has any relation to <code class="calibre18">T</code>. But you know that the type system will enforce that
              it’s called with the right parameters and that its return value is given the correct type. So you
              shouldn’t expect too many problems if you add a type assertion here:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">cacheLast</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kd">extends</code> <code class="nb">Function</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">fn</code>: <code class="nx">T</code><code class="p">)</code><code class="o">:</code> <code class="nx">T</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">lastArgs</code>: <code class="nx">any</code><code class="p">[]</code><code class="o">|</code><code class="nx">null</code><code class="o"> = </code><code class="kd">null</code><code class="p">;</code>
  <code class="kd">let</code> <code class="nx">lastResult</code>: <code class="nx">any</code><code class="p">;</code>
  <code class="kd">return</code> <code class="kd">function</code><code class="p">(...</code><code class="nx">args</code>: <code class="nx">any</code><code class="p">[])</code> <code class="p">{</code>
    <code class="kd">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">lastArgs</code> <code class="o">||</code> <code class="o">!</code><code class="nx">shallowEqual</code><code class="p">(</code><code class="nx">lastArgs</code><code class="p">,</code> <code class="nx">args</code><code class="p">))</code> <code class="p">{</code>
      <code class="nx">lastResult</code> <code class="o">=</code> <code class="nx">fn</code><code class="p">(...</code><code class="nx">args</code><code class="p">);</code>
      <code class="nx">lastArgs</code> <code class="o">=</code> <code class="nx">args</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="kd">return</code> <code class="nx">lastResult</code><code class="p">;</code>
  <code class="p">}</code> <code class="kd">as</code> <code class="nx">unknown</code> <code class="kd">as</code> <code class="nx">T</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">And indeed this will work great for any simple function you pass it. There are quite a
              few <code class="calibre18">any</code> types hidden in this implementation, but you’ve kept them out of
              the type signature, so the code that calls <code class="calibre18">cacheLast</code> will be none the
              wiser.</p>

            <p class="author1">(Is this actually safe? There are a few real problems with this implementation: it
              doesn’t check that the values of <code class="calibre18">this</code> for successive calls are the same.
              And if the original function had properties defined on it, then the wrapped function would not have these,
              so it wouldn’t have the same type. But if you know that these situations don’t come up in your code, this
              implementation is just fine. This function <em class="calibre3">can</em> be written in a type-safe way,
              but it is a more complex exercise that is left to the reader.)</p>

            <p class="author1">The <code class="calibre18">shallowEqual</code> function from the previous example
              operated on two arrays and is easy to type and implement. But the object variation is more interesting. As
              with <code class="calibre18">cacheLast</code>, it’s easy to write its type signature:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">declare</code> <code class="kd">function</code> <code class="nx">shallowObjectEqual</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kd">extends</code> <code class="nx">object</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">a</code>: <code class="nx">T</code><code class="p">,</code> <code class="nx">b</code>: <code class="nx">T</code><code class="p">)</code><code class="o">:</code> <code class="kd">boolean</code><code class="p">;</code></pre>

            <p class="author1">The<a data-primary="Object.keys" data-type="indexterm" id="calibre_link-444"
                class="calibre9"></a> implementation requires some care since there’s no guarantee that <code
                class="calibre18">a</code> and <code class="calibre18">b</code> have the same keys (see <a
                href="#calibre_link-42" class="calibre9">Item 54</a>):</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">shallowObjectEqual</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kd">extends</code> <code class="nx">object</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">a</code>: <code class="nx">T</code><code class="p">,</code> <code class="nx">b</code>: <code class="nx">T</code><code class="p">)</code><code class="o">:</code> <code class="kd">boolean</code> <code class="p">{</code>
  <code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="p">[</code><code class="nx">k</code><code class="p">,</code> <code class="nx">aVal</code><code class="p">]</code> <code class="nx">of</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">entries</code><code class="p">(</code><code class="nx">a</code><code class="p">))</code> <code class="p">{</code>
    <code class="kd">if</code> <code class="p">(</code><code class="o">!</code><code class="p">(</code><code class="nx">k</code> <code class="kd">in</code> <code class="nx">b</code><code class="p">)</code> <code class="o">||</code> <code class="nx">aVal</code> <code class="o">!==</code> <code class="nx">b</code><code class="p">[</code><code class="nx">k</code><code class="p">])</code> <code class="p">{</code>
                           <code class="c">// ~~~~ Element implicitly has an 'any' type</code>
                           <code class="c">//      because type '{}' has no index signature</code>
      <code class="kd">return</code> <code class="kd">false</code><code class="p">;</code>
    <code class="p">}</code>
  <code class="p">}</code>
  <code class="kd">return</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">keys</code><code class="p">(</code><code class="nx">a</code><code class="p">).</code><code class="nx">length</code> <code class="o">===</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">keys</code><code class="p">(</code><code class="nx">b</code><code class="p">).</code><code class="nx">length</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">It’s a bit surprising that TypeScript complains about the <code
                class="calibre18">b[k]</code> access despite your having just checked that <code
                class="calibre18">k in b</code> is true. But it does, so you have no choice but to cast:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">shallowObjectEqual</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kd">extends</code> <code class="nx">object</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">a</code>: <code class="nx">T</code><code class="p">,</code> <code class="nx">b</code>: <code class="nx">T</code><code class="p">)</code><code class="o">:</code> <code class="kd">boolean</code> <code class="p">{</code>
  <code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="p">[</code><code class="nx">k</code><code class="p">,</code> <code class="nx">aVal</code><code class="p">]</code> <code class="nx">of</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">entries</code><code class="p">(</code><code class="nx">a</code><code class="p">))</code> <code class="p">{</code>
    <code class="kd">if</code> <code class="p">(</code><code class="o">!</code><code class="p">(</code><code class="nx">k</code> <code class="kd">in</code> <code class="nx">b</code><code class="p">)</code> <code class="o">||</code> <code class="nx">aVal</code> <code class="o">!==</code> <code class="p">(</code><code class="nx">b</code> <code class="kd">as</code> <code class="nx">any</code><code class="p">)[</code><code class="nx">k</code><code class="p">])</code> <code class="p">{</code>
      <code class="kd">return</code> <code class="kd">false</code><code class="p">;</code>
    <code class="p">}</code>
  <code class="p">}</code>
  <code class="kd">return</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">keys</code><code class="p">(</code><code class="nx">a</code><code class="p">).</code><code class="nx">length</code> <code class="o">===</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">keys</code><code class="p">(</code><code class="nx">b</code><code class="p">).</code><code class="nx">length</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">This type assertion is harmless (since you’ve checked <code
                class="calibre18">k in b</code>), and you’re left with a correct function with a clear type signature.
              This is much preferable to scattering iteration and assertions to check for object equality throughout
              your code!</p>








            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-938">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">Sometimes unsafe type assertions are necessary or expedient. When you need to use
                      one, hide it inside a function with a correct signature.</p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>













        <section data-pdf-bookmark="Item 41: Understand Evolving any" data-type="sect1" class="praise">
          <div class="praise" id="calibre_link-763">
            <h1 class="calibre16">Item 41: Understand Evolving any</h1>

            <p class="author1">In<a data-primary="evolving any" data-type="indexterm" id="calibre_link-259"
                class="calibre9"></a><a data-primary="any[ ] types" data-type="indexterm" id="calibre_link-102"
                class="calibre9"></a><a data-primary="any types" data-secondary="evolving" data-type="indexterm"
                id="calibre_link-88" class="calibre9"></a><a data-primary="type annotations"
                data-secondary="using explicit with any types" data-type="indexterm" id="calibre_link-561"
                class="calibre9"></a> TypeScript a variable’s type is generally determined when it is declared. After
              this, it can be <em class="calibre3">refined</em> (by checking if it is <code
                class="calibre18">null</code>, for instance), but it cannot expand to include new values. There is one
              notable exception to this, however, involving <code class="calibre18">any</code> types.</p>

            <p class="author1">In JavaScript, you might write a function to generate a range of numbers like this:</p>

            <pre data-code-language="js" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">range</code><code class="p">(</code><code class="nx">start</code><code class="p">,</code> <code class="nx">limit</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">out</code> <code class="o">=</code> <code class="p">[];</code>
  <code class="kd">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="nx">start</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">limit</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">out</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">i</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="kd">return</code> <code class="nx">out</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">When you convert this to TypeScript, it works exactly as you’d expect:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">range</code><code class="p">(</code><code class="nx">start</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">limit</code>: <code class="nx">number</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">out</code> <code class="o">=</code> <code class="p">[];</code>
  <code class="kd">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="nx">start</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">limit</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">out</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">i</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="kd">return</code> <code class="nx">out</code><code class="p">;</code>  <code class="c">// Return type inferred as number[]</code>
<code class="p">}</code></pre>

            <p class="author1">Upon closer inspection, however, it’s surprising that this works! How does TypeScript
              know that the type of <code class="calibre18">out</code> is <code class="calibre18">number[]</code> when
              it’s initialized as <code class="calibre18">[]</code>, which could be an array of any type?</p>

            <p class="author1">Inspecting each of the three occurrences of <code class="calibre18">out</code> to reveal
              its inferred type starts to tell the story:</p>

            <pre data-code-language="ts" data-type="programlisting" id="calibre_link-939" class="calibre17"><code class="kd">function</code> <code class="nx">range</code><code class="p">(</code><code class="nx">start</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">limit</code>: <code class="nx">number</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">out</code> <code class="o">=</code> <code class="p">[];</code>  <code class="c">// Type is any[]</code>
  <code class="kd">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="nx">start</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">limit</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">out</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">i</code><code class="p">);</code>  <code class="c">// Type of out is any[]</code>
  <code class="p">}</code>
  <code class="kd">return</code> <code class="nx">out</code><code class="p">;</code>  <code class="c">// Type is number[]</code>
<code class="p">}</code></pre>

            <p class="author1">The type of <code class="calibre18">out</code> starts as <code
                class="calibre18">any[]</code>, an undifferentiated array. But as we push <code
                class="calibre18">number</code> values onto it, its type “evolves” to become <code
                class="calibre18">number[]</code>.</p>

            <p class="author1">This is distinct from narrowing (<a href="#calibre_link-43" class="calibre9">Item
                22</a>). An array’s type can expand by pushing different elements onto it:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">result</code> <code class="o">=</code> <code class="p">[];</code>  <code class="c">// Type is any[]</code>
<code class="nx">result</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="s">'a'</code><code class="p">);</code>
<code class="nx">result</code>  <code class="c">// Type is string[]</code>
<code class="nx">result</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="mi">1</code><code class="p">);</code>
<code class="nx">result</code>  <code class="c">// Type is (string | number)[]</code></pre>

            <p class="author1">With conditionals, the type can even vary across branches. Here we show the same behavior
              with a simple value, rather than an array:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">let</code> <code class="nx">val</code><code class="p">;</code>  <code class="c">// Type is any</code>
<code class="kd">if</code> <code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">&lt;</code> <code class="mi">0.5</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">val</code> <code class="o">=</code> <code class="sr">/hello/</code><code class="p">;</code>
  <code class="nx">val</code>  <code class="c">// Type is RegExp</code>
<code class="p">}</code> <code class="kd">else</code> <code class="p">{</code>
  <code class="nx">val</code> <code class="o">=</code> <code class="mi">12</code><code class="p">;</code>
  <code class="nx">val</code>  <code class="c">// Type is number</code>
<code class="p">}</code>
<code class="nx">val</code>  <code class="c">// Type is number | RegExp</code></pre>

            <p class="author1">A final case that triggers this “evolving any” behavior is if a variable is initially
              <code class="calibre18">null</code>. This often comes up when you set a value in a <code
                class="calibre18">try</code>/<code class="calibre18">catch</code> block:
            </p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">let</code> <code class="nx">val</code> <code class="o">=</code> <code class="kd">null</code><code class="p">;</code>  <code class="c">// Type is any</code>
<code class="kd">try</code> <code class="p">{</code>
  <code class="nx">somethingDangerous</code><code class="p">();</code>
  <code class="nx">val</code> <code class="o">=</code> <code class="mi">12</code><code class="p">;</code>
  <code class="nx">val</code>  <code class="c">// Type is number</code>
<code class="p">}</code> <code class="kd">catch</code> <code class="p">(</code><code class="nx">e</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">warn</code><code class="p">(</code><code class="s">'alas!'</code><code class="p">);</code>
<code class="p">}</code>
<code class="nx">val</code>  <code class="c">// Type is number | null</code></pre>

            <p class="author1">Interestingly, this behavior only happens when a variable’s type is implicitly <code
                class="calibre18">any</code> with <code class="calibre18">noImplicitAny</code> set! Adding an <em
                class="calibre3">explicit</em> <code class="calibre18">any</code> keeps the type constant:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">let</code> <code class="nx">val</code>: <code class="nx">any</code><code class="p">;</code>  <code class="c">// Type is any</code>
<code class="kd">if</code> <code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">&lt;</code> <code class="mi">0.5</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">val</code> <code class="o">=</code> <code class="sr">/hello/</code><code class="p">;</code>
  <code class="nx">val</code>  <code class="c">// Type is any</code>
<code class="p">}</code> <code class="kd">else</code> <code class="p">{</code>
  <code class="nx">val</code> <code class="o">=</code> <code class="mi">12</code><code class="p">;</code>
  <code class="nx">val</code>  <code class="c">// Type is any</code>
<code class="p">}</code>
<code class="nx">val</code>  <code class="c">// Type is any</code></pre>
            <div data-type="note" type="note" class="calibre24">
              <h6 class="calibre25">Note</h6>
              <p class="author1">This behavior can be confusing to follow in your editor since the type is only
                “evolved” <em class="calibre3">after</em> you assign or push an element. Inspecting the type on the line
                with the assignment will still show <code class="calibre18">any</code> or <code
                  class="calibre18">any[]</code>.</p>
            </div>

            <p class="author1">If you use a value before any assignment to it, you’ll get an implicit any error:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">range</code><code class="p">(</code><code class="nx">start</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">limit</code>: <code class="nx">number</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">out</code> <code class="o">=</code> <code class="p">[];</code>
  <code class="c">//    ~~~ Variable 'out' implicitly has type 'any[]' in some</code>
  <code class="c">//        locations where its type cannot be determined</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">start</code> <code class="o">===</code> <code class="nx">limit</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">return</code> <code class="nx">out</code><code class="p">;</code>
    <code class="c">//     ~~~ Variable 'out' implicitly has an 'any[]' type</code>
  <code class="p">}</code>
  <code class="kd">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="nx">start</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">limit</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">out</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">i</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="kd">return</code> <code class="nx">out</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">Put another way, “evolving” <code class="calibre18">any</code> types are only <code
                class="calibre18">any</code> when you <em class="calibre3">write</em> to them. If you try to <em
                class="calibre3">read</em> from them while they’re still <code class="calibre18">any</code>, you’ll get
              an error.</p>

            <p class="author1">Implicit <code class="calibre18">any</code> types do not evolve through function calls.
              The arrow function here trips up inference:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">makeSquares</code><code class="p">(</code><code class="nx">start</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">limit</code>: <code class="nx">number</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">out</code> <code class="o">=</code> <code class="p">[];</code>
     <code class="c">// ~~~ Variable 'out' implicitly has type 'any[]' in some locations</code>
  <code class="nx">range</code><code class="p">(</code><code class="nx">start</code><code class="p">,</code> <code class="nx">limit</code><code class="p">).</code><code class="nx">forEach</code><code class="p">(</code><code class="nx">i</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="nx">out</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">i</code> <code class="o">*</code> <code class="nx">i</code><code class="p">);</code>
  <code class="p">});</code>
  <code class="kd">return</code> <code class="nx">out</code><code class="p">;</code>
      <code class="c">// ~~~ Variable 'out' implicitly has an 'any[]' type</code>
<code class="p">}</code></pre>

            <p class="author1">In cases like this, you may want to consider using an array’s <code
                class="calibre18">map</code> and <code class="calibre18">filter</code> methods to build arrays in a
              single statement and avoid iteration and evolving <code class="calibre18">any</code> entirely. See Items
              <a href="#calibre_link-33" class="calibre9">23</a> and <a href="#calibre_link-44" class="calibre9">27</a>.
            </p>

            <p class="author1">Evolving <code class="calibre18">any</code> comes with all the usual caveats about type
              inference. Is the correct type for your array really <code class="calibre18">(string|number)[]</code>? Or
              should it be <code class="calibre18">number[]</code> and you incorrectly pushed a <code
                class="calibre18">string</code>? You may still want to provide an explicit type annotation to get better
              error checking instead of using evolving <code class="calibre18">any</code>.</p>








            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-940">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">While TypeScript types typically only <em class="calibre3">refine</em>, implicit
                      <code class="calibre18">any</code> and <code class="calibre18">any[]</code> types are allowed to
                      <em class="calibre3">evolve</em>. You should be able to recognize and understand this construct
                      where it occurs.
                    </p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">For better error checking, consider providing an explicit type annotation instead
                      of using evolving <code class="calibre18">any</code>.<a data-primary=""
                        data-startref="TAexplicitany05" data-type="indexterm" id="calibre_link-562"
                        class="calibre9"></a><a data-primary="" data-startref="ATevolv05" data-type="indexterm"
                        id="calibre_link-89" class="calibre9"></a><a data-primary="" data-startref="anysquare05"
                        data-type="indexterm" id="calibre_link-103" class="calibre9"></a><a data-primary=""
                        data-startref="evolany05" data-type="indexterm" id="calibre_link-260" class="calibre9"></a></p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>













        <section data-pdf-bookmark="Item 42: Use unknown Instead of any for Values with an Unknown Type"
          data-type="sect1" class="praise">
          <div class="praise" id="calibre_link-40">
            <h1 class="calibre16">Item 42: Use unknown Instead of any for Values with an Unknown Type</h1>

            <p class="author1">Suppose<a data-primary="any types" data-secondary="unknown versus any types"
                data-type="indexterm" id="calibre_link-96" class="calibre9"></a><a data-primary="unknown types"
                data-secondary="unknown versus any types" data-type="indexterm" id="calibre_link-716"
                class="calibre9"></a><a data-primary="{ } type" data-type="indexterm" id="calibre_link-75"
                class="calibre9"></a><a data-primary="object type" data-type="indexterm" id="calibre_link-437"
                class="calibre9"></a><a data-primary="values" data-secondary="with unknown types"
                data-secondary-sortas="unknown types" data-type="indexterm" id="calibre_link-733" class="calibre9"></a>
              you want to write a<a data-primary="YAML" data-type="indexterm" id="calibre_link-749"
                class="calibre9"></a> YAML parser (YAML can represent the same set of values as<a data-primary="JSON"
                data-type="indexterm" id="calibre_link-370" class="calibre9"></a> JSON but allows a superset of JSON’s
              syntax). What should the return type of your <code class="calibre18">parseYAML</code> method be? It’s
              tempting to make it <code class="calibre18">any</code> (like <code class="calibre18">JSON.parse</code>):
            </p>

            <pre data-code-language="ts" data-type="programlisting" id="calibre_link-941" class="calibre17"><code class="kd">function</code> <code class="nx">parseYAML</code><code class="p">(</code><code class="nx">yaml</code>: <code class="kd">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">any</code> <code class="p">{</code>
  <code class="c">// ...</code>
<code class="p">}</code></pre>

            <p class="author1">But this flies in the face of <a href="#calibre_link-45" class="calibre9">Item 38</a>’s
              advice to avoid “contagious” <code class="calibre18">any</code> types, specifically by not returning them
              from functions.</p>

            <p class="author1">Ideally you’d like your users to immediately assign the result to another type:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Book</code> <code class="p">{</code>
  <code class="nx">name</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">author</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">const</code> <code class="nx">book</code>: <code class="nx">Book</code> <code class="o">=</code> <code class="nx">parseYAML</code><code class="p">(</code><code class="s">`</code>
<code class="s">  name: Wuthering Heights</code>
<code class="s">  author: Emily Brontë</code>
<code class="s">`</code><code class="p">);</code></pre>

            <p class="author1">Without the type declarations, though, the <code class="calibre18">book</code> variable
              would quietly get an <code class="calibre18">any</code> type, thwarting type checking wherever it’s used:
            </p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">book</code> <code class="o">=</code> <code class="nx">parseYAML</code><code class="p">(</code><code class="s">`</code>
<code class="s">  name: Jane Eyre</code>
<code class="s">  author: Charlotte Brontë</code>
<code class="s">`</code><code class="p">);</code>
<code class="nx">alert</code><code class="p">(</code><code class="nx">book</code><code class="p">.</code><code class="nx">title</code><code class="p">);</code>  <code class="c">// No error, alerts "undefined" at runtime</code>
<code class="nx">book</code><code class="p">(</code><code class="s">'read'</code><code class="p">);</code>  <code class="c">// No error, throws "TypeError: book is not a</code>
               <code class="c">// function" at runtime</code></pre>

            <p class="author1">A safer alternative would be to have <code class="calibre18">parseYAML</code> return an
              <code class="calibre18">unknown</code> type:
            </p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">safeParseYAML</code><code class="p">(</code><code class="nx">yaml</code>: <code class="kd">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">unknown</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">parseYAML</code><code class="p">(</code><code class="nx">yaml</code><code class="p">);</code>
<code class="p">}</code>
<code class="kd">const</code> <code class="nx">book</code> <code class="o">=</code> <code class="nx">safeParseYAML</code><code class="p">(</code><code class="s">`</code>
<code class="s">  name: The Tenant of Wildfell Hall</code>
<code class="s">  author: Anne Brontë</code>
<code class="s">`</code><code class="p">);</code>
<code class="nx">alert</code><code class="p">(</code><code class="nx">book</code><code class="p">.</code><code class="nx">title</code><code class="p">);</code>
   <code class="c">// ~~~~ Object is of type 'unknown'</code>
<code class="nx">book</code><code class="p">(</code><code class="s">"read"</code><code class="p">);</code>
<code class="c">// ~~~~~~~~~~ Object is of type 'unknown'</code></pre>

            <p class="author1">To understand the <code class="calibre18">unknown</code> type, it helps to think about
              <code class="calibre18">any</code> in terms of assignability. The power and danger of <code
                class="calibre18">any</code> come from two properties:
            </p>

            <ul class="printings">
              <li class="calibre12">
                <p class="author1">Any type is assignable to the <code class="calibre18">any</code> type.</p>
              </li>
              <li class="calibre12">
                <p class="author1">The <code class="calibre18">any</code> type is assignable to any other type.<sup
                    class="calibre44"><a data-type="noteref" href="#calibre_link-46" id="calibre_link-54"
                      class="calibre45">2</a></sup></p>
              </li>
            </ul>

            <p class="author1">In the context of “thinking of types as sets of values” (<a href="#calibre_link-47"
                class="calibre9">Item 7</a>), <code class="calibre18">any</code> clearly doesn’t fit into the type
              system, since a set can’t simultaneously be both a subset and a superset of all other sets. This is the
              source of <code class="calibre18">any</code>’s power but also the reason it’s problematic. Since the type
              checker is set-based, the use of <code class="calibre18">any</code> effectively disables it.</p>

            <p class="author1">The <code class="calibre18">unknown</code> type is an alternative to <code
                class="calibre18">any</code> that <em class="calibre3">does</em> fit into the type system. It has the
              first property (any type is assignable to <code class="calibre18">unknown</code>) but not the second
              (<code class="calibre18">unknown</code> is only assignable to <code class="calibre18">unknown</code> and,
              of course, <code class="calibre18">any</code>). The<a data-primary="never type" data-type="indexterm"
                id="calibre_link-415" class="calibre9"></a> <code class="calibre18">never</code> type is the opposite:
              it has the second property (can be assigned to any other type) but not the first (nothing can be assigned
              to <code class="calibre18">never</code>).</p>

            <p class="author1">Attempting to access a property on a value with the <code
                class="calibre18">unknown</code> type is an error. So is attempting to call it or do arithmetic with it.
              You can’t do much with <code class="calibre18">unknown</code>, which is exactly the point. The errors
              about an <code class="calibre18">unknown</code> type will encourage you to add an appropriate type:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">book</code> <code class="o">=</code> <code class="nx">safeParseYAML</code><code class="p">(</code><code class="s">`</code>
<code class="s">  name: Villette</code>
<code class="s">  author: Charlotte Brontë</code>
<code class="s">`</code><code class="p">)</code> <code class="kd">as</code> <code class="nx">Book</code><code class="p">;</code>
<code class="nx">alert</code><code class="p">(</code><code class="nx">book</code><code class="p">.</code><code class="nx">title</code><code class="p">);</code>
        <code class="c">// ~~~~~ Property 'title' does not exist on type 'Book'</code>
<code class="nx">book</code><code class="p">(</code><code class="s">'read'</code><code class="p">);</code>
<code class="c">// ~~~~~~~~~ this expression is not callable</code></pre>

            <p class="author1">These errors are more sensible. Since <code class="calibre18">unknown</code> is not
              assignable to other types, a type assertion is required. But it is also appropriate: we really do know
              more about the type of the resulting object than TypeScript does.</p>

            <p class="author1"><code class="calibre18">unknown</code> is appropriate whenever you know that there will
              be a value but you don’t know its type. The result of <code class="calibre18">parseYAML</code> is one
              example, but there are others. In<a data-primary="GeoJSON" data-type="indexterm" id="calibre_link-297"
                class="calibre9"></a> the GeoJSON spec, for example, the <code class="calibre18">properties</code>
              property of a Feature is a grab-bag of anything<a data-primary="JSON" data-type="indexterm"
                id="calibre_link-371" class="calibre9"></a><a data-primary="Geometry" data-type="indexterm"
                id="calibre_link-300" class="calibre9"></a> JSON serializable. So <code class="calibre18">unknown</code>
              makes sense:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Feature</code> <code class="p">{</code>
  <code class="nx">id?</code>: <code class="kd">string</code> <code class="o">|</code> <code class="kt">number</code><code class="p">;</code>
  <code class="nx">geometry</code>: <code class="nx">Geometry</code><code class="p">;</code>
  <code class="nx">properties</code>: <code class="nx">unknown</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">A type assertion isn’t the only way to recover a type from an <code
                class="calibre18">unknown</code> object. An <code class="calibre18">instanceof</code> check will do:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">processValue</code><code class="p">(</code><code class="nx">val</code>: <code class="nx">unknown</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">val</code> <code class="kd">instanceof</code> <code class="nb">Date</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">val</code>  <code class="c">// Type is Date</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

            <p class="author1">You can also use a user-defined type guard:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">isBook</code><code class="p">(</code><code class="nx">val</code>: <code class="nx">unknown</code><code class="p">)</code><code class="o">:</code> <code class="nx">val</code> <code class="nx">is</code> <code class="nx">Book</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="p">(</code>
      <code class="kd">typeof</code><code class="p">(</code><code class="nx">val</code><code class="p">)</code> <code class="o">===</code> <code class="s">'object'</code> <code class="o">&amp;&amp;</code> <code class="nx">val</code> <code class="o">!==</code> <code class="kd">null</code> <code class="o">&amp;&amp;</code>
      <code class="s">'name'</code> <code class="kd">in</code> <code class="nx">val</code> <code class="o">&amp;&amp;</code> <code class="s">'author'</code> <code class="kd">in</code> <code class="nx">val</code>
  <code class="p">);</code>
<code class="p">}</code>
<code class="kd">function</code> <code class="nx">processValue</code><code class="p">(</code><code class="nx">val</code>: <code class="nx">unknown</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">isBook</code><code class="p">(</code><code class="nx">val</code><code class="p">))</code> <code class="p">{</code>
    <code class="nx">val</code><code class="p">;</code>  <code class="c">// Type is Book</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

            <p class="author1">TypeScript requires quite a bit of proof to narrow an <code
                class="calibre18">unknown</code> type: in order to avoid errors on the <code class="calibre18">in</code>
              checks, you first have to demonstrate that <code class="calibre18">val</code> is an object type and that
              it is non-<code class="calibre18">null</code> (since <code
                class="calibre18">typeof null === 'object'</code>).</p>

            <p class="author1">You’ll sometimes see a generic parameter used instead of <code
                class="calibre18">unknown</code>. You could have declared the <code
                class="calibre18">safeParseYAML</code> function this way:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">safeParseYAML</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">yaml</code>: <code class="kd">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">T</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">parseYAML</code><code class="p">(</code><code class="nx">yaml</code><code class="p">);</code>
<code class="p">}</code></pre>

            <p class="author1">This is generally considered bad style in TypeScript, however. It looks different than a
              type assertion, but is functionally the same. Better to just return <code class="calibre18">unknown</code>
              and force your users to use an assertion or narrow to the type they want.</p>

            <p class="author1"><code class="calibre18">unknown</code> can<a data-primary="double assertion"
                data-type="indexterm" id="calibre_link-221" class="calibre9"></a> also be used instead of <code
                class="calibre18">any</code> in “double assertions”:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">declare</code> <code class="kd">const</code> <code class="nx">foo</code>: <code class="nx">Foo</code><code class="p">;</code>
<code class="kd">let</code> <code class="nx">barAny</code> <code class="o">=</code> <code class="nx">foo</code> <code class="kd">as</code> <code class="nx">any</code> <code class="kd">as</code> <code class="nx">Bar</code><code class="p">;</code>
<code class="kd">let</code> <code class="nx">barUnk</code> <code class="o">=</code> <code class="nx">foo</code> <code class="kd">as</code> <code class="nx">unknown</code> <code class="kd">as</code> <code class="nx">Bar</code><code class="p">;</code></pre>

            <p class="author1">These are functionally equivalent, but the <code class="calibre18">unknown</code> form
              has less risk if you do a refactor and break up the two assertions. In that case the <code
                class="calibre18">any</code> could escape and spread. If the <code class="calibre18">unknown</code> type
              escapes, it will probably just produce an error.</p>

            <p class="author1">As a final note, you may see code that uses <code class="calibre18">object</code> or
              <code class="calibre18">{}</code> in a similar way to how <code class="calibre18">unknown</code> has been
              described in this item. They are also broad types but are slightly narrower than <code
                class="calibre18">unknown</code>:
            </p>

            <ul class="printings">
              <li class="calibre12">
                <p class="author1">The <code class="calibre18">{}</code> type consists of all values except <code
                    class="calibre18">null</code> and <code class="calibre18">undefined</code>.</p>
              </li>
              <li class="calibre12">
                <p class="author1">The <code class="calibre18">object</code> type consists of all non-primitive types.
                  This doesn’t include <code class="calibre18">true</code> or <code class="calibre18">12</code> or <code
                    class="calibre18">"foo"</code> but does include objects and arrays.</p>
              </li>
            </ul>

            <p class="author1">The use of <code class="calibre18">{}</code> was more common before the <code
                class="calibre18">unknown</code> type was introduced. Uses today are somewhat rare: only use <code
                class="calibre18">{}</code> instead of <code class="calibre18">unknown</code> if you really do know that
              <code class="calibre18">null</code> and <code class="calibre18">undefined</code> aren’t possibilities.
            </p>








            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-942">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">The <code class="calibre18">unknown</code> type is a type-safe alternative to
                      <code class="calibre18">any</code>. Use it when you know you have a value but do not know what its
                      type is.
                    </p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Use <code class="calibre18">unknown</code> to force your users to use a type
                      assertion or do type checking.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Understand the difference between <code class="calibre18">{}</code>, <code
                        class="calibre18">object</code>, and <code class="calibre18">unknown</code>.<a data-primary=""
                        data-startref="Vunk05" data-type="indexterm" id="calibre_link-734" class="calibre9"></a><a
                        data-primary="" data-startref="obj05" data-type="indexterm" id="calibre_link-438"
                        class="calibre9"></a><a data-primary="" data-startref="curlytype05" data-type="indexterm"
                        id="calibre_link-76" class="calibre9"></a><a data-primary="" data-startref="UTunknown05"
                        data-type="indexterm" id="calibre_link-717" class="calibre9"></a><a data-primary=""
                        data-startref="ATunknow05" data-type="indexterm" id="calibre_link-97" class="calibre9"></a></p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>













        <section data-pdf-bookmark="Item 43: Prefer Type-Safe Approaches to Monkey Patching" data-type="sect1"
          class="praise">
          <div class="praise" id="calibre_link-764">
            <h1 class="calibre16">Item 43: Prefer Type-Safe Approaches to Monkey Patching</h1>

            <p class="author1">One<a data-primary="any types"
                data-secondary="type-safe approaches versus monkey-patching" data-type="indexterm" id="calibre_link-95"
                class="calibre9"></a><a data-primary="global variables" data-type="indexterm" id="calibre_link-301"
                class="calibre9"></a><a data-primary="built-in types, storing data on" data-type="indexterm"
                id="calibre_link-138" class="calibre9"></a><a data-primary="augmentation" data-type="indexterm"
                id="calibre_link-125" class="calibre9"></a><a data-primary="declaration merging" data-type="indexterm"
                id="calibre_link-207" class="calibre9"></a><a data-primary="JavaScript" data-secondary="open classes in"
                data-type="indexterm" id="calibre_link-353" class="calibre9"></a><a data-primary="type safety"
                data-secondary="type-safe approaches versus monkey-patching" data-type="indexterm" id="calibre_link-635"
                class="calibre9"></a><a data-primary="properties" data-secondary="attaching to built-in types"
                data-type="indexterm" id="calibre_link-466" class="calibre9"></a> of the most famous features of
              JavaScript is that its objects and classes are “open” in the sense that you can add arbitrary properties
              to them. This is occasionally used to create global variables on web pages by assigning to <code
                class="calibre18">window</code> or <code class="calibre18">document</code>:</p>

            <pre data-code-language="js" data-type="programlisting"
              class="calibre17"><code class="nb">window</code><code class="p">.</code><code class="nx">monkey</code> <code class="o">=</code> <code class="s">'Tamarin'</code><code class="p">;</code>
<code class="nb">document</code><code class="p">.</code><code class="nx">monkey</code> <code class="o">=</code> <code class="s">'Howler'</code><code class="p">;</code></pre>

            <p class="author1">or to attach data to DOM elements:</p>

            <pre data-code-language="js" data-type="programlisting"
              class="calibre17"><code class="kd">const</code> <code class="nx">el</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s">'colobus'</code><code class="p">);</code>
<code class="nx">el</code><code class="p">.</code><code class="nx">home</code> <code class="o">=</code> <code class="s">'tree'</code><code class="p">;</code></pre>

            <p class="author1">This<a data-primary="jQuery" data-secondary="type-safe approaches versus monkey-patching"
                data-type="indexterm" id="calibre_link-364" class="calibre9"></a> style is particularly common with code
              that uses jQuery.</p>

            <p class="author1">You can even attach properties to the prototypes of built-ins, with sometimes surprising
              results:</p>
            <pre data-code-language="javascript" data-type="programlisting" class="calibre17"><code class="o">&gt;</code><code class="calibre18"> </code><strong class="calibre32"><code class="calibre22"> </code><code class="nb1">RegExp</code><code class="p1">.</code><code class="nx1">prototype</code><code class="p1">.</code><code class="nx1">monkey</code><code class="calibre22"> </code><code class="o1">=</code><code class="calibre22"> </code><code class="s1">'Capuchin'</code></strong><code class="calibre18">
</code><code class="s">"Capuchin"</code><code class="calibre18">
</code><code class="o">&gt;</code><code class="calibre18"> </code><strong class="calibre32"><code class="sr1">/123/</code><code class="p1">.</code><code class="nx1">monkey</code></strong><code class="calibre18">
</code><code class="s">"Capuchin"</code></pre>

            <p class="author1">These approaches are generally not good designs. When you attach data to <code
                class="calibre18">window</code> or a DOM node, you are essentially turning it into a global variable.
              This makes it easy to inadvertently introduce dependencies between far-flung parts of your program and
              means that you have to think about side effects whenever you call a function.</p>

            <p class="author1">Adding TypeScript introduces another problem: while the type checker knows about built-in
              properties of <code class="calibre18">Document</code> and <code class="calibre18">HTMLElement</code>, it
              certainly doesn’t know about the ones you’ve added:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="nb">document</code><code class="p">.</code><code class="nx">monkey</code> <code class="o">=</code> <code class="s">'Tamarin'</code><code class="p">;</code>
      <code class="c">// ~~~~~~ Property 'monkey' does not exist on type 'Document'</code></pre>

            <p class="author1">The most straightforward way to fix this error is with an <code
                class="calibre18">any</code> assertion:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="p">(</code><code class="nb">document</code> <code class="kd">as</code> <code class="nx">any</code><code class="p">).</code><code class="nx">monkey</code> <code class="o">=</code> <code class="s">'Tamarin'</code><code class="p">;</code>  <code class="c">// OK</code></pre>

            <p class="author1">This satisfies the type checker, but, as should be no surprise by now, it has some
              downsides. As with any use of <code class="calibre18">any</code>, you lose type safety and language
              services:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="p">(</code><code class="nb">document</code> <code class="kd">as</code> <code class="nx">any</code><code class="p">).</code><code class="nx">monky</code> <code class="o">=</code> <code class="s">'Tamarin'</code><code class="p">;</code>  <code class="c">// Also OK, misspelled</code>
<code class="p">(</code><code class="nb">document</code> <code class="kd">as</code> <code class="nx">any</code><code class="p">).</code><code class="nx">monkey</code> <code class="o">=</code> <code class="sr">/Tamarin/</code><code class="p">;</code>  <code class="c">// Also OK, wrong type</code></pre>

            <p class="author1">The best solution is to move your data out of <code class="calibre18">document</code> or
              the DOM. But if you can’t (perhaps you’re using a library that requires it or are in the process of
              migrating a JavaScript application), then you have a few next-best options available.</p>

            <p class="author1">One is to use an augmentation, one of the special abilities of <code
                class="calibre18">interface</code> (<a href="#calibre_link-48" class="calibre9">Item 13</a>):</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">interface</code> <code class="nx">Document</code> <code class="p">{</code>
  <code class="c">/** Genus or species of monkey patch */</code>
  <code class="nx">monkey</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>

<code class="nb">document</code><code class="p">.</code><code class="nx">monkey</code> <code class="o">=</code> <code class="s">'Tamarin'</code><code class="p">;</code>  <code class="c">// OK</code></pre>

            <p class="author1">This is an improvement over using <code class="calibre18">any</code> in a few ways:</p>

            <ul class="printings">
              <li class="calibre12">
                <p class="author1">You get type safety. The type checker will flag misspellings or assignments of the
                  wrong type.</p>
              </li>
              <li class="calibre12">
                <p class="author1">You can attach documentation to the property (<a href="#calibre_link-49"
                    class="calibre9">Item 48</a>).</p>
              </li>
              <li class="calibre12">
                <p class="author1">You get autocomplete on the property.</p>
              </li>
              <li class="calibre12">
                <p class="author1">There is a record of precisely what the monkey patch is.</p>
              </li>
            </ul>

            <p class="author1">In a module context (i.e., a TypeScript file that uses <code
                class="calibre18">import</code> / <code class="calibre18">export</code>), you’ll need to add a <code
                class="calibre18">declare global</code> to make this work:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">export</code> <code class="p">{};</code>
<code class="kd">declare</code> <code class="nx">global</code> <code class="p">{</code>
  <code class="kd">interface</code> <code class="nx">Document</code> <code class="p">{</code>
    <code class="c">/** Genus or species of monkey patch */</code>
    <code class="nx">monkey</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>
<code class="nb">document</code><code class="p">.</code><code class="nx">monkey</code> <code class="o">=</code> <code class="s">'Tamarin'</code><code class="p">;</code>  <code class="c">// OK</code></pre>

            <p class="author1">The main issues with using an augmentation have to do with scope. First, the augmentation
              applies globally. You can’t hide it from other parts of your code or from libraries. And second, if you
              assign the property while your application is running, there’s no way to introduce the augmentation only
              after this has happened. This is particularly problematic when you patch HTML Elements, where some
              elements on the page will have the property and some will not. For this reason, you might want to declare
              the property to be <code class="calibre18">string|undefined</code>. This is more accurate, but will make
              the type less convenient to work with.</p>

            <p class="author1">Another approach is to use a more precise type assertion:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">interface</code> <code class="nx">MonkeyDocument</code> <code class="kd">extends</code> <code class="nx">Document</code> <code class="p">{</code>
  <code class="c">/** Genus or species of monkey patch */</code>
  <code class="nx">monkey</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>

<code class="p">(</code><code class="nb">document</code> <code class="kd">as</code> <code class="nx">MonkeyDocument</code><code class="p">).</code><code class="nx">monkey</code> <code class="o">=</code> <code class="s">'Macaque'</code><code class="p">;</code></pre>

            <p class="author1">TypeScript is OK with the type assertion because <code class="calibre18">Document</code>
              and <code class="calibre18">MonkeyDocument</code> share properties (<a href="#calibre_link-27"
                class="calibre9">Item 9</a>). And you get type safety in the assignment. The scope issues are also more
              manageable: there’s no global modification of the <code class="calibre18">Document</code> type, just the
              introduction of a new type (which is only in scope if you import it). You have to write an assertion (or
              introduce a new variable) whenever you reference the monkey-patched property. But you can take that as
              encouragement to refactor into something more structured. Monkey patching shouldn’t be <em
                class="calibre3">too</em> easy!</p>








            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-943">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">Prefer structured code to storing data in globals or on the DOM.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">If you must store data on built-in types, use one of the type-safe approaches
                      (augmentation or asserting a custom interface).</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Understand the scoping issues of augmentations.</p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>













        <section data-pdf-bookmark="Item 44: Track Your Type Coverage to Prevent Regressions in Type Safety"
          data-type="sect1" class="praise">
          <div class="praise" id="calibre_link-765">
            <h1 class="calibre16">Item 44: Track Your Type Coverage to Prevent Regressions in Type Safety</h1>

            <p class="author1">Are<a data-primary="any types" data-secondary="preventing regressions in type safety"
                data-type="indexterm" id="calibre_link-94" class="calibre9"></a><a data-primary="type safety"
                data-secondary="preventing regressions in" data-type="indexterm" id="calibre_link-633"
                class="calibre9"></a><a data-primary="noImplicitAny" data-type="indexterm" id="calibre_link-421"
                class="calibre9"></a><a data-primary="@types (type dependencies)"
                data-secondary="preventing regressions in type safety" data-type="indexterm" id="calibre_link-71"
                class="calibre9"></a><a data-primary="third-party type declarations" data-type="indexterm"
                id="calibre_link-536" class="calibre9"></a><a data-primary="type declaration"
                data-secondary="third-party" data-type="indexterm" id="calibre_link-577" class="calibre9"></a><a
                data-primary="any[ ] types" data-type="indexterm" id="calibre_link-104" class="calibre9"></a><a
                data-primary="{[key: string]: any} type" data-type="indexterm" id="calibre_link-80"
                class="calibre9"></a> you safe from the problems associated with any types once you’ve added type
              annotations for values with implicit <code class="calibre18">any</code> types and enabled <code
                class="calibre18">noImplicitAny</code>? The answer is “no”; <code class="calibre18">any</code> types can
              still enter your program in two main ways:</p>
            <dl class="praise">
              <dt class="calibre19"><em class="calibre3">Explicit</em> <code class="calibre18">any</code> types</dt>
              <dd class="calibre20">
                <p class="author1">Even if you follow the advice of Items <a href="#calibre_link-45"
                    class="calibre9">38</a> and <a href="#calibre_link-50" class="calibre9">39</a>, making your <code
                    class="calibre18">any</code> types both narrow and specific, they remain <code
                    class="calibre18">any</code> types. In particular, types like <code class="calibre18">any[]</code>
                  and <code class="calibre18">{[key: string]: any}</code> become plain <code
                    class="calibre18">any</code>s once you index into them, and the resulting <code
                    class="calibre18">any</code> types can flow through your code.</p>
              </dd>
              <dt class="calibre19">From third-party type declarations</dt>
              <dd class="calibre20">
                <p class="author1">This is particularly insidious since <code class="calibre18">any</code> types from an
                  <code class="calibre18">@types</code> declaration file enter silently: even though you have <code
                    class="calibre18">noImplicitAny</code> enabled and you never typed <code
                    class="calibre18">any</code>, you still have <code class="calibre18">any</code> types flowing
                  through your code.
                </p>
              </dd>
            </dl>

            <p class="author1">Because of the negative effects <code class="calibre18">any</code> types can have on type
              safety and developer experience (<a href="#calibre_link-51" class="calibre9">Item 5</a>), it’s a good idea
              to keep track of the number of them in your codebase. There are many ways to do this, including the <code
                class="calibre18">type-coverage</code> package on npm:</p>

            <pre data-type="programlisting" class="calibre17">$ npx type-coverage
9985 / 10117 98.69%</pre>

            <p class="author1">This means that, of the 10,117 symbols in this project, 9,985 (98.69%) had a type other
              than <code class="calibre18">any</code> or an alias to <code class="calibre18">any</code>. If a change
              inadvertently introduces an <code class="calibre18">any</code> type and it flows through your code, you’ll
              see a corresponding drop in this percentage.</p>

            <p class="author1">In some ways this percentage is a way of keeping score on how well you’ve followed the
              advice of the other items in this chapter. Using narrowly scoped <code class="calibre18">any</code> will
              reduce the number of symbols with <code class="calibre18">any</code> types, and so will using more
              specific forms like <code class="calibre18">any[]</code>. Tracking this numerically helps you make sure
              things only get better over time.</p>

            <p class="author1">Even collecting type coverage information once can be informative. Running <code
                class="calibre18">type-coverage</code> with the <code class="calibre18">--detail</code> flag will print
              where every <code class="calibre18">any</code> type occurs in your code:</p>

            <pre data-type="programlisting" class="calibre17">$ npx type-coverage --detail
path/to/code.ts:1:10 getColumnInfo
path/to/module.ts:7:1 pt2
...</pre>

            <p class="author1">These are worth investigating because they’re likely to turn up sources of <code
                class="calibre18">any</code>s that you hadn’t considered. Let’s look at a few examples.</p>

            <p class="author1">Explicit <code class="calibre18">any</code> types are often the result of choices you
              made for expediency earlier on. Perhaps you were getting a type error that you didn’t want to take the
              time to sort out. Or maybe the type was one that you hadn’t written out yet. Or you might have just been
              in a rush.</p>

            <p class="author1">Type assertions with <code class="calibre18">any</code> can prevent types from flowing
              where they otherwise would. Perhaps you’ve built an application that works with tabular data and needed a
              single-parameter function that built up some kind of column description:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">getColumnInfo</code><code class="p">(</code><code class="nx">name</code>: <code class="kd">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">any</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">utils</code><code class="p">.</code><code class="nx">buildColumnInfo</code><code class="p">(</code><code class="nx">appState</code><code class="p">.</code><code class="nx">dataSchema</code><code class="p">,</code> <code class="nx">name</code><code class="p">);</code>  <code class="c">// Returns any</code>
<code class="p">}</code></pre>

            <p class="author1">The <code class="calibre18">utils.buildColumnInfo</code> function returned <code
                class="calibre18">any</code> at some point. As a reminder, you added a comment and an explicit “: any”
              annotation to the function.</p>

            <p class="author1">However, in the intervening months you’ve also added a type for <code
                class="calibre18">ColumnInfo</code>, and <code class="calibre18">utils.buildColumnInfo</code> no longer
              returns <code class="calibre18">any</code>. The <code class="calibre18">any</code> annotation is now
              throwing away valuable type information. Get rid of it!</p>

            <p class="author1">Third-party <code class="calibre18">any</code> types can come in a few forms, but the
              most extreme is when you give an entire module an <code class="calibre18">any</code> type:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">declare</code> <code class="nx">module</code> <code class="s">'my-module'</code><code class="p">;</code></pre>

            <p class="author1">Now you can import anything from <code class="calibre18">my-module</code> without error.
              These symbols all have <code class="calibre18">any</code> types and will lead to more <code
                class="calibre18">any</code> types if you pass values through them:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">import</code> <code class="p">{</code><code class="nx">someMethod</code><code class="p">,</code> <code class="nx">someSymbol</code><code class="p">}</code> <code class="nx">from</code> <code class="s">'my-module'</code><code class="p">;</code>  <code class="c">// OK</code>

<code class="kd">const</code> <code class="nx">pt1</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">x</code>: <code class="nx">1</code><code class="p">,</code>
  <code class="nx">y</code>: <code class="nx">2</code><code class="p">,</code>
<code class="p">};</code>  <code class="c">// type is {x: number, y: number}</code>
<code class="kd">const</code> <code class="nx">pt2</code> <code class="o">=</code> <code class="nx">someMethod</code><code class="p">(</code><code class="nx">pt1</code><code class="p">,</code> <code class="nx">someSymbol</code><code class="p">);</code>  <code class="c">// OK, pt2's type is any</code></pre>

            <p class="author1">Since the usage looks identical to a well-typed module, it’s easy to forget that you
              stubbed out the module. Or maybe a coworker did it and you never knew in the first place. It’s worth
              revisiting these from time to time. Maybe there are official type declarations for the module. Or perhaps
              you’ve gained enough understanding of the module to write types yourself and contribute them back to the
              community.</p>

            <p class="author1">Another common source of <code class="calibre18">any</code>s with third-party
              declarations is when there’s a bug in the types. Maybe the declarations didn’t follow the advice of <a
                href="#calibre_link-52" class="calibre9">Item 29</a> and declared a function to return a union type when
              in fact it returns something much more specific. When you first used the function this didn’t seem worth
              fixing so you used an <code class="calibre18">any</code> assertion. But maybe the declarations have been
              fixed since then. Or maybe it’s time to fix them yourself!</p>

            <p class="author1">The considerations that led you to use an <code class="calibre18">any</code> type might
              not apply any more. Maybe there’s a type you can plug in now where previously you used <code
                class="calibre18">any</code>. Maybe an unsafe type assertion is no longer necessary. Maybe the bug in
              the type declarations you were working around has been fixed. Tracking your type coverage highlights these
              choices and encourages you to keep revisiting them.</p>








            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-944">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">Even with <code class="calibre18">noImplicitAny</code> set, <code
                        class="calibre18">any</code> types can make their way into your code either through explicit
                      <code class="calibre18">any</code>s or third-party type declarations (<code
                        class="calibre18">@types</code>).
                    </p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Consider tracking how well-typed your program is. This will encourage you to
                      revisit decisions about using <code class="calibre18">any</code> and increase type safety over
                      time.</p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>







        <div data-type="footnotes" class="calibre46">
          <p data-type="footnote" id="calibre_link-41" class="calibre47"><sup class="calibre48"><a
                href="#calibre_link-53" class="calibre49">1</a></sup> If you are using React, you should use the
            built-in <code class="calibre18">useMemo</code> hook, rather than rolling your own.</p>
          <p data-type="footnote" id="calibre_link-46" class="calibre47"><sup class="calibre48"><a
                href="#calibre_link-54" class="calibre49">2</a></sup> With the exception of <code
              class="calibre18">never</code>.</p>
        </div>
      </div>
    </section>
  </div>

  <div data-type="book" class="calibre1" id="calibre_link-0">
    <section data-pdf-bookmark="Chapter 6. Types Declarations and @types" data-type="chapter" type="chapter"
      class="praise">
      <div class="praise" id="calibre_link-791">
        <h1 class="calibre14"><span class="calibre">Chapter 6. </span>Types Declarations and @types</h1>


        <p class="author1">Dependency management can be confusing in any language, and TypeScript is no exception. This
          chapter will help you build a mental model for how dependencies work in TypeScript and show you how to work
          through some of the issues that can come up with them. It will also help you craft your own type declaration
          files to publish and share with others. By writing great type declarations, you can help not just your own
          project but the entire TypeScript community.</p>






        <section data-pdf-bookmark="Item 45: Put TypeScript and @types in devDependencies" data-type="sect1"
          class="praise">
          <div class="praise" id="calibre_link-2">
            <h1 class="calibre16">Item 45: Put TypeScript and @types in devDependencies</h1>

            <p class="author1">The<a data-primary="type dependencies" data-see="@types" data-type="indexterm"
                id="calibre_link-945" class="calibre9"></a><a
                data-primary="Node Package Manager (npm), dependency distinctions in" data-type="indexterm"
                id="calibre_link-417" class="calibre9"></a><a data-primary="dependencies" data-type="indexterm"
                id="calibre_link-212" class="calibre9"></a><a data-primary="@types (type dependencies)"
                data-secondary="installing in devDependencies" data-type="indexterm" id="calibre_link-69"
                class="calibre9"></a><a data-primary="devDependencies" data-type="indexterm" id="calibre_link-214"
                class="calibre9"></a><a data-primary="TypeScript" data-secondary="installing as a devDependency"
                data-type="indexterm" id="calibre_link-678" class="calibre9"></a><a data-primary="type declaration"
                data-secondary="TypeScript and @types" data-type="indexterm" id="calibre_link-584" class="calibre9"></a>
              Node Package Manager, npm, is ubiquitous in the JavaScript world. It provides both a repository of
              JavaScript libraries (the npm registry) and a way to specify which versions of them you depend on (<em
                class="calibre3">package.json</em>).</p>

            <p class="author1">npm draws a distinction between a few types of dependencies, each of which goes in a
              separate section of <em class="calibre3">package.json</em>:</p>
            <dl class="praise">
              <dt class="calibre19"><code class="calibre18">dependencies</code></dt>
              <dd class="calibre20">
                <p class="author1">These<a data-primary="Lodash library" data-type="indexterm" id="calibre_link-387"
                    class="calibre9"></a> are packages that are required to run your JavaScript. If you import <code
                    class="calibre18">lodash</code> at runtime, then it should go in <code
                    class="calibre18">dependencies</code>. When you publish your code on npm and another user installs
                  it, it will also install these dependencies. (These are known as transitive dependencies.)</p>
              </dd>
              <dt class="calibre19"><code class="calibre18">devDependencies</code></dt>
              <dd class="calibre20">
                <p class="author1">These packages are used to develop and test your code but are not required at
                  runtime. Your test framework would be an example of a <code class="calibre18">devDependency</code>.
                  Unlike <code class="calibre18">dependencies</code>, these are <em class="calibre3">not</em> installed
                  transitively with your packages.</p>
              </dd>
              <dt class="calibre19"><code class="calibre18">peerDependencies</code></dt>
              <dd class="calibre20">
                <p class="author1">These are packages that you require at runtime but don’t want to be responsible for
                  tracking. The canonical example is a plug-in. Your<a data-primary="jQuery"
                    data-secondary="dependencies" data-type="indexterm" id="calibre_link-361" class="calibre9"></a>
                  jQuery plug-in is compatible with a range of versions of jQuery itself, but you’d prefer that the user
                  select one, rather than you choosing for them.</p>
              </dd>
            </dl>

            <p class="author1">Of these, <code class="calibre18">dependencies</code> and <code
                class="calibre18">devDependencies</code> are by far the most common. As you use TypeScript, be aware of
              which type of dependency you’re adding. Because TypeScript is a development tool and TypeScript types do
              not exist at runtime (<a href="#calibre_link-1" class="calibre9">Item 3</a>), packages related to
              TypeScript generally belong in <code class="calibre18">devDependencies</code>.</p>

            <p class="author1">The first dependency to consider is TypeScript itself. It is possible to install
              TypeScript system-wide, but this is generally a bad idea for two reasons:</p>

            <ul class="printings">
              <li class="calibre12">
                <p class="author1">There’s no guarantee that you and your coworkers will always have the same version
                  installed.</p>
              </li>
              <li class="calibre12">
                <p class="author1">It adds a step to your project setup.</p>
              </li>
            </ul>

            <p class="author1">Make TypeScript a <code class="calibre18">devDependency</code> instead. That way you and
              your coworkers will always get the correct version when you run <code
                class="calibre18">npm install</code>. And updating your TypeScript version follows the same pattern as
              updating any other package.</p>

            <p class="author1">Your IDE and build tools will happily discover a version of TypeScript installed in this
              way. On the command line you can use <code class="calibre18">npx</code> to run the version of <code
                class="calibre18">tsc</code> installed by npm:</p>
            <pre data-type="programlisting" class="calibre17">$ <strong class="calibre32">npx tsc</strong></pre>

            <p class="author1">The<a data-primary="DefinitelyTyped" data-type="indexterm" id="calibre_link-210"
                class="calibre9"></a> next type of dependency to consider is <em class="calibre3">type dependencies</em>
              or <code class="calibre18">@types</code>. If a library itself does not come with TypeScript type
              declarations, then you may still be able to find typings on DefinitelyTyped, a community-maintained
              collection of type definitions for JavaScript libraries. Type definitions from DefinitelyTyped are
              published on the npm registry under the <code class="calibre18">@types</code> scope: <code
                class="calibre18">@types/jquery</code> has type definitions for the jQuery, <code
                class="calibre18">@types/lodash</code> has types for Lodash, and so on. These <code
                class="calibre18">@types</code> packages only contain the <em class="calibre3">types</em>. They don’t
              contain the implementation.</p>

            <p class="author1">Your <code class="calibre18">@types</code> dependencies should also be <code
                class="calibre18">devDependencies</code>, even if the package itself is a direct dependency. For
              example, to depend on<a data-primary="React library" data-secondary="dependencies" data-type="indexterm"
                id="calibre_link-481" class="calibre9"></a> React and its type declarations, you might run:</p>
            <pre data-type="programlisting"
              class="calibre17">$ <strong class="calibre32">npm install react</strong></pre>
            <pre data-type="programlisting"
              class="calibre17">$ <strong class="calibre32">npm install --save-dev @types/react</strong></pre>

            <p class="author1">This will result in a <em class="calibre3">package.json</em> file that looks something
              like this:</p>

            <pre data-code-language="json" data-type="programlisting" class="calibre17"><code class="p">{</code>
  <code class="nt">"devDependencies"</code><code class="p">:</code> <code class="p">{</code>
    <code class="nt">"@types/lodash"</code><code class="p">:</code> <code class="s">"^16.8.19"</code><code class="p">,</code>
    <code class="nt">"typescript"</code><code class="p">:</code> <code class="s">"^3.5.3"</code>
  <code class="p">},</code>
  <code class="nt">"dependencies"</code><code class="p">:</code> <code class="p">{</code>
    <code class="nt">"react"</code><code class="p">:</code> <code class="s">"^16.8.6"</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

            <p class="author1">The idea here is that you should publish JavaScript, not TypeScript, and your JavaScript
              does not depend on the <code class="calibre18">@types</code> when you run it. There are a few things that
              can go wrong with <code class="calibre18">@types</code> dependencies, and the next item will delve deeper
              into this topic.</p>








            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-946">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">Avoid installing TypeScript system-wide. Make TypeScript a <code
                        class="calibre18">devDependency</code> of your project to ensure that everyone on the team is
                      using a consistent version.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Put <code class="calibre18">@types</code> dependencies in <code
                        class="calibre18">devDependencies</code>, not <code class="calibre18">dependencies</code>. If
                      you need <code class="calibre18">@types</code> at runtime, then you may want to rework your
                      process.</p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>













        <section data-pdf-bookmark="Item 46: Understand the Three Versions Involved in Type Declarations"
          data-type="sect1" class="praise">
          <div class="praise" id="calibre_link-766">
            <h1 class="calibre16">Item 46: Understand the Three Versions Involved in Type Declarations</h1>

            <p class="author1">Dependency management<a data-primary="type declaration"
                data-secondary="three versions involved in" data-type="indexterm" id="calibre_link-578"
                class="calibre9"></a><a data-primary="versions, managing for type declarations" data-type="indexterm"
                id="calibre_link-743" class="calibre9"></a><a data-primary="@types (type dependencies)"
                data-secondary="three versions involved in" data-type="indexterm" id="calibre_link-72"
                class="calibre9"></a> rarely conjures up happy feelings for software developers. Usually you just want
              to use a library and not think too much about whether its transitive dependencies are compatible with
              yours.</p>

            <p class="author1">The bad news is that TypeScript doesn’t make this any better. In fact, it makes
              dependency management quite a bit <em class="calibre3">more</em> complicated. This is because instead of
              having a single version to worry about, you now have three:</p>

            <ul class="printings">
              <li class="calibre12">
                <p class="author1">The version of the package</p>
              </li>
              <li class="calibre12">
                <p class="author1">The version of its type declarations (<code class="calibre18">@types</code>)</p>
              </li>
              <li class="calibre12">
                <p class="author1">The version of TypeScript</p>
              </li>
            </ul>

            <p class="author1">If any of these versions get out of sync with one another, you can run into errors that
              may not be clearly related to dependency management. But as the saying goes, “make things as simple as
              possible but no simpler.” Understanding the full complexity of TypeScript package management will help you
              diagnose and fix problems. And it will help you make more informed decisions when it comes time to publish
              type declarations of your own.</p>

            <p class="author1">Here’s how dependencies in TypeScript are supposed to work. You install a package as a
              direct dependency, and you install its types as a dev dependency (see <a href="#calibre_link-2"
                class="calibre9">Item 45</a>):</p>
            <pre data-type="programlisting" class="calibre17">$ <strong class="calibre32">npm install react</strong>
+ react@16.8.6

$ <strong class="calibre32">npm install --save-dev @types/react</strong>
+ @types/react@16.8.19</pre>

            <p class="author1">Note that the major and minor versions (<code class="calibre18">16.8</code>) match but
              that the patch versions (<code class="calibre18">.6</code> and <code class="calibre18">.19</code>) do not.
              This is exactly what you want to see. The <code class="calibre18">16.8</code> in the <code
                class="calibre18">@types</code> version means that these type declarations describe the API of version
              <code class="calibre18">16.8</code> of <code class="calibre18">react</code>. Assuming the <code
                class="calibre18">react</code> module follows good semantic versioning hygiene, the patch versions
              (<code class="calibre18">16.8.1</code>, <code class="calibre18">16.8.2</code>, …) will not change its
              public API and will not require updates to the type declarations. But the type declarations <em
                class="calibre3">themselves</em> might have bugs or omissions. The patch versions of the <code
                class="calibre18">@types</code> module correspond to these sorts of fixes and additions. In this case,
              there were many more updates to the type declarations than the library itself (19 versus 6).
            </p>

            <p class="author1">This can go wrong in a few ways.</p>

            <p class="author1">First, you might update a library but forget to update its type declarations. In this
              case you’ll get type errors whenever you try to use new features of the library. If there were breaking
              changes to the library, you might get runtime errors despite your code passing the type checker.</p>

            <p class="author1">The solution is usually to update your type declarations so that the versions are back in
              sync. If the type declarations have not been updated, you have a few options. You can use an augmentation
              in your own project to add new functions and methods that you’d like to use. Or you can contribute updated
              type declarations back to the <span class="calibre">community</span>.</p>

            <p class="author1">Second, your type declarations might get ahead of your library. This can happen if you’ve
              been using a library without its typings (perhaps you gave it an <code class="calibre18">any</code> type
              using <code class="calibre18">declare module</code>) and try to install them later. If there have been new
              releases of the library and its type declarations, your versions might be out of sync. The symptoms of
              this are similar to the first problem, just in reverse. The type checker will be comparing your code
              against the latest API, while you’ll be using an older one at runtime. The solution is to either upgrade
              the library or downgrade the type declarations until they match.</p>

            <p class="author1">Third, the type declarations might require a newer version of TypeScript than you’re
              using in your project. Much of the development of TypeScript’s type system has been motivated by an
              attempt to more precisely type popular JavaScript libraries like<a data-primary="Ramda library"
                data-type="indexterm" id="calibre_link-480" class="calibre9"></a> Lodash, React, and Ramda. It makes
              sense that the type declarations for these libraries would want to use the latest and greatest features to
              get you better type safety.<a data-primary="" data-startref="lodash06" data-type="indexterm"
                id="calibre_link-388" class="calibre9"></a><a data-primary="" data-startref="react06"
                data-type="indexterm" id="calibre_link-482" class="calibre9"></a></p>

            <p class="author1">If this happens, you’ll experience it as type errors in the <code
                class="calibre18">@types</code> declarations themselves. The solution is to either upgrade your
              TypeScript version, use an older version of the type declarations, or, if you really can’t update
              TypeScript, stub out the types with <code class="calibre18">declare module</code>. It is possible for a
              library to provide different type declarations for different versions of TypeScript via <code
                class="calibre18">typesVersions</code>, but this is rare: at the time of this writing, fewer than 1% of
              the packages on<a data-primary="DefinitelyTyped" data-type="indexterm" id="calibre_link-211"
                class="calibre9"></a> DefinitelyTyped did so.</p>

            <p class="author1">To install <code class="calibre18">@types</code> for a specific version of TypeScript,
              you can use:</p>

            <pre data-type="programlisting" class="calibre17">npm install --save-dev @types/lodash@ts3.1</pre>

            <p class="author1">The version matching between libraries and their types is best effort and may not always
              be correct. But the more popular the library is, the more likely it is that its type declarations will get
              this right.</p>

            <p class="author1">Fourth, you can wind up with duplicate <code class="calibre18">@types</code>
              dependencies. Say you depend on <code class="calibre18">@types/foo</code> and <code
                class="calibre18">@types/bar</code>. If <code class="calibre18">@types/bar</code> depends on an
              incompatible version of <code class="calibre18">@types/foo</code>, then npm will attempt to resolve this
              by installing both versions, one in a nested folder:</p>

            <pre data-type="programlisting" class="calibre17">node_modules/
  @types/
    foo/
      index.d.ts @1.2.3
    bar/
      index.d.ts
      node_modules/
        @types/
          foo/
            index.d.ts @2.3.4</pre>

            <p class="author1">While this is sometimes OK for node modules that are used at runtime, it almost certainly
              won’t be OK for type declarations, which live in a flat global<a data-primary="namespace"
                data-secondary="type declarations and" data-type="indexterm" id="calibre_link-413" class="calibre9"></a>
              namespace. You’ll see this as errors about duplicate declarations or declarations that cannot be merged.
              You can track down why you have a duplicate type declaration by running <code
                class="calibre18">npm ls @types/foo</code>. The solution is typically to update your dependency on <code
                class="calibre18">@types/foo</code> or <code class="calibre18">@types/bar</code> so that they are
              compatible. Transitive <code class="calibre18">@types</code> dependencies like these are often a source of
              trouble. If you’re publishing types, see <a href="#calibre_link-3" class="calibre9">Item 51</a> for ways
              to avoid them.</p>

            <p class="author1">Some<a data-primary="bundling types" data-type="indexterm" id="calibre_link-139"
                class="calibre9"></a> packages, particularly those written in TypeScript, choose to bundle their own
              type declarations. This is usually indicated by a <code class="calibre18">"types"</code> field in their
              <em class="calibre3">package.json</em> which points to a <em class="calibre3">.d.ts</em> file:
            </p>

            <pre data-code-language="json" data-type="programlisting" class="calibre17"><code class="p">{</code>
  <code class="nt">"name"</code><code class="p">:</code> <code class="s">"left-pad"</code><code class="p">,</code>
  <code class="nt">"version"</code><code class="p">:</code> <code class="s">"1.3.0"</code><code class="p">,</code>
  <code class="nt">"description"</code><code class="p">:</code> <code class="s">"String left pad"</code><code class="p">,</code>
  <code class="nt">"main"</code><code class="p">:</code> <code class="s">"index.js"</code><code class="p">,</code>
  <code class="nt">"types"</code><code class="p">:</code> <code class="s">"index.d.ts"</code><code class="p">,</code>
  <code class="si">//</code> <code class="si">...</code>
<code class="p">}</code></pre>

            <p class="author1">Does this solve all our problems? Would I even be asking if the answer was “yes”?</p>

            <p class="author1">Bundling types <em class="calibre3">does</em> solve the problem of version mismatch,
              particularly if the library itself is written in TypeScript and the type declarations are generated by
              <code class="calibre18">tsc</code>. But bundling has some problems of its own.
            </p>

            <p class="author1">First, what if there’s an error in the bundled types that can’t be fixed through
              augmentation? Or the types worked fine when they were published, but a new TypeScript version has since
              been released which flags an error. With <code class="calibre18">@types</code> you could depend on the
              library’s implementation but not its type declarations. But with bundled types, you lose this option. One
              bad type declaration might keep you stuck on an old version of TypeScript. Contrast this with
              DefinitelyTyped: as TypeScript is developed, Microsoft runs it against all the type declarations on
              DefinitelyTyped. Breaks are fixed quickly.</p>

            <p class="author1">Second, what if your types depend on another library’s type declarations? Usually this
              would be a <code class="calibre18">devDependency</code> (<a href="#calibre_link-2" class="calibre9">Item
                45</a>). But if you publish your module and another user installs it, they won’t get your <code
                class="calibre18">devDependencies</code>. Type errors will result. On the other hand, you probably don’t
              want to make it a direct dependency either, since then your JavaScript users will install <code
                class="calibre18">@types</code> modules for no reason. <a href="#calibre_link-3" class="calibre9">Item
                51</a> discusses the standard workaround for this situation. But if you publish your types on
              DefinitelyTyped, this is not a problem at all: you declare your type dependency there and only your
              TypeScript users will get it.</p>

            <p class="author1">Third, what if you need to fix an issue with the type declarations of an old version of
              your library? Would you be able to go back and release a patch update? DefinitelyTyped has mechanisms for
              simultaneously maintaining type declarations for different versions of the same library, something that
              might be hard for you to do in your own project.</p>

            <p class="author1">Fourth, how committed to accepting patches for type declarations are you? Remember the
              versions of <code class="calibre18">react</code> and <code class="calibre18">@types/react</code> from the
              start of this item. There were three times more patch updates to the type declarations than the library
              itself. DefinitelyTyped is community-maintained and is able to handle this volume. In particular, if a
              library maintainer doesn’t look at a patch within five days, a global maintainer will. Can you commit to a
              similar turnaround time for your library?</p>

            <p class="author1">Managing dependencies in TypeScript can be challenging, but it does come with rewards:
              well-written type declarations can help you learn how to use libraries correctly and can greatly improve
              your productivity with them. As you run into issues with dependency management, keep the three versions in
              mind.</p>

            <p class="author1">If you are publishing packages, weigh the pros and cons of bundling type declarations
              versus publishing them on DefinitelyTyped. The official recommendation is to bundle type declarations only
              if the library is written in TypeScript. This works well in practice since <code
                class="calibre18">tsc</code> can automatically generate type declarations for you (using the <code
                class="calibre18">declaration</code> compiler option). For JavaScript libraries, handcrafted type
              declarations are more likely to contain errors, and they’ll require more updates. If you publish your type
              declarations on DefinitelyTyped, the community will help you support and maintain them.</p>








            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-947">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">There are three versions involved in an <code class="calibre18">@types</code>
                      dependency: the library version, the <code class="calibre18">@types</code> version, and the
                      TypeScript version.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">If you update a library, make sure you update the corresponding <code
                        class="calibre18">@types</code>.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Understand the pros and cons of bundling types versus publishing them on
                      DefinitelyTyped. Prefer bundling types if your library is written in TypeScript and
                      DefinitelyTyped if it is not.<a data-primary="" data-startref="TDthree06" data-type="indexterm"
                        id="calibre_link-579" class="calibre9"></a><a data-primary="" data-startref="Vmanage06"
                        data-type="indexterm" id="calibre_link-744" class="calibre9"></a><a data-primary=""
                        data-startref="attypethree06" data-type="indexterm" id="calibre_link-73" class="calibre9"></a>
                    </p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>













        <section data-pdf-bookmark="Item 47: Export All Types That Appear in Public APIs" data-type="sect1"
          class="praise">
          <div class="praise" id="calibre_link-948">
            <h1 class="calibre16">Item 47: Export All Types That Appear in Public APIs</h1>

            <p class="author1">Use<a data-primary="type declaration" data-secondary="types in public APIs"
                data-type="indexterm" id="calibre_link-583" class="calibre9"></a><a data-primary="public APIs"
                data-secondary="exporting all types appearing in" data-type="indexterm" id="calibre_link-476"
                class="calibre9"></a> TypeScript long enough and you’ll eventually find yourself wanting to use a <code
                class="calibre18">type</code> or <code class="calibre18">interface</code> from a third-party module only
              to find that it isn’t exported. Fortunately TypeScript’s tools for mapping between types are rich enough
              that, as a library user, you can almost always find a way to reference the type you want. As a library
              author, this means that you ought to just export your types to begin with. If a type ever appears in a
              function declaration, it is effectively exported. So you may as well make things explicit.</p>

            <p class="author1">Suppose you want to create some secret, unexported types:</p>

            <pre data-code-language="ts" data-type="programlisting" id="calibre_link-949" class="calibre17"><code class="kd">interface</code> <code class="nx">SecretName</code> <code class="p">{</code>
  <code class="nx">first</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">last</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">interface</code> <code class="nx">SecretSanta</code> <code class="p">{</code>
  <code class="nx">name</code>: <code class="nx">SecretName</code><code class="p">;</code>
  <code class="nx">gift</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">export</code> <code class="kd">function</code> <code class="nx">getGift</code><code class="p">(</code><code class="nx">name</code>: <code class="nx">SecretName</code><code class="p">,</code> <code class="nx">gift</code>: <code class="kd">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">SecretSanta</code> <code class="p">{</code>
  <code class="c">// ...</code>
<code class="p">}</code></pre>

            <p class="author1">As a user of your module, I cannot directly import <code
                class="calibre18">SecretName</code> or <code class="calibre18">SecretSanta</code>, only <code
                class="calibre18">getGift</code>. But this is no barrier: because those types appear in an exported
              function signature, I can extract them. One way is to use the <code class="calibre18">Parameters</code>
              and <code class="calibre18">ReturnType</code> generic types:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">type</code> <code class="nx">MySanta</code> <code class="o">=</code> <code class="nx">ReturnType</code><code class="o">&lt;</code><code class="kd">typeof</code> <code class="nx">getGift</code><code class="o">&gt;</code><code class="p">;</code>  <code class="c">// SecretSanta</code>
<code class="kd">type</code> <code class="nx">MyName</code> <code class="o">=</code> <code class="nx">Parameters</code><code class="o">&lt;</code><code class="kd">typeof</code> <code class="nx">getGift</code><code class="o">&gt;</code><code class="p">[</code><code class="mi">0</code><code class="p">];</code>  <code class="c">// SecretName</code></pre>

            <p class="author1">If your goal in not exporting these types was to preserve flexibility, then the jig is
              up! You’ve already committed to them by putting them in a public API. Do your users a favor and export
              them.</p>








            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-950">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">Export types that appear in any form in any public method. Your users will be
                      able to extract them anyway, so you may as well make it easy for them.</p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>













        <section data-pdf-bookmark="Item 48: Use TSDoc for API Comments" data-type="sect1" class="praise">
          <div class="praise" id="calibre_link-49">
            <h1 class="calibre16">Item 48: Use TSDoc for API Comments</h1>

            <p class="author1">Here’s<a data-primary="type declaration" data-secondary="TSDoc for API comments"
                data-type="indexterm" id="calibre_link-580" class="calibre9"></a><a data-primary="public APIs"
                data-secondary="TSDoc for API comments" data-type="indexterm" id="calibre_link-477"
                class="calibre9"></a><a data-primary="TSDoc" data-type="indexterm" id="calibre_link-550"
                class="calibre9"></a><a data-primary="JSDoc-style comments" data-type="indexterm" id="calibre_link-365"
                class="calibre9"></a> a TypeScript function to generate a greeting:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="c">// Generate a greeting. Result is formatted for display.</code>
<code class="kd">function</code> <code class="nx">greet</code><code class="p">(</code><code class="nx">name</code>: <code class="kd">string</code><code class="p">,</code> <code class="nx">title</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="s">`Hello </code><code class="si">${</code><code class="nx">title</code><code class="si">}</code><code class="s"> </code><code class="si">${</code><code class="nx">name</code><code class="si">}</code><code class="s">`</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">The author was kind enough to leave a comment describing what this function does. But for
              documentation intended to be read by users of your functions, it’s better to use JSDoc-style comments:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="c">/** Generate a greeting. Result is formatted for display. */</code>
<code class="kd">function</code> <code class="nx">greetJSDoc</code><code class="p">(</code><code class="nx">name</code>: <code class="kd">string</code><code class="p">,</code> <code class="nx">title</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="s">`Hello </code><code class="si">${</code><code class="nx">title</code><code class="si">}</code><code class="s"> </code><code class="si">${</code><code class="nx">name</code><code class="si">}</code><code class="s">`</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">The reason is that there is a nearly universal convention in editors to surface
              JSDoc-style comments when the function is called (see <a data-type="xref" href="#calibre_link-4"
                class="calibre9">Figure&nbsp;6-1</a>).</p>

            <figure class="width1">
              <div class="figure" id="calibre_link-4">
                <img alt="efts 06in01" src="images/000027.png" class="calibre29" />
                <h6 class="calibre30"><span class="calibre">Figure 6-1. </span>JSDoc-style comments are typically
                  surfaced in tooltips in your editor.</h6>
              </div>
            </figure>

            <p class="author1">Whereas the inline comment gets no such treatment (see <a data-type="xref"
                href="#calibre_link-5" class="calibre9">Figure&nbsp;6-2</a>).</p>

            <figure class="width1">
              <div class="figure" id="calibre_link-5">
                <img alt="efts 06in02" src="images/000035.png" class="calibre29" />
                <h6 class="calibre30"><span class="calibre">Figure 6-2. </span>Inline comments are typically not shown
                  in tooltips.</h6>
              </div>
            </figure>

            <p class="author1">The<a data-primary="language services"
                data-secondary="commenting convention supported by" data-type="indexterm" id="calibre_link-375"
                class="calibre9"></a><a data-primary="@param type" data-type="indexterm" id="calibre_link-64"
                class="calibre9"></a><a data-primary="@returns type" data-type="indexterm" id="calibre_link-65"
                class="calibre9"></a> TypeScript language service supports this convention, and you should take
              advantage of it. If a comment describes a public API, it should be JSDoc. In the context of TypeScript,
              these comments are sometimes called TSDoc. You can use many of the usual conventions like <code
                class="calibre18">@param</code> and <code class="calibre18">@returns</code>:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="c">/**</code>
<code class="c"> * Generate a greeting.</code>
<code class="c"> * @param name Name of the person to greet</code>
<code class="c"> * @param salutation The person's title</code>
<code class="c"> * @returns A greeting formatted for human consumption.</code>
<code class="c"> */</code>
<code class="kd">function</code> <code class="nx">greetFullTSDoc</code><code class="p">(</code><code class="nx">name</code>: <code class="kd">string</code><code class="p">,</code> <code class="nx">title</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="s">`Hello </code><code class="si">${</code><code class="nx">title</code><code class="si">}</code><code class="s"> </code><code class="si">${</code><code class="nx">name</code><code class="si">}</code><code class="s">`</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">This lets editors show the relevant documentation for each parameter as you’re writing
              out a function call (as shown in <a data-type="xref" href="#calibre_link-6"
                class="calibre9">Figure&nbsp;6-3</a>).</p>

            <figure class="width">
              <div class="figure" id="calibre_link-6">
                <img alt="efts 06in03" src="images/000001.png" class="calibre53" />
                <h6 class="calibre30"><span class="calibre">Figure 6-3. </span>An @param annotation lets your editor
                  show documentation for the current parameter as you type it.</h6>
              </div>
            </figure>

            <p class="author1">You can also use TSDoc with type definitions:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="c">/** A measurement performed at a time and place. */</code>
<code class="kd">interface</code> <code class="nx">Measurement</code> <code class="p">{</code>
  <code class="c">/** Where was the measurement made? */</code>
  <code class="nx">position</code>: <code class="nx">Vector3D</code><code class="p">;</code>
  <code class="c">/** When was the measurement made? In seconds since epoch. */</code>
  <code class="nx">time</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="c">/** Observed momentum */</code>
  <code class="nx">momentum</code>: <code class="nx">Vector3D</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">As you inspect individual fields in a <code class="calibre18">Measurement</code> object,
              you’ll get contextual documentation (see <a data-type="xref" href="#calibre_link-7"
                class="calibre9">Figure&nbsp;6-4</a>).</p>

            <figure class="width1">
              <div class="figure" id="calibre_link-7">
                <img alt="efts 06in04" src="images/000018.png" class="calibre29" />
                <h6 class="calibre30"><span class="calibre">Figure 6-4. </span>TSDoc for a field is shown when you mouse
                  over that field in your editor.</h6>
              </div>
            </figure>

            <p class="author1">TSDoc comments are formatted using Markdown, so if you want to use bold, italic, or
              bulleted lists, you can (see <a data-type="xref" href="#calibre_link-8"
                class="calibre9">Figure&nbsp;6-5</a>):</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="c">/**</code>
<code class="c"> * This _interface_ has **three** properties:</code>
<code class="c"> * 1. x</code>
<code class="c"> * 2. y</code>
<code class="c"> * 3. z</code>
<code class="c"> */</code>
<code class="kd">interface</code> <code class="nx">Vector3D</code> <code class="p">{</code>
  <code class="nx">x</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">y</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">z</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code></pre>

            <figure class="width1">
              <div class="figure" id="calibre_link-8">
                <img alt="efts 06in05" src="images/000006.png" class="calibre29" />
                <h6 class="calibre30"><span class="calibre">Figure 6-5. </span>TSDoc comments</h6>
              </div>
            </figure>

            <p class="author1">Try to avoid writing essays in your documentation, though: the best comments are short
              and to the point.</p>

            <p class="author1">JSDoc includes some conventions for specifying type information (<code
                class="calibre18">@param {string} name ...</code>), but you should avoid these in favor of TypeScript
              types (<a href="#calibre_link-9" class="calibre9">Item 30</a>).</p>








            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-951">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">Use JSDoc-/TSDoc-formatted comments to document exported functions, classes, and
                      types. This helps editors surface information for your users when it’s most relevant.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Use <code class="calibre18">@param</code>, <code
                        class="calibre18">@returns</code>, and Markdown for formatting.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Avoid including type information in documentation (see <a href="#calibre_link-9"
                        class="calibre9">Item 30</a>).</p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>













        <section data-pdf-bookmark="Item 49: Provide a Type for this in Callbacks" data-type="sect1" class="praise">
          <div class="praise" id="calibre_link-12">
            <h1 class="calibre16">Item 49: Provide a Type for this in Callbacks</h1>

            <p class="author1">JavaScript’s<a data-primary="JavaScript" data-secondary="this keyword"
                data-type="indexterm" id="calibre_link-357" class="calibre9"></a><a data-primary="type declaration"
                data-secondary="providing types for this keyword in callbacks" data-type="indexterm"
                id="calibre_link-576" class="calibre9"></a><a data-primary="callbacks"
                data-secondary="providing types for this keyword in" data-type="indexterm" id="calibre_link-148"
                class="calibre9"></a><a data-primary="this keyword" data-type="indexterm" id="calibre_link-537"
                class="calibre9"></a> <code class="calibre18">this</code> keyword is one of the most notoriously
              confusing parts of the language. Unlike variables declared with <code class="calibre18">let</code> or
              <code class="calibre18">const</code>, which are lexically scoped, <code class="calibre18">this</code> is
              dynamically scoped: its value depends not on the way in which it was <em class="calibre3">defined</em> but
              on the way in which it was <em class="calibre3">called</em>.
            </p>

            <p class="author1"><code class="calibre18">this</code> is most often used in classes, where it typically
              references the current instance of an object:</p>

            <pre data-code-language="ts" data-type="programlisting" id="calibre_link-952" class="calibre17"><code class="kd">class</code> <code class="nx">C</code> <code class="p">{</code>
  <code class="nx">vals</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">];</code>
  <code class="nx">logSquares() {</code>
    <code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="nx">val</code> <code class="nx">of</code> <code class="kd">this</code><code class="p">.</code><code class="nx">vals</code><code class="p">)</code> <code class="p">{</code>
      <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">val</code> <code class="o">*</code> <code class="nx">val</code><code class="p">);</code>
    <code class="p">}</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kd">const</code> <code class="nx">c</code> <code class="o">=</code> <code class="kd">new</code> <code class="nx">C</code><code class="p">();</code>
<code class="nx">c</code><code class="p">.</code><code class="nx">logSquares</code><code class="p">();</code></pre>

            <p class="author1">This logs:</p>

            <pre data-type="programlisting" id="calibre_link-953" class="calibre17">1
4
9</pre>

            <p class="author1">Now look what happens if you try to put <code class="calibre18">logSquares</code> in a
              variable and call that:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">c</code> <code class="o">=</code> <code class="kd">new</code> <code class="nx">C</code><code class="p">();</code>
<code class="kd">const</code> <code class="nx">method</code> <code class="o">=</code> <code class="nx">c</code><code class="p">.</code><code class="nx">logSquares</code><code class="p">;</code>
<code class="nx">method</code><code class="p">();</code></pre>

            <p class="author1">This version throws an error at runtime:</p>

            <pre data-type="programlisting"
              class="calibre17">Uncaught TypeError: Cannot read property 'vals' of undefined</pre>

            <p class="author1">The problem is that <code class="calibre18">c.logSquares()</code> actually does two
              things: it calls <code class="calibre18">C.prototype.logSquares</code> <em class="calibre3">and</em> it
              binds the value of <code class="calibre18">this</code> in that function to <code
                class="calibre18">c</code>. By pulling out a reference to <code class="calibre18">logSquares</code>,
              you’ve separated these, and <code class="calibre18">this</code> gets set to <code
                class="calibre18">undefined</code>.</p>

            <p class="author1">JavaScript gives you complete control over <code class="calibre18">this</code> binding.
              You can use <code class="calibre18">call</code> to explicitly set <code class="calibre18">this</code> and
              fix the problem:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">const</code> <code class="nx">c</code> <code class="o">=</code> <code class="kd">new</code> <code class="nx">C</code><code class="p">();</code>
<code class="kd">const</code> <code class="nx">method</code> <code class="o">=</code> <code class="nx">c</code><code class="p">.</code><code class="nx">logSquares</code><code class="p">;</code>
<code class="nx">method</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="nx">c</code><code class="p">);</code>  <code class="c">// Logs the squares again</code></pre>

            <p class="author1">There’s no reason that <code class="calibre18">this</code> had to be bound to an instance
              of <code class="calibre18">C</code>. It could have been bound to anything. So libraries can, and do, make
              the value of <code class="calibre18">this</code> part of their APIs. Even the DOM makes use of this. In an
              event handler, for instance:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="nb">document</code><code class="p">.</code><code class="nx">querySelector</code><code class="p">(</code><code class="s">'input'</code><code class="p">)</code><code class="o">!</code><code class="p">.</code><code class="nx">addEventListener</code><code class="p">(</code><code class="s">'change'</code><code class="p">,</code> <code class="kd">function</code><code class="p">(</code><code class="nx">e</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="kd">this</code><code class="p">);</code>  <code class="c">// Logs the input element on which the event fired.</code>
<code class="p">});</code></pre>

            <p class="author1"><code class="calibre18">this</code> binding often comes up in the context of callbacks
              like this one. If you want to define an <code class="calibre18">onClick</code> handler in a class, for
              example, you might try this:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">class</code> <code class="nx">ResetButton</code> <code class="p">{</code>
  <code class="nx">render() {</code>
    <code class="kd">return</code> <code class="nx">makeButton</code><code class="p">({</code><code class="nx">text</code><code class="o">:</code> <code class="s">'Reset'</code><code class="p">,</code> <code class="nx">onClick</code>: <code class="nx">this.onClick</code><code class="p">});</code>
  <code class="p">}</code>
  <code class="nx">onClick() {</code>
    <code class="nx">alert</code><code class="p">(</code><code class="s">`Reset </code><code class="si">${</code><code class="kd">this</code><code class="si">}</code><code class="s">`</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

            <p class="author1">When <code class="calibre18">Button</code> calls <code class="calibre18">onClick</code>,
              it will alert “Reset undefined.” Oops! As usual, the culprit is <code class="calibre18">this</code>
              binding. A common solution is to create a bound version of the method in the constructor:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">class</code> <code class="nx">ResetButton</code> <code class="p">{</code>
  <code class="kd">constructor</code><code class="p">()</code> <code class="p">{</code>
    <code class="kd">this</code><code class="p">.</code><code class="nx">onClick</code> <code class="o">=</code> <code class="kd">this</code><code class="p">.</code><code class="nx">onClick</code><code class="p">.</code><code class="nx">bind</code><code class="p">(</code><code class="kd">this</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="nx">render() {</code>
    <code class="kd">return</code> <code class="nx">makeButton</code><code class="p">({</code><code class="nx">text</code><code class="o">:</code> <code class="s">'Reset'</code><code class="p">,</code> <code class="nx">onClick</code>: <code class="nx">this.onClick</code><code class="p">});</code>
  <code class="p">}</code>
  <code class="nx">onClick() {</code>
    <code class="nx">alert</code><code class="p">(</code><code class="s">`Reset </code><code class="si">${</code><code class="kd">this</code><code class="si">}</code><code class="s">`</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

            <p class="author1">The <code class="calibre18">onClick() { ... }</code> definition defines a property on
              <code class="calibre18">ResetButton.prototype</code>. This is shared by all instances of <code
                class="calibre18">ResetButton</code>. When you bind <code class="calibre18">this.onClick = ...</code> in
              the constructor, it creates a property called <code class="calibre18">onClick</code> on the instance of
              <code class="calibre18">ResetButton</code> with <code class="calibre18">this</code> bound to that
              instance. The <code class="calibre18">onClick</code> instance property comes before the <code
                class="calibre18">onClick</code> prototype property in the lookup sequence, so <code
                class="calibre18">this.onClick</code> refers to the bound function in the <code
                class="calibre18">render()</code> method.
            </p>

            <p class="author1">There is a shorthand for binding that can sometimes be convenient:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">class</code> <code class="nx">ResetButton</code> <code class="p">{</code>
  <code class="nx">render() {</code>
    <code class="kd">return</code> <code class="nx">makeButton</code><code class="p">({</code><code class="nx">text</code><code class="o">:</code> <code class="s">'Reset'</code><code class="p">,</code> <code class="nx">onClick</code>: <code class="nx">this.onClick</code><code class="p">});</code>
  <code class="p">}</code>
  <code class="nx">onClick</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="nx">alert</code><code class="p">(</code><code class="s">`Reset </code><code class="si">${</code><code class="kd">this</code><code class="si">}</code><code class="s">`</code><code class="p">);</code>  <code class="c">// "this" always refers to the ResetButton instance.</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

            <p class="author1">Here we’ve replaced <code class="calibre18">onClick</code> with an arrow function. This
              will define a new function every time a <code class="calibre18">ResetButton</code> is constructed with
              <code class="calibre18">this</code> set to the appropriate value. It’s instructive to look at the
              JavaScript that this generates:
            </p>

            <pre data-code-language="js" data-type="programlisting" class="calibre17"><code class="kd">class</code> <code class="nx">ResetButton</code> <code class="p">{</code>
  <code class="nx">constructor</code><code class="p">()</code> <code class="p">{</code>
    <code class="kd">var</code> <code class="nx">_this</code> <code class="o">=</code> <code class="kd">this</code><code class="p">;</code>
    <code class="kd">this</code><code class="p">.</code><code class="nx">onClick</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
      <code class="nx">alert</code><code class="p">(</code><code class="s">"Reset "</code> <code class="o">+</code> <code class="nx">_this</code><code class="p">);</code>
    <code class="p">};</code>
  <code class="p">}</code>
  <code class="nx">render</code><code class="p">()</code> <code class="p">{</code>
    <code class="kd">return</code> <code class="nx">makeButton</code><code class="p">({</code> <code class="nx">text</code><code class="o">:</code> <code class="s">'Reset'</code><code class="p">,</code> <code class="nx">onClick</code><code class="o">:</code> <code class="kd">this</code><code class="p">.</code><code class="nx">onClick</code> <code class="p">});</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

            <p class="author1">So what does this all have to do with TypeScript? Because <code
                class="calibre18">this</code> binding is part of JavaScript, TypeScript models it. This means that if
              you’re writing (or typing) a library that sets the value of <code class="calibre18">this</code> on
              callbacks, then you should model this, too.</p>

            <p class="author1">You do this by adding a <code class="calibre18">this</code> parameter to your callback:
            </p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">addKeyListener</code><code class="p">(</code>
  <code class="nx">el</code>: <code class="nx">HTMLElement</code><code class="p">,</code>
  <code class="nx">fn</code><code class="o">:</code> <code class="p">(</code><code class="kd">this</code><code class="o">:</code> <code class="nx">HTMLElement</code><code class="p">,</code> <code class="nx">e</code>: <code class="nx">KeyboardEvent</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kd">void</code>
<code class="p">)</code> <code class="p">{</code>
  <code class="nx">el</code><code class="p">.</code><code class="nx">addEventListener</code><code class="p">(</code><code class="s">'keydown'</code><code class="p">,</code> <code class="nx">e</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="nx">fn</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="nx">el</code><code class="p">,</code> <code class="nx">e</code><code class="p">);</code>
  <code class="p">});</code>
<code class="p">}</code></pre>

            <p class="author1">The <code class="calibre18">this</code> parameter is special: it’s not just another
              positional argument. You can see this if you try to call it with two parameters:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">addKeyListener</code><code class="p">(</code>
  <code class="nx">el</code>: <code class="nx">HTMLElement</code><code class="p">,</code>
  <code class="nx">fn</code><code class="o">:</code> <code class="p">(</code><code class="kd">this</code><code class="o">:</code> <code class="nx">HTMLElement</code><code class="p">,</code> <code class="nx">e</code>: <code class="nx">KeyboardEvent</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kd">void</code>
<code class="p">)</code> <code class="p">{</code>
  <code class="nx">el</code><code class="p">.</code><code class="nx">addEventListener</code><code class="p">(</code><code class="s">'keydown'</code><code class="p">,</code> <code class="nx">e</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="nx">fn</code><code class="p">(</code><code class="nx">el</code><code class="p">,</code> <code class="nx">e</code><code class="p">);</code>
        <code class="c">// ~ Expected 1 arguments, but got 2</code>
  <code class="p">});</code>
<code class="p">}</code></pre>

            <p class="author1">Even better, TypeScript will enforce that you call the function with the correct <code
                class="calibre18">this</code> context:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">addKeyListener</code><code class="p">(</code>
  <code class="nx">el</code>: <code class="nx">HTMLElement</code><code class="p">,</code>
  <code class="nx">fn</code><code class="o">:</code> <code class="p">(</code><code class="kd">this</code><code class="o">:</code> <code class="nx">HTMLElement</code><code class="p">,</code> <code class="nx">e</code>: <code class="nx">KeyboardEvent</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kd">void</code>
<code class="p">)</code> <code class="p">{</code>
  <code class="nx">el</code><code class="p">.</code><code class="nx">addEventListener</code><code class="p">(</code><code class="s">'keydown'</code><code class="p">,</code> <code class="nx">e</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="nx">fn</code><code class="p">(</code><code class="nx">e</code><code class="p">);</code>
 <code class="c">// ~~~~~ The 'this' context of type 'void' is not assignable</code>
 <code class="c">//       to method's 'this' of type 'HTMLElement'</code>
  <code class="p">});</code>
<code class="p">}</code></pre>

            <p class="author1">As a user of this function, you can reference <code class="calibre18">this</code> in the
              callback and get full type safety:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">declare</code> <code class="kd">let</code> <code class="nx">el</code>: <code class="nx">HTMLElement</code><code class="p">;</code>
<code class="nx">addKeyListener</code><code class="p">(</code><code class="nx">el</code><code class="p">,</code> <code class="kd">function</code><code class="p">(</code><code class="nx">e</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">this</code><code class="p">.</code><code class="nx">innerHTML</code><code class="p">;</code>  <code class="c">// OK, "this" has type of HTMLElement</code>
<code class="p">});</code></pre>

            <p class="author1">Of course, if you use an arrow function here, you’ll override the value of <code
                class="calibre18">this</code>. TypeScript will catch the issue:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">class</code> <code class="nx">Foo</code> <code class="p">{</code>
  <code class="nx">registerHandler</code><code class="p">(</code><code class="nx">el</code>: <code class="nx">HTMLElement</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">addKeyListener</code><code class="p">(</code><code class="nx">el</code><code class="p">,</code> <code class="nx">e</code> <code class="o">=&gt;</code> <code class="p">{</code>
      <code class="kd">this</code><code class="p">.</code><code class="nx">innerHTML</code><code class="p">;</code>
        <code class="c">// ~~~~~~~~~ Property 'innerHTML' does not exist on type 'Foo'</code>
    <code class="p">});</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

            <p class="author1">Don’t forget about <code class="calibre18">this</code>! If you set the value of <code
                class="calibre18">this</code> in your callbacks, then it’s part of your API, and you should include it
              in your type declarations.</p>








            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-954">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">Understand how <code class="calibre18">this</code> binding works.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Provide a type for <code class="calibre18">this</code> in callbacks when it’s
                      part of your API.</p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>













        <section data-pdf-bookmark="Item 50: Prefer Conditional Types to Overloaded Declarations" data-type="sect1"
          class="praise">
          <div class="praise" id="calibre_link-767">
            <h1 class="calibre16">Item 50: Prefer Conditional Types to Overloaded Declarations</h1>

            <p class="author1">How<a data-primary="type declaration"
                data-secondary="conditional types versus overloaded declarations" data-type="indexterm"
                id="calibre_link-572" class="calibre9"></a><a data-primary="overloaded declarations"
                data-type="indexterm" id="calibre_link-452" class="calibre9"></a><a data-primary="conditional types"
                data-type="indexterm" id="calibre_link-182" class="calibre9"></a> would you write a type declaration for
              this JavaScript function?</p>

            <pre data-code-language="js" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="kd">double</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">x</code> <code class="o">+</code> <code class="nx">x</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1"><code class="calibre18">double</code> can be passed either a <code
                class="calibre18">string</code> or a <code class="calibre18">number</code>. So you might use a union
              type:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">function</code> <code class="kd">double</code><code class="p">(</code><code class="nx">x</code>: <code class="nx">number</code><code class="o">|</code><code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="kt">number</code><code class="o">|</code><code class="kt">string</code><code class="p">;</code>
<code class="kd">function</code> <code class="kd">double</code><code class="p">(</code><code class="nx">x</code>: <code class="nx">any</code><code class="p">)</code> <code class="p">{</code> <code class="kd">return</code> <code class="nx">x</code> <code class="o">+</code> <code class="nx">x</code><code class="p">;</code> <code class="p">}</code></pre>

            <p class="author1">(These examples all make use of TypeScript’s concept of function overloading. For a
              refresher, see <a href="#calibre_link-1" class="calibre9">Item 3</a>.)</p>

            <p class="author1">While this declaration is accurate, it’s a bit imprecise:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">const</code> <code class="nx">num</code> <code class="o">=</code> <code class="kd">double</code><code class="p">(</code><code class="mi">12</code><code class="p">);</code>  <code class="c">// string | number</code>
<code class="kd">const</code> <code class="nx">str</code> <code class="o">=</code> <code class="kd">double</code><code class="p">(</code><code class="s">'x'</code><code class="p">);</code>  <code class="c">// string | number</code></pre>

            <p class="author1">When <code class="calibre18">double</code> is passed a <code
                class="calibre18">number</code>, it returns a <code class="calibre18">number</code>. And when it’s
              passed a <code class="calibre18">string</code>, it returns a <code class="calibre18">string</code>. This
              declaration misses that nuance and will produce types that are hard to work with.</p>

            <p class="author1">You might try to capture this relationship using a generic:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">function</code> <code class="kd">double</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kd">extends</code> <code class="kt">number</code><code class="o">|</code><code class="kt">string</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">x</code>: <code class="nx">T</code><code class="p">)</code><code class="o">:</code> <code class="nx">T</code><code class="p">;</code>
<code class="kd">function</code> <code class="kd">double</code><code class="p">(</code><code class="nx">x</code>: <code class="nx">any</code><code class="p">)</code> <code class="p">{</code> <code class="kd">return</code> <code class="nx">x</code> <code class="o">+</code> <code class="nx">x</code><code class="p">;</code> <code class="p">}</code>

<code class="kd">const</code> <code class="nx">num</code> <code class="o">=</code> <code class="kd">double</code><code class="p">(</code><code class="mi">12</code><code class="p">);</code>  <code class="c">// Type is 12</code>
<code class="kd">const</code> <code class="nx">str</code> <code class="o">=</code> <code class="kd">double</code><code class="p">(</code><code class="s">'x'</code><code class="p">);</code>  <code class="c">// Type is "x"</code></pre>

            <p class="author1">Unfortunately, in our zeal for precision we’ve overshot. The types are now a little <em
                class="calibre3">too</em> precise. When passed a <code class="calibre18">string</code> type, this <code
                class="calibre18">double</code> declaration will result in a <code class="calibre18">string</code> type,
              which is correct. But when passed a string <em class="calibre3">literal</em> type, the return type is the
              same string literal type. This is wrong: doubling <code class="calibre18">'x'</code> results in <code
                class="calibre18">'xx'</code>, not <code class="calibre18">'x'</code>.</p>

            <p class="author1">Another option is to provide multiple type declarations. While TypeScript only allows you
              to write one implementation of a function, it allows you to write any number of type declarations. You can
              use this to improve the type of <code class="calibre18">double</code>:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">function</code> <code class="kd">double</code><code class="p">(</code><code class="nx">x</code>: <code class="nx">number</code><code class="p">)</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>
<code class="kd">function</code> <code class="kd">double</code><code class="p">(</code><code class="nx">x</code>: <code class="kd">string</code><code class="p">)</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>
<code class="kd">function</code> <code class="kd">double</code><code class="p">(</code><code class="nx">x</code>: <code class="nx">any</code><code class="p">)</code> <code class="p">{</code> <code class="kd">return</code> <code class="nx">x</code> <code class="o">+</code> <code class="nx">x</code><code class="p">;</code> <code class="p">}</code>

<code class="kd">const</code> <code class="nx">num</code> <code class="o">=</code> <code class="kd">double</code><code class="p">(</code><code class="mi">12</code><code class="p">);</code>  <code class="c">// Type is number</code>
<code class="kd">const</code> <code class="nx">str</code> <code class="o">=</code> <code class="kd">double</code><code class="p">(</code><code class="s">'x'</code><code class="p">);</code>  <code class="c">// Type is string</code></pre>

            <p class="author1">This is progress! But is this declaration correct? Unfortunately there’s still a subtle
              bug. This type declaration will work with values that are either a <code class="calibre18">string</code>
              or a <code class="calibre18">number</code>, but not with values that could be either:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">f</code><code class="p">(</code><code class="nx">x</code>: <code class="nx">number</code><code class="o">|</code><code class="kt">string</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="kd">double</code><code class="p">(</code><code class="nx">x</code><code class="p">);</code>
             <code class="c">// ~ Argument of type 'string | number' is not assignable</code>
             <code class="c">//   to parameter of type 'string'</code>
<code class="p">}</code></pre>

            <p class="author1">This call to <code class="calibre18">double</code> is safe and should return <code
                class="calibre18">string|number</code>. When you overload type declarations, TypeScript processes them
              one by one until it finds a match. The error you’re seeing is a result of the last overload (the <code
                class="calibre18">string</code> version) failing, because <code class="calibre18">string|number</code>
              is not assignable to <code class="calibre18">string</code>.</p>

            <p class="author1">While you could patch this issue by adding a third <code
                class="calibre18">string|number</code> overload, the best solution is to use a <em
                class="calibre3">conditional type</em>. Conditional types are like if statements (conditionals) in type
              space. They’re perfect for situations like this one where there are a few possibilities that you need to
              cover:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">function</code> <code class="kd">double</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kd">extends</code> <code class="kt">number</code> <code class="o">|</code> <code class="kt">string</code><code class="o">&gt;</code><code class="p">(</code>
  <code class="nx">x</code>: <code class="nx">T</code>
<code class="p">)</code><code class="o">:</code> <code class="nx">T</code> <code class="kd">extends</code> <code class="kt">string</code> <code class="o">?</code> <code class="kt">string</code> <code class="o">:</code> <code class="kt">number</code><code class="p">;</code>
<code class="kd">function</code> <code class="kd">double</code><code class="p">(</code><code class="nx">x</code>: <code class="nx">any</code><code class="p">)</code> <code class="p">{</code> <code class="kd">return</code> <code class="nx">x</code> <code class="o">+</code> <code class="nx">x</code><code class="p">;</code> <code class="p">}</code></pre>

            <p class="author1">This is similar to the first attempt to type <code class="calibre18">double</code> using
              a generic, but with a more elaborate return type. You read the conditional type like you’d read a ternary
              (<code class="calibre18">?:</code>) operator in JavaScript:</p>

            <ul class="printings">
              <li class="calibre12">
                <p class="author1">If <code class="calibre18">T</code> is a subset of <code
                    class="calibre18">string</code> (e.g., <code class="calibre18">string</code> or a string literal or
                  a union of string literals), then the return type is <code class="calibre18">string</code>.</p>
              </li>
              <li class="calibre12">
                <p class="author1">Otherwise return <code class="calibre18">number</code>.</p>
              </li>
            </ul>

            <p class="author1">With this declaration, all of our examples work:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">num</code> <code class="o">=</code> <code class="kd">double</code><code class="p">(</code><code class="mi">12</code><code class="p">);</code>  <code class="c">// number</code>
<code class="kd">const</code> <code class="nx">str</code> <code class="o">=</code> <code class="kd">double</code><code class="p">(</code><code class="s">'x'</code><code class="p">);</code>  <code class="c">// string</code>

<code class="c">// function f(x: string | number): string | number</code>
<code class="kd">function</code> <code class="nx">f</code><code class="p">(</code><code class="nx">x</code>: <code class="nx">number</code><code class="o">|</code><code class="kt">string</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="kd">double</code><code class="p">(</code><code class="nx">x</code><code class="p">);</code>
<code class="p">}</code></pre>

            <p class="author1">The <code class="calibre18">number|string</code> example works because conditional types
              distribute over unions. When <code class="calibre18">T</code> is <code
                class="calibre18">number|string</code>, TypeScript resolves the conditional type as follows:</p>

            <pre data-type="programlisting" class="calibre17">   (number|string) extends string ? string : number
-&gt; (number extends string ? string : number) |
   (string extends string ? string : number)
-&gt; number | string</pre>

            <p class="author1">While the type declaration using overloading was simpler to write, the version using
              conditional types is more correct because it generalizes to the union of the individual cases. This is
              often the case for overloads. Whereas overloads are treated independently, the type checker can analyze
              conditional types as a single expression, distributing them over unions. If you find yourself writing an
              overloaded type declarations, consider whether it might be better expressed using a conditional type.</p>








            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-955">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">Prefer conditional types to overloaded type declarations. By distributing over
                      unions, conditional types allow your declarations to support union types without additional
                      overloads.</p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>













        <section data-pdf-bookmark="Item 51: Mirror Types to Sever Dependencies" data-type="sect1" class="praise">
          <div class="praise" id="calibre_link-3">
            <h1 class="calibre16">Item 51: Mirror Types to Sever Dependencies</h1>

            <p class="author1">Suppose<a data-primary="type declaration"
                data-secondary="mirroring types to sever dependencies" data-type="indexterm" id="calibre_link-573"
                class="calibre9"></a><a data-primary="@types (type dependencies)"
                data-secondary="JavaScript developers and" data-type="indexterm" id="calibre_link-70"
                class="calibre9"></a><a data-primary="NodeJS" data-type="indexterm" id="calibre_link-418"
                class="calibre9"></a> you’ve written a library for parsing<a data-primary="CSV" data-type="indexterm"
                id="calibre_link-199" class="calibre9"></a> CSV files. Its API is simple: you pass in the contents of
              the CSV file and get back a list of objects mapping column names to values. As a convenience for your
              NodeJS users, you allow the contents to be either a <code class="calibre18">string</code> or a NodeJS
              <code class="calibre18">Buffer</code>:
            </p>

            <pre data-code-language="ts" data-type="programlisting" id="calibre_link-956" class="calibre17"><code class="kd">function</code> <code class="nx">parseCSV</code><code class="p">(</code><code class="nx">contents</code>: <code class="kd">string</code> <code class="o">|</code> <code class="nx">Buffer</code><code class="p">)</code><code class="o">:</code> <code class="p">{[</code><code class="nx">column</code>: <code class="kd">string</code><code class="p">]</code><code class="o">:</code> <code class="kt">string</code><code class="p">}[]</code>  <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="kd">typeof</code> <code class="nx">contents</code> <code class="o">===</code> <code class="s">'object'</code><code class="p">)</code> <code class="p">{</code>
    <code class="c">// It's a buffer</code>
    <code class="kd">return</code> <code class="nx">parseCSV</code><code class="p">(</code><code class="nx">contents</code><code class="p">.</code><code class="nx">toString</code><code class="p">(</code><code class="s">'utf8'</code><code class="p">));</code>
  <code class="p">}</code>
  <code class="c">// ...</code>
<code class="p">}</code></pre>

            <p class="author1">The type definition for <code class="calibre18">Buffer</code> comes from the NodeJS type
              declarations, which you must install:</p>

            <pre data-type="programlisting" class="calibre17">npm install --save-dev @types/node</pre>

            <p class="author1">When you publish your CSV parsing library, you include the type declarations with it.
              Since your type declarations depend on the NodeJS types, you include these as a <code
                class="calibre18">devDependency</code> (<a href="#calibre_link-2" class="calibre9">Item 45</a>). If you
              do this, you’re liable to get complaints from two groups of users:</p>

            <ul class="printings">
              <li class="calibre12">
                <p class="author1">JavaScript developers who wonder what these <code class="calibre18">@types</code>
                  modules are that they’re depending on.</p>
              </li>
              <li class="calibre12">
                <p class="author1">TypeScript web developers who wonder why they’re depending on NodeJS.</p>
              </li>
            </ul>

            <p class="author1">These complaints are reasonable. The <code class="calibre18">Buffer</code> behavior isn’t
              essential and is only relevant for users who are using NodeJS already. And the declaration in <code
                class="calibre18">@types/node</code> is only relevant to NodeJS users who are also using TypeScript.</p>

            <p class="author1">TypeScript’s<a data-primary="TypeScript" data-secondary="structural typing"
                data-type="indexterm" id="calibre_link-691" class="calibre9"></a><a data-primary="structural typing"
                data-type="indexterm" id="calibre_link-520" class="calibre9"></a> structural typing (<a
                href="#calibre_link-10" class="calibre9">Item 4</a>) can help you out of the jam. Rather than using the
              declaration of <code class="calibre18">Buffer</code> from <code class="calibre18">@types/node</code>, you
              can write your own with just the methods and properties you need. In this case that’s just a <code
                class="calibre18">toString</code> method that accepts an encoding:</p>

            <pre data-code-language="ts" data-type="programlisting" id="calibre_link-957" class="calibre17"><code class="kd">interface</code> <code class="nx">CsvBuffer</code> <code class="p">{</code>
  <code class="nx">toString</code><code class="p">(</code><code class="nx">encoding</code>: <code class="kd">string</code><code class="p">)</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">function</code> <code class="nx">parseCSV</code><code class="p">(</code><code class="nx">contents</code>: <code class="kd">string</code> <code class="o">|</code> <code class="nx">CsvBuffer</code><code class="p">)</code><code class="o">:</code> <code class="p">{[</code><code class="nx">column</code>: <code class="kd">string</code><code class="p">]</code><code class="o">:</code> <code class="kt">string</code><code class="p">}[]</code>  <code class="p">{</code>
  <code class="c">// ...</code>
<code class="p">}</code></pre>

            <p class="author1">This interface is dramatically shorter than the complete one, but it does capture our
              (simple) needs from a <code class="calibre18">Buffer</code>. In a NodeJS project, calling <code
                class="calibre18">parseCSV</code> with a real <code class="calibre18">Buffer</code> is still OK because
              the types are compatible:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="nx">parseCSV</code><code class="p">(</code><code class="kd">new</code> <code class="nx">Buffer</code><code class="p">(</code><code class="s">"column1,column2\nval1,val2"</code><code class="p">,</code> <code class="s">"utf-8"</code><code class="p">));</code>  <code class="c">// OK</code></pre>

            <p class="author1">If your library only depends on the types for another library, rather than its
              implementation, consider mirroring just the declarations you need into your own code. This will result in
              a similar experience for your TypeScript users and an improved experience for everyone else.</p>

            <p class="author1">If you depend on the implementation of a library, you may still be able to apply the same
              trick to avoid depending on its typings. But this becomes increasingly difficult as the dependence grows
              larger and more essential. If you’re copying a large portion of the type declarations for another library,
              you may want to formalize the relationship by making the <code class="calibre18">@types</code> dependency
              explicit.</p>

            <p class="author1">This technique is also helpful for severing dependencies between your unit tests and
              production systems. See the <code class="calibre18">getAuthors</code> example in <a
                href="#calibre_link-10" class="calibre9">Item 4</a>.</p>








            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-958">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">Use structural typing to sever dependencies that are nonessential.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Don’t force JavaScript users to depend on <code class="calibre18">@types</code>.
                      Don’t force web developers to depend on NodeJS.</p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>













        <section data-pdf-bookmark="Item 52: Be Aware of the Pitfalls of Testing Types" data-type="sect1"
          class="praise">
          <div class="praise" id="calibre_link-768">
            <h1 class="calibre16">Item 52: Be Aware of the Pitfalls of Testing Types</h1>

            <p class="author1">You<a data-primary="Testing types" data-type="indexterm" id="calibre_link-534"
                class="calibre9"></a><a data-primary="type declaration" data-secondary="pitfalls of testing types"
                data-type="indexterm" id="calibre_link-575" class="calibre9"></a><a data-primary="equality"
                data-type="indexterm" id="calibre_link-241" class="calibre9"></a><a data-primary="assignable to"
                data-type="indexterm" id="calibre_link-115" class="calibre9"></a><a data-primary="callbacks"
                data-secondary="testing inferred types" data-type="indexterm" id="calibre_link-149"
                class="calibre9"></a><a data-primary="functions" data-secondary="testing inferred types of callbacks"
                data-type="indexterm" id="calibre_link-288" class="calibre9"></a> wouldn’t publish code without writing
              tests for it (I hope!), and you shouldn’t publish type declarations without writing tests for them,
              either. But how do you test types? If you’re authoring type declarations, testing is an essential but
              surprisingly fraught undertaking. It’s tempting to make assertions about types inside the type system
              using the tools that TypeScript provides. But there are several pitfalls with this approach. Ultimately
              it’s safer and more straightforward<a data-primary="dtslint" data-type="indexterm" id="calibre_link-224"
                class="calibre9"></a> to use <code class="calibre18">dtslint</code> or a similar tool that inspects
              types from outside of the type system.</p>

            <p class="author1">Suppose you’ve written a type declaration for a <code class="calibre18">map</code>
              function provided by a utility library (the popular<a data-primary="Lodash library" data-type="indexterm"
                id="calibre_link-389" class="calibre9"></a><a data-primary="Underscore library" data-type="indexterm"
                id="calibre_link-708" class="calibre9"></a> Lodash and Underscore libraries both provide such a
              function):</p>

            <pre data-code-language="ts" data-type="programlisting" id="calibre_link-959"
              class="calibre17"><code class="kd">declare</code> <code class="kd">function</code> <code class="nx">map</code><code class="o">&lt;</code><code class="nx">U</code><code class="p">,</code> <code class="nx">V</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">array</code>: <code class="nx">U</code><code class="p">[],</code> <code class="nx">fn</code><code class="o">:</code> <code class="p">(</code><code class="nx">u</code>: <code class="nx">U</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">V</code><code class="p">)</code><code class="o">:</code> <code class="nx">V</code><code class="p">[];</code></pre>

            <p class="author1">How can you check that this type declaration results in the expected types? (Presumably
              there are separate tests for the implementation.) One common technique is to write a test file that calls
              the function:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="nx">map</code><code class="p">([</code><code class="s">'2017'</code><code class="p">,</code> <code class="s">'2018'</code><code class="p">,</code> <code class="s">'2019'</code><code class="p">],</code> <code class="nx">v</code> <code class="o">=&gt;</code> <code class="nb">Number</code><code class="p">(</code><code class="nx">v</code><code class="p">));</code></pre>

            <p class="author1">This will do some blunt error checking: if your declaration of <code
                class="calibre18">map</code> only listed a single parameter, this would catch the mistake. But does it
              feel like something is missing here?</p>

            <p class="author1">The equivalent of this style of test for runtime behavior might look something like this:
            </p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="nx">test</code><code class="p">(</code><code class="s">'square a number'</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="nx">square</code><code class="p">(</code><code class="mi">1</code><code class="p">);</code>
  <code class="nx">square</code><code class="p">(</code><code class="mi">2</code><code class="p">);</code>
<code class="p">});</code></pre>

            <p class="author1">Sure, this tests that the <code class="calibre18">square</code> function doesn’t throw an
              error. But it’s missing any checks on the return value, so there’s no real test of the behavior. An
              incorrect implementation of <code class="calibre18">square</code> would still pass this test.</p>

            <p class="author1">This approach is common in testing type declaration files because it’s simple to copy
              over existing unit tests for a library. And while it does provide some value, it would be much better to
              actually check some types!</p>

            <p class="author1">One way is to assign the result to a variable with a specific type:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">const</code> <code class="nx">lengths</code>: <code class="nx">number</code><code class="p">[]</code> <code class="o">=</code> <code class="nx">map</code><code class="p">([</code><code class="s">'john'</code><code class="p">,</code> <code class="s">'paul'</code><code class="p">],</code> <code class="nx">name</code> <code class="o">=&gt;</code> <code class="nx">name</code><code class="p">.</code><code class="nx">length</code><code class="p">);</code></pre>

            <p class="author1">This is exactly the sort of superfluous type declaration that <a href="#calibre_link-11"
                class="calibre9">Item 19</a> would encourage you to remove. But here it plays an essential role: it
              provides some confidence that the <code class="calibre18">map</code> declaration is at least doing
              something sensible with the types. And indeed you can find many type declarations in DefinitelyTyped that
              use exactly this approach for testing. But, as we’ll see, there are a few fundamental problems with using
              assignment for testing.</p>

            <p class="author1">One is that you have to create a named variable that is likely to be unused. This adds
              boilerplate, but also means that you’ll have to disable some forms of linting.</p>

            <p class="author1">A common workaround is to define a helper:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">function</code> <code class="nx">assertType</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">x</code>: <code class="nx">T</code><code class="p">)</code> <code class="p">{}</code>

<code class="nx">assertType</code><code class="o">&lt;</code><code class="kt">number</code><code class="p">[]</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">map</code><code class="p">([</code><code class="s">'john'</code><code class="p">,</code> <code class="s">'paul'</code><code class="p">],</code> <code class="nx">name</code> <code class="o">=&gt;</code> <code class="nx">name</code><code class="p">.</code><code class="nx">length</code><code class="p">));</code></pre>

            <p class="author1">This eliminates the unused variable issue, but there are still surprises.</p>

            <p class="author1">A second issue is that we’re checking <em class="calibre3">assignability</em> of the two
              types rather than equality. Often this works as you’d expect. For example:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">const</code> <code class="nx">n</code> <code class="o">=</code> <code class="mi">12</code><code class="p">;</code>
<code class="nx">assertType</code><code class="o">&lt;</code><code class="kt">number</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">n</code><code class="p">);</code>  <code class="c">// OK</code></pre>

            <p class="author1">If you inspect the <code class="calibre18">n</code> symbol, you’ll see that its type is
              actually <code class="calibre18">12</code>, a numeric literal type. This is a subtype of <code
                class="calibre18">number</code> and so the assignability check passes, just as you’d expect.</p>

            <p class="author1">So far so good. But things get murkier when you start checking the types of objects:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">beatles</code> <code class="o">=</code> <code class="p">[</code><code class="s">'john'</code><code class="p">,</code> <code class="s">'paul'</code><code class="p">,</code> <code class="s">'george'</code><code class="p">,</code> <code class="s">'ringo'</code><code class="p">];</code>
<code class="nx">assertType</code><code class="o">&lt;</code><code class="p">{</code><code class="nx">name</code>: <code class="kd">string</code><code class="p">}[]</code><code class="o">&gt;</code><code class="p">(</code>
  <code class="nx">map</code><code class="p">(</code><code class="nx">beatles</code><code class="p">,</code> <code class="nx">name</code> <code class="o">=&gt;</code> <code class="p">({</code>
    <code class="nx">name</code><code class="p">,</code>
    <code class="nx">inYellowSubmarine</code>: <code class="nx">name</code> <code class="o">===</code> <code class="s">'ringo'</code>
  <code class="p">})));</code>  <code class="c">// OK</code></pre>

            <p class="author1">The <code class="calibre18">map</code> call returns an array of <code
                class="calibre18">{name: string, inYellowSubmarine: boolean}</code> objects. This is assignable to <code
                class="calibre18">{name: string}[]</code>, sure, but shouldn’t we be forced to acknowledge the yellow
              submarine? Depending on the context you may or may not really want to check for type equality.</p>

            <p class="author1">If your function returns another function, you may be surprised at what’s considered
              assignable:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">const</code> <code class="nx">add</code> <code class="o">=</code> <code class="p">(</code><code class="nx">a</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">b</code>: <code class="nx">number</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code><code class="p">;</code>
<code class="nx">assertType</code><code class="o">&lt;</code><code class="p">(</code><code class="nx">a</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">b</code>: <code class="nx">number</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kt">number</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">add</code><code class="p">);</code>  <code class="c">// OK</code>

<code class="kd">const</code> <code class="kd">double</code> <code class="o">=</code> <code class="p">(</code><code class="nx">x</code>: <code class="nx">number</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="mi">2</code> <code class="o">*</code> <code class="nx">x</code><code class="p">;</code>
<code class="nx">assertType</code><code class="o">&lt;</code><code class="p">(</code><code class="nx">a</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">b</code>: <code class="nx">number</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kt">number</code><code class="o">&gt;</code><code class="p">(</code><code class="kd">double</code><code class="p">);</code>  <code class="c">// OK!?</code></pre>

            <p class="author1">Are you surprised that the second assertion succeeds? The reason is that a function in
              TypeScript is assignable to a function type, which takes fewer parameters:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">const</code> <code class="nx">g</code><code class="o">:</code> <code class="p">(</code><code class="nx">x</code>: <code class="kd">string</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">any</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="mi">12</code><code class="p">;</code>  <code class="c">// OK</code></pre>

            <p class="author1">This reflects the fact that it’s perfectly fine to call a JavaScript function with more
              parameters than it’s declared to take. TypeScript chooses to model this behavior rather than bar it,
              largely because it is pervasive in callbacks. The callback in the<a data-primary="Lodash library"
                data-type="indexterm" id="calibre_link-390" class="calibre9"></a> Lodash <code
                class="calibre18">map</code> function, for example, takes up to three parameters:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="nx">map</code><code class="p">(</code><code class="nx">array</code><code class="p">,</code> <code class="p">(</code><code class="nx">name</code><code class="p">,</code> <code class="nx">index</code><code class="p">,</code> <code class="nx">array</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">});</code></pre>

            <p class="author1">While all three are available, it’s very common to use only one or sometimes two, as we
              have so far in this item. In fact, it’s quite rare to use all three. By disallowing this assignment,
              TypeScript would report errors in an enormous amount of JavaScript code.</p>

            <p class="author1">So what can you do? You could break apart the function type and test its pieces using the
              generic <code class="calibre18">Parameters</code> and <code class="calibre18">ReturnType</code> types:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">const</code> <code class="kd">double</code> <code class="o">=</code> <code class="p">(</code><code class="nx">x</code>: <code class="nx">number</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="mi">2</code> <code class="o">*</code> <code class="nx">x</code><code class="p">;</code>
<code class="kd">let</code> <code class="nx">p</code>: <code class="nx">Parameters</code><code class="o">&lt;</code><code class="kd">typeof</code> <code class="kd">double</code><code class="o">&gt;</code> <code class="o">=</code> <code class="kd">null</code><code class="o">!</code><code class="p">;</code>
<code class="nx">assertType</code><code class="o">&lt;</code><code class="p">[</code><code class="kt">number</code><code class="p">,</code> <code class="kt">number</code><code class="p">]</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">p</code><code class="p">);</code>
<code class="c">//                           ~ Argument of type '[number]' is not</code>
<code class="c">//                             assignable to parameter of type [number, number]</code>
<code class="kd">let</code> <code class="nx">r</code>: <code class="nx">ReturnType</code><code class="o">&lt;</code><code class="kd">typeof</code> <code class="kd">double</code><code class="o">&gt;</code> <code class="o">=</code> <code class="kd">null</code><code class="o">!</code><code class="p">;</code>
<code class="nx">assertType</code><code class="o">&lt;</code><code class="kt">number</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">r</code><code class="p">);</code>  <code class="c">// OK</code></pre>

            <p class="author1">But if “this” isn’t complicated enough, there’s another issue: <code
                class="calibre18">map</code> sets the value of <code class="calibre18">this</code> for its callback.
              TypeScript can model this behavior (see <a href="#calibre_link-12" class="calibre9">Item 49</a>), so your
              type declaration should do so. And you should test it. How can we do that?</p>

            <p class="author1">Our tests of <code class="calibre18">map</code> so far have been a bit black box in
              style: we’ve run an array and function through <code class="calibre18">map</code> and tested the type of
              the result, but we haven’t tested the details of the intermediate steps. We can do so by filling out the
              callback function and verifying the types of its parameters and <code class="calibre18">this</code>
              directly:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">beatles</code> <code class="o">=</code> <code class="p">[</code><code class="s">'john'</code><code class="p">,</code> <code class="s">'paul'</code><code class="p">,</code> <code class="s">'george'</code><code class="p">,</code> <code class="s">'ringo'</code><code class="p">];</code>
<code class="nx">assertType</code><code class="o">&lt;</code><code class="kt">number</code><code class="p">[]</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">map</code><code class="p">(</code>
  <code class="nx">beatles</code><code class="p">,</code>
  <code class="kd">function</code><code class="p">(</code><code class="nx">name</code><code class="p">,</code> <code class="nx">i</code><code class="p">,</code> <code class="nx">array</code><code class="p">)</code> <code class="p">{</code>
<code class="c">// ~~~~~~~ Argument of type '(name: any, i: any, array: any) =&gt; any' is</code>
<code class="c">//         not assignable to parameter of type '(u: string) =&gt; any'</code>
    <code class="nx">assertType</code><code class="o">&lt;</code><code class="kt">string</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">name</code><code class="p">);</code>
    <code class="nx">assertType</code><code class="o">&lt;</code><code class="kt">number</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">i</code><code class="p">);</code>
    <code class="nx">assertType</code><code class="o">&lt;</code><code class="kt">string</code><code class="p">[]</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">array</code><code class="p">);</code>
    <code class="nx">assertType</code><code class="o">&lt;</code><code class="kt">string</code><code class="p">[]</code><code class="o">&gt;</code><code class="p">(</code><code class="kd">this</code><code class="p">);</code>
                      <code class="c">// ~~~~ 'this' implicitly has type 'any'</code>
    <code class="kd">return</code> <code class="nx">name</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">));</code></pre>

            <p class="author1">This surfaced a few issues with our declaration of <code class="calibre18">map</code>.
              Note the use of a non-arrow function so that we could test the type of <code
                class="calibre18">this</code>.</p>

            <p class="author1">Here is a declaration that passes the checks:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">declare</code> <code class="kd">function</code> <code class="nx">map</code><code class="o">&lt;</code><code class="nx">U</code><code class="p">,</code> <code class="nx">V</code><code class="o">&gt;</code><code class="p">(</code>
  <code class="nx">array</code>: <code class="nx">U</code><code class="p">[],</code>
  <code class="nx">fn</code><code class="o">:</code> <code class="p">(</code><code class="kd">this</code><code class="o">:</code> <code class="nx">U</code><code class="p">[],</code> <code class="nx">u</code>: <code class="nx">U</code><code class="p">,</code> <code class="nx">i</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">array</code>: <code class="nx">U</code><code class="p">[])</code> <code class="o">=&gt;</code> <code class="nx">V</code>
<code class="p">)</code><code class="o">:</code> <code class="nx">V</code><code class="p">[];</code></pre>

            <p class="author1">There remains a final issue, however, and it is a major one. Here’s a complete type
              declaration file for our module that will pass even the most stringent tests for <code
                class="calibre18">map</code> but is worse than useless:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">declare</code> <code class="nx">module</code> <code class="s">'overbar'</code><code class="p">;</code></pre>

            <p class="author1">This assigns an <code class="calibre18">any</code> type to the <em
                class="calibre3">entire module</em>. Your tests will all pass, but you won’t have any type safety.
              What’s worse, every call to a function in this module will quietly produce an <code
                class="calibre18">any</code> type, contagiously destroying type safety throughout your code. Even with
              <code class="calibre18">noImplicitAny</code>, you can still get <code class="calibre18">any</code> types
              through type declarations.
            </p>

            <p class="author1">Barring some advanced trickery, it’s quite difficult to detect an <code
                class="calibre18">any</code> type from within the type system. This is why the preferred method for
              testing type declarations is to use a tool that operates <em class="calibre3">outside</em> the type
              checker.</p>

            <p class="author1">For<a data-primary="dtslint" data-type="indexterm" id="calibre_link-225"
                class="calibre9"></a> type declarations in the DefinitelyTyped repository, this tool is <code
                class="calibre18">dtslint</code>. It operates through specially formatted comments. Here’s how you might
              write the last test for the <code class="calibre18">map</code> function using <code
                class="calibre18">dtslint</code>:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">beatles</code> <code class="o">=</code> <code class="p">[</code><code class="s">'john'</code><code class="p">,</code> <code class="s">'paul'</code><code class="p">,</code> <code class="s">'george'</code><code class="p">,</code> <code class="s">'ringo'</code><code class="p">];</code>
<code class="nx">map</code><code class="p">(</code><code class="nx">beatles</code><code class="p">,</code> <code class="kd">function</code><code class="p">(</code>
  <code class="nx">name</code><code class="p">,</code>  <code class="c">// $ExpectType string</code>
  <code class="nx">i</code><code class="p">,</code>     <code class="c">// $ExpectType number</code>
  <code class="nx">array</code>  <code class="c">// $ExpectType string[]</code>
<code class="p">)</code> <code class="p">{</code>
  <code class="kd">this</code>   <code class="c">// $ExpectType string[]</code>
  <code class="kd">return</code> <code class="nx">name</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code>
<code class="p">});</code>  <code class="c">// $ExpectType number[]</code></pre>

            <p class="author1">Rather than checking assignability, <code class="calibre18">dtslint</code> inspects the
              type of each symbol and does a textual comparison. This matches how you’d manually test the type
              declarations in your editor: <code class="calibre18">dtslint</code> essentially automates this process.
              This approach does have some drawbacks: <code class="calibre18">number|string</code> and <code
                class="calibre18">string|number</code> are textually different but the same type. But so are <code
                class="calibre18">string</code> and <code class="calibre18">any</code>, despite being assignable to each
              other, which is really the point.</p>

            <p class="author1">Testing type declarations is tricky business. You <em class="calibre3">should</em> test
              them. But be aware of the pitfalls of some of the common techniques and consider using a tool like <code
                class="calibre18">dtslint</code> to avoid them.</p>








            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-960">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">When testing types, be aware of the difference between equality and
                      assignability, particularly for function types.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">For functions that use callbacks, test the inferred types of the callback
                      parameters. Don’t forget to test the type of <code class="calibre18">this</code> if it’s part of
                      your API.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Be wary of <code class="calibre18">any</code> in tests involving types. Consider
                      using a tool like <code class="calibre18">dtslint</code> for stricter, less error-prone
                      checking.<a data-primary="" data-startref="test06" data-type="indexterm" id="calibre_link-535"
                        class="calibre9"></a></p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>







      </div>
    </section>
  </div>

  <div data-type="book" class="calibre1" id="calibre_link-819">
    <section data-pdf-bookmark="Chapter 7. Writing and Running Your Code" data-type="chapter" type="chapter"
      class="praise">
      <div class="praise" id="calibre_link-961">
        <h1 class="calibre14"><span class="calibre">Chapter 7. </span>Writing and Running Your Code</h1>


        <p class="author1">This chapter is a bit of a grab bag: it covers some issues that come up in writing code (not
          types) as well as issues you may run into when you run your code.</p>






        <section data-pdf-bookmark="Item 53: Prefer ECMAScript Features to TypeScript Features" data-type="sect1"
          class="praise">
          <div class="praise" id="calibre_link-19">
            <h1 class="calibre16">Item 53: Prefer ECMAScript Features to TypeScript Features</h1>

            <p class="author1">The<a data-primary="ECMAScript" data-type="indexterm" id="calibre_link-233"
                class="calibre9"></a><a data-primary="code, writing and running"
                data-secondary="ECMAScript versus TypeScript features" data-type="indexterm" id="calibre_link-170"
                class="calibre9"></a><a data-primary="TypeScript" data-secondary="relationship to JavaScript"
                data-type="indexterm" id="calibre_link-685" class="calibre9"></a><a data-primary="JavaScript"
                data-secondary="relationship to TypeScript" data-type="indexterm" id="calibre_link-356"
                class="calibre9"></a> relationship between TypeScript and JavaScript has changed over time. When
              Microsoft first started work on TypeScript in 2010, the prevailing attitude around JavaScript was that it
              was a problematic language that needed to be fixed. It was common for frameworks and source-to-source
              compilers to add missing features like classes, decorators, and a module system to JavaScript. TypeScript
              was no different. Early versions included home-grown versions of classes, enums, and modules.</p>

            <p class="author1">Over time TC39, the standards body that governs JavaScript, added many of these same
              features to the core JavaScript language. And the features they added were not compatible with the
              versions that existed in TypeScript. This left the TypeScript team in an awkward predicament: adopt the
              new features from the standard or break existing code?</p>

            <p class="author1">TypeScript has largely chosen to do the latter and eventually articulated its current
              governing principle: TC39 defines the runtime while TypeScript innovates solely in the type space.</p>

            <p class="author1">There are a few remaining features from before this decision. It’s important to recognize
              and understand these, because they don’t fit the pattern of the rest of the language. In general, I
              recommend avoiding them to keep the relationship between TypeScript and JavaScript as clear as possible.
            </p>








            <section class="praise" data-pdf-bookmark="Enums" data-type="sect2">
              <div class="praise" id="calibre_link-962">
                <h2 class="calibre31">Enums</h2>

                <p class="author1">Many<a data-primary="enums (enumerations)" data-type="indexterm"
                    id="calibre_link-240" class="calibre9"></a> languages model types that can take on a small set of
                  values using <em class="calibre3">enumerations</em> or <em class="calibre3">enums</em>. TypeScript
                  adds them to JavaScript:</p>

                <pre data-code-language="ts" data-type="programlisting"
                  class="calibre17"><code class="kd">enum</code> <code class="nx">Flavor</code> <code class="p">{</code>
  <code class="nx">VANILLA</code> <code class="o">=</code> <code class="mi">0</code><code class="p">,</code>
  <code class="nx">CHOCOLATE</code> <code class="o">=</code> <code class="mi">1</code><code class="p">,</code>
  <code class="nx">STRAWBERRY</code> <code class="o">=</code> <code class="mi">2</code><code class="p">,</code>
<code class="p">}</code>

<code class="kd">let</code> <code class="nx">flavor</code> <code class="o">=</code> <code class="nx">Flavor</code><code class="p">.</code><code class="nx">CHOCOLATE</code><code class="p">;</code>  <code class="c">// Type is Flavor</code>

<code class="nx">Flavor</code>  <code class="c">// Autocomplete shows: VANILLA, CHOCOLATE, STRAWBERRY</code>
<code class="nx">Flavor</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code>  <code class="c">// Value is "VANILLA"</code></pre>

                <p class="author1">The argument for enums is that they provide more safety and transparency than bare
                  numbers. But enums in TypeScript have some quirks. There are actually several variants on enums that
                  all have subtly different behaviors:</p>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">A number-valued enum (like <code class="calibre18">Flavor</code>). Any number is
                      assignable to this, so it’s not very safe. (It was designed this way to make bit flag structures
                      possible.)</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">A string-valued enum. This does offer type safety, and also more transparent
                      values at runtime. But it’s not structurally typed, unlike every other type in TypeScript (more on
                      this momentarily).</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1"><code class="calibre18">const enum</code>. Unlike regular enums, const enums go
                      away completely at runtime. If you changed to <code class="calibre18">const enum Flavor</code> in
                      the previous example, the compiler would rewrite <code class="calibre18">Flavor.CHOCOLATE</code>
                      as <code class="calibre18">0</code>. This also breaks our expectations around how the compiler
                      behaves and still has the divergent behaviors between <code class="calibre18">string</code> and
                      <code class="calibre18">number</code>-valued enums.
                    </p>
                  </li>
                  <li class="calibre12">
                    <p class="author1"><code class="calibre18">const enum</code> with the <code
                        class="calibre18">preserveConstEnums</code> flag set. This emits runtime code for <code
                        class="calibre18">const enum</code>s, just like for a regular <code
                        class="calibre18">enum</code>.</p>
                  </li>
                </ul>

                <p class="author1">That string-valued enums are nominally typed comes as a particular surprise, since
                  every other type in TypeScript uses structural typing for assignability (see <a
                    href="#calibre_link-10" class="calibre9">Item 4</a>):</p>

                <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">enum</code> <code class="nx">Flavor</code> <code class="p">{</code>
  <code class="nx">VANILLA</code> <code class="o">=</code> <code class="s">'vanilla'</code><code class="p">,</code>
  <code class="nx">CHOCOLATE</code> <code class="o">=</code> <code class="s">'chocolate'</code><code class="p">,</code>
  <code class="nx">STRAWBERRY</code> <code class="o">=</code> <code class="s">'strawberry'</code><code class="p">,</code>
<code class="p">}</code>

<code class="kd">let</code> <code class="nx">flavor</code> <code class="o">=</code> <code class="nx">Flavor</code><code class="p">.</code><code class="nx">CHOCOLATE</code><code class="p">;</code>  <code class="c">// Type is Flavor</code>
    <code class="nx">flavor</code> <code class="o">=</code> <code class="s">'strawberry'</code><code class="p">;</code>
 <code class="c">// ~~~~~~ Type '"strawberry"' is not assignable to type 'Flavor'</code></pre>

                <p class="author1">This has implications when you publish a library. Suppose you have a function that
                  takes a <code class="calibre18">Flavor</code>:</p>

                <pre data-code-language="ts" data-type="programlisting"
                  class="calibre17"><code class="kd">function</code> <code class="nx">scoop</code><code class="p">(</code><code class="nx">flavor</code>: <code class="nx">Flavor</code><code class="p">)</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">}</code></pre>

                <p class="author1">Because a <code class="calibre18">Flavor</code> at runtime is really just a string,
                  it’s fine for your JavaScript users to call it with one:</p>

                <pre data-code-language="js" data-type="programlisting"
                  class="calibre17"><code class="nx">scoop</code><code class="p">(</code><code class="s">'vanilla'</code><code class="p">);</code>  <code class="c">// OK in JavaScript</code></pre>

                <p class="author1">but your TypeScript users will need to import the <code class="calibre18">enum</code>
                  and use that instead:</p>

                <pre data-code-language="ts" data-type="programlisting"
                  class="calibre17"><code class="nx">scoop</code><code class="p">(</code><code class="s">'vanilla'</code><code class="p">);</code>
   <code class="c">// ~~~~~~~~~ '"vanilla"' is not assignable to parameter of type 'Flavor'</code>

<code class="kd">import</code> <code class="p">{</code><code class="nx">Flavor</code><code class="p">}</code> <code class="nx">from</code> <code class="s">'ice-cream'</code><code class="p">;</code>
<code class="nx">scoop</code><code class="p">(</code><code class="nx">Flavor</code><code class="p">.</code><code class="nx">VANILLA</code><code class="p">);</code>  <code class="c">// OK</code></pre>

                <p class="author1">These divergent experiences for JavaScript and TypeScript users are a reason to avoid
                  string-valued enums.</p>

                <p class="author1">TypeScript offers an alternative to enums that is less common in other languages: a
                  union of literal types.</p>

                <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">Flavor</code> <code class="o">=</code> <code class="s">'vanilla'</code> <code class="o">|</code> <code class="s">'chocolate'</code> <code class="o">|</code> <code class="s">'strawberry'</code><code class="p">;</code>

<code class="kd">let</code> <code class="nx">flavor</code>: <code class="nx">Flavor</code> <code class="o">=</code> <code class="s">'chocolate'</code><code class="p">;</code>  <code class="c">// OK</code>
    <code class="nx">flavor</code> <code class="o">=</code> <code class="s">'mint chip'</code><code class="p">;</code>
 <code class="c">// ~~~~~~ Type '"mint chip"' is not assignable to type 'Flavor'</code></pre>

                <p class="author1">This offers as much safety as the enum and has the advantage of translating more
                  directly to JavaScript. It also offers similarly strong autocomplete in your editor:</p>

                <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">scoop</code><code class="p">(</code><code class="nx">flavor</code>: <code class="nx">Flavor</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">flavor</code> <code class="o">===</code> <code class="s">'v</code>
<code class="s">                   // Autocomplete here suggests '</code><code class="nx">vanilla</code><code class="si">'</code>
<code class="p">}</code></pre>

                <p class="author1">For more on this approach, see <a href="#calibre_link-812" class="calibre9">Item
                    33</a>.</p>
              </div>
            </section>













            <section class="praise" data-pdf-bookmark="Parameter Properties" data-type="sect2">
              <div class="praise" id="calibre_link-963">
                <h2 class="calibre31">Parameter Properties</h2>

                <p class="author1">It’s<a data-primary="classes" data-secondary="parameter properties"
                    data-type="indexterm" id="calibre_link-156" class="calibre9"></a><a
                    data-primary="parameter properties" data-type="indexterm" id="calibre_link-454"
                    class="calibre9"></a><a data-primary="properties" data-secondary="parameter properties"
                    data-type="indexterm" id="calibre_link-471" class="calibre9"></a><a data-primary="classes"
                    data-secondary="this" data-type="indexterm" id="calibre_link-158" class="calibre9"></a> common to
                  assign properties to a constructor parameter when initializing a class:</p>

                <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">class</code> <code class="nx">Person</code> <code class="p">{</code>
  <code class="nx">name</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="kd">constructor</code><code class="p">(</code><code class="nx">name</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

                <p class="author1">TypeScript provides a more compact syntax for this:</p>

                <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">class</code> <code class="nx">Person</code> <code class="p">{</code>
  <code class="kd">constructor</code><code class="p">(</code><code class="kd">public</code> <code class="nx">name</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{}</code>
<code class="p">}</code></pre>

                <p class="author1">This is called a “parameter property,” and it is equivalent to the code in the first
                  example. There are a few issues to be aware of with parameter properties:</p>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">They are one of the few constructs which generates code when you compile to
                      JavaScript (<code class="calibre18">enum</code>s are another). Generally compilation just involves
                      erasing types.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Because the parameter is only used in generated code, the source looks like it
                      has unused parameters.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">A mix of parameter and non-parameter properties can hide the design of your
                      classes.</p>
                  </li>
                </ul>

                <p class="author1">For example:</p>

                <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">class</code> <code class="nx">Person</code> <code class="p">{</code>
  <code class="nx">first</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">last</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="kd">constructor</code><code class="p">(</code><code class="kd">public</code> <code class="nx">name</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{</code>
    <code class="p">[</code><code class="kd">this</code><code class="p">.</code><code class="nx">first</code><code class="p">,</code> <code class="kd">this</code><code class="p">.</code><code class="nx">last</code><code class="p">]</code> <code class="o">=</code> <code class="nx">name</code><code class="p">.</code><code class="nx">split</code><code class="p">(</code><code class="s">' '</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

                <p class="author1">This class has three properties (<code class="calibre18">first</code>, <code
                    class="calibre18">last</code>, <code class="calibre18">name</code>), but this is hard to read off
                  the code because only two are listed before the constructor. This gets worse if the constructor takes
                  other parameters, too.</p>

                <p class="author1">If your class consists <em class="calibre3">only</em> of parameter properties and no
                  methods, you might consider making it an <code class="calibre18">interface</code> and using object
                  literals. Remember that the two are assignable to one another because of structural typing <a
                    href="#calibre_link-10" class="calibre9">Item 4</a>:</p>

                <pre data-code-language="ts" data-type="programlisting"
                  class="calibre17"><code class="kd">class</code> <code class="nx">Person</code> <code class="p">{</code>
  <code class="kd">constructor</code><code class="p">(</code><code class="kd">public</code> <code class="nx">name</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{}</code>
<code class="p">}</code>
<code class="kd">const</code> <code class="nx">p</code>: <code class="kd">Person</code> <code class="o">=</code> <code class="p">{</code><code class="nx">name</code><code class="o">:</code> <code class="s">'Jed Bartlet'</code><code class="p">};</code>  <code class="c">// OK</code></pre>

                <p class="author1">Opinions are divided on parameter properties. While I generally avoid them, others
                  appreciate the saved keystrokes. Be aware that they do not fit the pattern of the rest of TypeScript,
                  and may in fact obscure that pattern for new developers. Try to avoid hiding the design of your class
                  by using a mix of parameter and non-parameter properties.</p>
              </div>
            </section>













            <section class="praise" data-pdf-bookmark="Namespaces and Triple-Slash Imports" data-type="sect2">
              <div class="praise" id="calibre_link-964">
                <h2 class="calibre31">Namespaces and Triple-Slash Imports</h2>

                <p class="author1">Before<a data-primary="namespace" data-secondary="triple-slash imports and"
                    data-type="indexterm" id="calibre_link-412" class="calibre9"></a><a
                    data-primary="triple-slash imports" data-type="indexterm" id="calibre_link-541"
                    class="calibre9"></a> ECMAScript 2015, JavaScript didn’t have an official module system. Different
                  environments added this missing feature in different ways: Node.js used <code
                    class="calibre18">require</code> and <code class="calibre18">module.exports</code> whereas AMD used
                  a <code class="calibre18">define</code> function with a callback.</p>

                <p class="author1">TypeScript also filled this gap with its own module system. This was done using a
                  <code class="calibre18">module</code> keyword and “triple-slash” imports. After ECMAScript 2015 added
                  an official module system, TypeScript added <code class="calibre18">namespace</code> as a synonym for
                  <code class="calibre18">module</code>, to avoid confusion:
                </p>

                <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="nx">namespace</code> <code class="nx">foo</code> <code class="p">{</code>
  <code class="kd">function</code> <code class="nx">bar() {</code><code class="p">}</code>
<code class="p">}</code></pre>

                <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="c">/// &lt;reference path="other.ts"/&gt;</code>
<code class="nx">foo</code><code class="p">.</code><code class="nx">bar</code><code class="p">();</code></pre>

                <p class="author1">Outside of type declarations, triple-slash imports and the <code
                    class="calibre18">module</code> keyword are just a historical curiosity. In your own code, you
                  should use ECMASCript 2015&ndash;style modules (<code class="calibre18">import</code> and <code
                    class="calibre18">export</code>). See <a href="#calibre_link-29" class="calibre9">Item 58</a>.</p>
              </div>
            </section>













            <section class="praise" data-pdf-bookmark="Decorators" data-type="sect2">
              <div class="praise" id="calibre_link-965">
                <h2 class="calibre31">Decorators</h2>

                <p class="author1">Decorators<a data-primary="decorators" data-type="indexterm" id="calibre_link-209"
                    class="calibre9"></a> can be used to annotate or modify classes, methods, and properties. For
                  example, you could define a <code class="calibre18">logged</code> annotation that logs all calls to a
                  method on a class:</p>

                <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">class</code> <code class="nx">Greeter</code> <code class="p">{</code>
  <code class="nx">greeting</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="kd">constructor</code><code class="p">(</code><code class="nx">message</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">this</code><code class="p">.</code><code class="nx">greeting</code> <code class="o">=</code> <code class="nx">message</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="kd">@logged</code>
  <code class="nx">greet() {</code>
    <code class="kd">return</code> <code class="s">"Hello, "</code> <code class="o">+</code> <code class="kd">this</code><code class="p">.</code><code class="nx">greeting</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="nx">logged</code><code class="p">(</code><code class="nx">target</code>: <code class="nx">any</code><code class="p">,</code> <code class="nx">name</code>: <code class="kd">string</code><code class="p">,</code> <code class="nx">descriptor</code>: <code class="nx">PropertyDescriptor</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">fn</code> <code class="o">=</code> <code class="nx">target</code><code class="p">[</code><code class="nx">name</code><code class="p">];</code>
  <code class="nx">descriptor</code><code class="p">.</code><code class="nx">value</code> <code class="o">=</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s">`Calling </code><code class="si">${</code><code class="nx">name</code><code class="si">}</code><code class="s">`</code><code class="p">);</code>
    <code class="kd">return</code> <code class="nx">fn</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="kd">this</code><code class="p">,</code> <code class="nx">arguments</code><code class="p">);</code>
  <code class="p">};</code>
<code class="p">}</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="kd">new</code> <code class="nx">Greeter</code><code class="p">(</code><code class="s">'Dave'</code><code class="p">).</code><code class="nx">greet</code><code class="p">());</code>
<code class="c">// Logs:</code>
<code class="c">// Calling greet</code>
<code class="c">// Hello, Dave</code></pre>

                <p class="author1">This<a data-primary="tsconfig.json" data-secondary="experimentalDecorators property"
                    data-type="indexterm" id="calibre_link-544" class="calibre9"></a> feature was initially added to
                  support the<a data-primary="Angular" data-type="indexterm" id="calibre_link-85" class="calibre9"></a>
                  Angular framework and requires the <code class="calibre18">experimentalDecorators</code> property to
                  be set in <code class="calibre18">tsconfig.json</code>. Their implementation has not yet been
                  standardized by TC39 at the time of this writing, so any code you write today using decorators is
                  liable to break or become non-standard in the future. Unless you’re using Angular or another framework
                  that requires annotations and until they’re standardized, don’t use TypeScript’s decorators.</p>
              </div>
            </section>













            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-966">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">By and large, you can convert TypeScript to JavaScript by removing all the types
                      from your code.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Enums, parameter properties, triple-slash imports, and decorators are historical
                      exceptions to this rule.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">In order to keep TypeScript’s role in your codebase as clear as possible, I
                      recommend avoiding these features.<a data-primary="" data-startref="CWRecma07"
                        data-type="indexterm" id="calibre_link-171" class="calibre9"></a><a data-primary=""
                        data-startref="ecma07" data-type="indexterm" id="calibre_link-234" class="calibre9"></a></p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>













        <section data-pdf-bookmark="Item 54: Know How to Iterate Over Objects" data-type="sect1" class="praise">
          <div class="praise" id="calibre_link-42">
            <h1 class="calibre16">Item 54: Know How to Iterate Over Objects</h1>

            <p class="author1">This<a data-primary="in construct" data-secondary="in (for-in)" data-type="indexterm"
                id="calibre_link-309" class="calibre9"></a><a data-primary="code, writing and running"
                data-secondary="iterating over objects" data-type="indexterm" id="calibre_link-173"
                class="calibre9"></a><a data-primary="let k: keyof T" data-type="indexterm" id="calibre_link-379"
                class="calibre9"></a><a data-primary="for-in loops" data-type="indexterm" id="calibre_link-272"
                class="calibre9"></a><a data-primary="Object.entries" data-type="indexterm" id="calibre_link-441"
                class="calibre9"></a><a data-primary="objects" data-secondary="iterating over" data-type="indexterm"
                id="calibre_link-449" class="calibre9"></a> code runs fine, and yet TypeScript flags an error in it.
              Why?</p>

            <pre data-code-language="ts" data-type="programlisting" id="calibre_link-967" class="calibre17"><code class="kd">const</code> <code class="nx">obj</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">one</code><code class="o">:</code> <code class="s">'uno'</code><code class="p">,</code>
  <code class="nx">two</code><code class="o">:</code> <code class="s">'dos'</code><code class="p">,</code>
  <code class="nx">three</code><code class="o">:</code> <code class="s">'tres'</code><code class="p">,</code>
<code class="p">};</code>
<code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="nx">k</code> <code class="kd">in</code> <code class="nx">obj</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">v</code> <code class="o">=</code> <code class="nx">obj</code><code class="p">[</code><code class="nx">k</code><code class="p">];</code>
         <code class="c">// ~~~~~~ Element implicitly has an 'any' type</code>
         <code class="c">//        because type ... has no index signature</code>
<code class="p">}</code></pre>

            <p class="author1">Inspecting the <code class="calibre18">obj</code> and <code class="calibre18">k</code>
              symbols gives a clue:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">obj</code> <code class="o">=</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">};</code>
<code class="c">// const obj: {</code>
<code class="c">//     one: string;</code>
<code class="c">//     two: string;</code>
<code class="c">//     three: string;</code>
<code class="c">// }</code>
<code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="nx">k</code> <code class="kd">in</code> <code class="nx">obj</code><code class="p">)</code> <code class="p">{</code>  <code class="c">// const k: string</code>
  <code class="c">// ...</code>
<code class="p">}</code></pre>

            <p class="author1">The type of <code class="calibre18">k</code> is <code class="calibre18">string</code>,
              but you’re trying to index into an object whose type only has three specific keys: <code
                class="calibre18">'one'</code>, <code class="calibre18">'two'</code>, and <code
                class="calibre18">'three'</code>. There are strings other than these three, so this has to fail.</p>

            <p class="author1">Plugging in a narrower type declaration for <code class="calibre18">k</code> fixes the
              issue:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">let</code> <code class="nx">k</code>: <code class="nx">keyof</code> <code class="kd">typeof</code> <code class="nx">obj</code><code class="p">;</code>  <code class="c">// Type is "one" | "two" | "three"</code>
<code class="kd">for</code> <code class="p">(</code><code class="nx">k</code> <code class="kd">in</code> <code class="nx">obj</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">v</code> <code class="o">=</code> <code class="nx">obj</code><code class="p">[</code><code class="nx">k</code><code class="p">];</code>  <code class="c">// OK</code>
<code class="p">}</code></pre>

            <p class="author1">So the real question is: why is the type of <code class="calibre18">k</code> in the first
              example inferred as <code class="calibre18">string</code> rather than <code
                class="calibre18">"one" | "two" | "three"</code>?</p>

            <p class="author1">To understand, let’s look at a slightly different example involving an interface and a
              function:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">ABC</code> <code class="p">{</code>
  <code class="nx">a</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">b</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">c</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="nx">foo</code><code class="p">(</code><code class="nx">abc</code>: <code class="nx">ABC</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="nx">k</code> <code class="kd">in</code> <code class="nx">abc</code><code class="p">)</code> <code class="p">{</code>  <code class="c">// const k: string</code>
    <code class="kd">const</code> <code class="nx">v</code> <code class="o">=</code> <code class="nx">abc</code><code class="p">[</code><code class="nx">k</code><code class="p">];</code>
           <code class="c">// ~~~~~~ Element implicitly has an 'any' type</code>
           <code class="c">//        because type 'ABC' has no index signature</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

            <p class="author1">It’s the same error as before. And you can “fix” it using the same sort of declaration
              (<code class="calibre18">let k: keyof ABC</code>). But in this case TypeScript is right to complain.
              Here’s why:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">const</code> <code class="nx">x</code> <code class="o">=</code> <code class="p">{</code><code class="nx">a</code><code class="o">:</code> <code class="s">'a'</code><code class="p">,</code> <code class="nx">b</code><code class="o">:</code> <code class="s">'b'</code><code class="p">,</code> <code class="nx">c</code>: <code class="nx">2</code><code class="p">,</code> <code class="nx">d</code>: <code class="nx">new</code> <code class="nb">Date</code><code class="p">()};</code>
<code class="nx">foo</code><code class="p">(</code><code class="nx">x</code><code class="p">);</code>  <code class="c">// OK</code></pre>

            <p class="author1">The<a data-primary="assignable to" data-type="indexterm" id="calibre_link-116"
                class="calibre9"></a> function <code class="calibre18">foo</code> can be called with any value <em
                class="calibre3">assignable</em> to <code class="calibre18">ABC</code>, not just a value with “a,” “b,”
              and “c” properties. It’s entirely possible that the value will have other properties, too (see <a
                href="#calibre_link-10" class="calibre9">Item 4</a>). To allow for this, TypeScript gives <code
                class="calibre18">k</code> the only type it can be confident of, namely, <code
                class="calibre18">string</code>.</p>

            <p class="author1">Using the <code class="calibre18">keyof</code> declaration would have another downside
              here:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">foo</code><code class="p">(</code><code class="nx">abc</code>: <code class="nx">ABC</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">k</code>: <code class="nx">keyof</code> <code class="nx">ABC</code><code class="p">;</code>
  <code class="kd">for</code> <code class="p">(</code><code class="nx">k</code> <code class="kd">in</code> <code class="nx">abc</code><code class="p">)</code> <code class="p">{</code>  <code class="c">// let k: "a" | "b" | "c"</code>
    <code class="kd">const</code> <code class="nx">v</code> <code class="o">=</code> <code class="nx">abc</code><code class="p">[</code><code class="nx">k</code><code class="p">];</code>  <code class="c">// Type is string | number</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

            <p class="author1">If <code class="calibre18">"a" | "b" | "c"</code> is too narrow for <code
                class="calibre18">k</code>, then <code class="calibre18">string | number</code> is certainly too narrow
              for <code class="calibre18">v</code>. In the preceding example one of the values is a <code
                class="calibre18">Date</code>, but it could be anything. The types here give a false sense of certainty
              that could lead to chaos at runtime.</p>

            <p class="author1">So what if you just want to iterate over the object’s keys and values without type
              errors? <code class="calibre18">Object.entries</code> lets you iterate over both simultaneously:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">foo</code><code class="p">(</code><code class="nx">abc</code>: <code class="nx">ABC</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="p">[</code><code class="nx">k</code><code class="p">,</code> <code class="nx">v</code><code class="p">]</code> <code class="nx">of</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">entries</code><code class="p">(</code><code class="nx">abc</code><code class="p">))</code> <code class="p">{</code>
    <code class="nx">k</code>  <code class="c">// Type is string</code>
    <code class="nx">v</code>  <code class="c">// Type is any</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

            <p class="author1">While these types may be hard to work with, they are at least honest!</p>

            <p class="author1">You<a data-primary="prototype pollution" data-type="indexterm" id="calibre_link-474"
                class="calibre9"></a> should also be aware of the possibility of <em class="calibre3">prototype
                pollution</em>. Even in the case of an object literal that you define, for-in can produce additional
              keys:</p>
            <pre data-type="programlisting" class="calibre17">&gt; <strong class="calibre32">Object.prototype.z = 3;</strong> // Please don't do this!
&gt; <strong class="calibre32">const obj = {x: 1, y: 2};</strong>
&gt; <strong class="calibre32">for (const k in obj) { console.log(k); }</strong>
x
y
z</pre>

            <p class="author1">Hopefully this doesn’t happen in a nonadversarial environment (you should never add
              enumerable properties to <code class="calibre18">Object.prototype</code>), but it is another reason that
              for-in produces <code class="calibre18">string</code> keys even for object literals.</p>

            <p class="author1">If you want to iterate over the keys and values in an object, use either a <code
                class="calibre18">keyof</code> declaration (<code class="calibre18">let k: keyof T</code>) or <code
                class="calibre18">Object.entries</code>. The former is appropriate for constants or other situations
              where you know that the object won’t have additional keys and you want precise types. The latter is more
              generally appropriate, though the key and value types are more difficult to work with.</p>








            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-968">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">Use <code class="calibre18">let k: keyof T</code> and a for-in loop to iterate
                      objects when you know exactly what the keys will be. Be aware that any objects your function
                      receives as parameters might have additional keys.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Use <code class="calibre18">Object.entries</code> to iterate over the keys and
                      values of any object.</p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>













        <section data-pdf-bookmark="Item 55: Understand the DOM hierarchy" data-type="sect1" class="praise">
          <div class="praise" id="calibre_link-26">
            <h1 class="calibre16">Item 55: Understand the DOM hierarchy</h1>

            <p class="author1">Most<a data-primary="code, writing and running" data-secondary="DOM hierarchy"
                data-type="indexterm" id="calibre_link-168" class="calibre9"></a><a data-primary="DOM hierarchy"
                data-type="indexterm" id="calibre_link-216" class="calibre9"></a><a data-primary="TypeScript"
                data-secondary="writing for browsers" data-type="indexterm" id="calibre_link-695" class="calibre9"></a>
              of the items in this book are agnostic about where you run your TypeScript: in a web browser, on a server,
              on a phone. This one is different. If you’re not working in a browser, skip ahead!</p>

            <p class="author1">The DOM hierarchy is always present when you’re running JavaScript in a web browser. When
              you use <code class="calibre18">document.getElementById</code> to get an element or <code
                class="calibre18">document.createElement</code> to create one, it’s always a particular kind of element,
              even if you’re not entirely familiar with the taxonomy. You call the methods and use the properties that
              you want and hope for the best.</p>

            <p class="author1">With<a data-primary="Node" data-type="indexterm" id="calibre_link-416"
                class="calibre9"></a><a data-primary="Element" data-type="indexterm" id="calibre_link-238"
                class="calibre9"></a><a data-primary="EventTarget" data-type="indexterm" id="calibre_link-258"
                class="calibre9"></a> TypeScript, the hierarchy of DOM elements becomes more visible. Knowing your <code
                class="calibre18">Node</code>s from your <code class="calibre18">Element</code>s and <code
                class="calibre18">EventTarget</code>s will help you debug type errors and decide when type assertions
              are appropriate. Because so many APIs are based on the DOM, this is relevant even if you’re using a
              framework like<a data-primary="React library" data-secondary="DOM hierarchy and" data-type="indexterm"
                id="calibre_link-483" class="calibre9"></a> React or d3.</p>

            <p class="author1">Suppose you want to track a user’s mouse as they drag it across a <code
                class="calibre18">&lt;div&gt;</code>. You write some seemingly innocuous JavaScript:</p>

            <pre data-code-language="js" data-type="programlisting"
              class="calibre17"><code class="kd">function</code> <code class="nx">handleDrag</code><code class="p">(</code><code class="nx">eDown</code><code class="o">:</code> <code class="nx">Event</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">targetEl</code> <code class="o">=</code> <code class="nx">eDown</code><code class="p">.</code><code class="nx">currentTarget</code><code class="p">;</code>
  <code class="nx">targetEl</code><code class="p">.</code><code class="nx">classList</code><code class="p">.</code><code class="nx">add</code><code class="p">(</code><code class="s">'dragging'</code><code class="p">);</code>
  <code class="kd">const</code> <code class="nx">dragStart</code> <code class="o">=</code> <code class="p">[</code><code class="nx">eDown</code><code class="p">.</code><code class="nx">clientX</code><code class="p">,</code> <code class="nx">eDown</code><code class="p">.</code><code class="nx">clientY</code><code class="p">];</code>
  <code class="kd">const</code> <code class="nx">handleUp</code> <code class="o">=</code> <code class="p">(</code><code class="nx">eUp</code><code class="o">:</code> <code class="nx">Event</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="nx">targetEl</code><code class="p">.</code><code class="nx">classList</code><code class="p">.</code><code class="nx">remove</code><code class="p">(</code><code class="s">'dragging'</code><code class="p">);</code>
    <code class="nx">targetEl</code><code class="p">.</code><code class="nx">removeEventListener</code><code class="p">(</code><code class="s">'mouseup'</code><code class="p">,</code> <code class="nx">handleUp</code><code class="p">);</code>
    <code class="kd">const</code> <code class="nx">dragEnd</code> <code class="o">=</code> <code class="p">[</code><code class="nx">eUp</code><code class="p">.</code><code class="nx">clientX</code><code class="p">,</code> <code class="nx">eUp</code><code class="p">.</code><code class="nx">clientY</code><code class="p">];</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s">'dx, dy = '</code><code class="p">,</code> <code class="p">[</code><code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">].</code><code class="nx">map</code><code class="p">(</code><code class="nx">i</code> <code class="o">=&gt;</code> <code class="nx">dragEnd</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code> <code class="o">-</code> <code class="nx">dragStart</code><code class="p">[</code><code class="nx">i</code><code class="p">]));</code>
  <code class="p">}</code>
  <code class="nx">targetEl</code><code class="p">.</code><code class="nx">addEventListener</code><code class="p">(</code><code class="s">'mouseup'</code><code class="p">,</code> <code class="nx">handleUp</code><code class="p">);</code>
<code class="p">}</code>
<code class="kd">const</code> <code class="nx">div</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s">'surface'</code><code class="p">);</code>
<code class="nx">div</code><code class="p">.</code><code class="nx">addEventListener</code><code class="p">(</code><code class="s">'mousedown'</code><code class="p">,</code> <code class="nx">handleDrag</code><code class="p">);</code></pre>

            <p class="author1">TypeScript’s type checker flags no fewer than 11 errors in these 14 lines of code:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">handleDrag</code><code class="p">(</code><code class="nx">eDown</code>: <code class="nx">Event</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">targetEl</code> <code class="o">=</code> <code class="nx">eDown</code><code class="p">.</code><code class="nx">currentTarget</code><code class="p">;</code>
  <code class="nx">targetEl</code><code class="p">.</code><code class="nx">classList</code><code class="p">.</code><code class="nx">add</code><code class="p">(</code><code class="s">'dragging'</code><code class="p">);</code>
<code class="c">// ~~~~~~~           Object is possibly 'null'.</code>
<code class="c">//         ~~~~~~~~~ Property 'classList' does not exist on type 'EventTarget'</code>
  <code class="kd">const</code> <code class="nx">dragStart</code> <code class="o">=</code> <code class="p">[</code>
     <code class="nx">eDown</code><code class="p">.</code><code class="nx">clientX</code><code class="p">,</code> <code class="nx">eDown</code><code class="p">.</code><code class="nx">clientY</code><code class="p">];</code>
        <code class="c">// ~~~~~~~                Property 'clientX' does not exist on 'Event'</code>
        <code class="c">//                ~~~~~~~ Property 'clientY' does not exist on 'Event'</code>
  <code class="kd">const</code> <code class="nx">handleUp</code> <code class="o">=</code> <code class="p">(</code><code class="nx">eUp</code>: <code class="nx">Event</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="nx">targetEl</code><code class="p">.</code><code class="nx">classList</code><code class="p">.</code><code class="nx">remove</code><code class="p">(</code><code class="s">'dragging'</code><code class="p">);</code>
<code class="c">//  ~~~~~~~~           Object is possibly 'null'.</code>
<code class="c">//           ~~~~~~~~~ Property 'classList' does not exist on type 'EventTarget'</code>
    <code class="nx">targetEl</code><code class="p">.</code><code class="nx">removeEventListener</code><code class="p">(</code><code class="s">'mouseup'</code><code class="p">,</code> <code class="nx">handleUp</code><code class="p">);</code>
<code class="c">//  ~~~~~~~~ Object is possibly 'null'</code>
    <code class="kd">const</code> <code class="nx">dragEnd</code> <code class="o">=</code> <code class="p">[</code>
       <code class="nx">eUp</code><code class="p">.</code><code class="nx">clientX</code><code class="p">,</code> <code class="nx">eUp</code><code class="p">.</code><code class="nx">clientY</code><code class="p">];</code>
        <code class="c">// ~~~~~~~                Property 'clientX' does not exist on 'Event'</code>
        <code class="c">//              ~~~~~~~   Property 'clientY' does not exist on 'Event'</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s">'dx, dy = '</code><code class="p">,</code> <code class="p">[</code><code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">].</code><code class="nx">map</code><code class="p">(</code><code class="nx">i</code> <code class="o">=&gt;</code> <code class="nx">dragEnd</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code> <code class="o">-</code> <code class="nx">dragStart</code><code class="p">[</code><code class="nx">i</code><code class="p">]));</code>
  <code class="p">}</code>
  <code class="nx">targetEl</code><code class="p">.</code><code class="nx">addEventListener</code><code class="p">(</code><code class="s">'mouseup'</code><code class="p">,</code> <code class="nx">handleUp</code><code class="p">);</code>
<code class="c">// ~~~~~~~ Object is possibly 'null'</code>
<code class="p">}</code>

   <code class="kd">const</code> <code class="nx">div</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s">'surface'</code><code class="p">);</code>
   <code class="nx">div</code><code class="p">.</code><code class="nx">addEventListener</code><code class="p">(</code><code class="s">'mousedown'</code><code class="p">,</code> <code class="nx">handleDrag</code><code class="p">);</code>
<code class="c">// ~~~ Object is possibly 'null'</code></pre>

            <p class="author1">What went wrong? What’s this <code class="calibre18">EventTarget</code>? And why might
              everything be <code class="calibre18">null</code>?</p>

            <p class="author1">To understand the <code class="calibre18">EventTarget</code> errors it helps to dig into
              the DOM hierarchy a bit. Here’s some HTML:</p>

            <pre data-code-language="html" data-type="programlisting"
              class="calibre17"><code class="nt">&lt;p</code> <code class="na">id=</code><code class="s">"quote"</code><code class="nt">&gt;</code>and <code class="nt">&lt;i&gt;</code>yet<code class="nt">&lt;/i&gt;</code> it moves<code class="nt">&lt;/p&gt;</code></pre>

            <p class="author1">If you open your browser’s JavaScript console and get a reference to the <code
                class="calibre18">p</code> element, you’ll see that it’s an <code
                class="calibre18">HTMLParagraphElement</code>:</p>

            <pre data-code-language="js" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">p</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">getElementsByTagName</code><code class="p">(</code><code class="s">'p'</code><code class="p">)[</code><code class="mi">0</code><code class="p">];</code>
<code class="nx">p</code> <code class="kd">instanceof</code> <code class="nx">HTMLParagraphElement</code>
<code class="c">// True</code></pre>

            <p class="author1">An <code class="calibre18">HTMLParagraphElement</code> is<a data-primary="HTMLElement"
                data-type="indexterm" id="calibre_link-306" class="calibre9"></a> a subtype of <code
                class="calibre18">HTMLElement</code>, which is a subtype of <code class="calibre18">Element</code>,
              which is a subtype of <code class="calibre18">Node</code>, which is a subtype of <code
                class="calibre18">EventTarget</code>. Here are some examples of types along the hierarchy:</p>
            <table class="calibre34">
              <caption class="calibre35"><span class="calibre">Table 7-1. </span>Types in the DOM Hierarchy</caption>
              <thead class="calibre36">
                <tr class="calibre37">
                  <th class="calibre38">Type</th>
                  <th class="calibre38">Examples</th>
                </tr>
              </thead>
              <tbody class="calibre39">
                <tr class="calibre37">
                  <td class="calibre40">
                    <p class="author1">EventTarget</p>
                  </td>
                  <td class="calibre40">
                    <p class="author1"><code class="calibre41">window</code>, <code
                        class="calibre41">XMLHttpRequest</code></p>
                  </td>
                </tr>
                <tr class="calibre42">
                  <td class="calibre40">
                    <p class="author1">Node</p>
                  </td>
                  <td class="calibre40">
                    <p class="author1"><code class="calibre41">document</code>, <code class="calibre41">Text</code>,
                      <code class="calibre41">Comment</code>
                    </p>
                  </td>
                </tr>
                <tr class="calibre37">
                  <td class="calibre40">
                    <p class="author1">Element</p>
                  </td>
                  <td class="calibre40">
                    <p class="author1"><em class="calibre3">includes HTMLElements, SVGElements</em></p>
                  </td>
                </tr>
                <tr class="calibre42">
                  <td class="calibre40">
                    <p class="author1">HTMLElement</p>
                  </td>
                  <td class="calibre40">
                    <p class="author1"><code class="calibre41">&lt;i&gt;</code>, <code
                        class="calibre41">&lt;b&gt;</code></p>
                  </td>
                </tr>
                <tr class="calibre37">
                  <td class="calibre40">
                    <p class="author1">HTMLButtonElement</p>
                  </td>
                  <td class="calibre40">
                    <p class="author1"><code class="calibre41">&lt;button&gt;</code></p>
                  </td>
                </tr>
              </tbody>
            </table>

            <p class="author1">An <code class="calibre18">EventTarget</code> is the most generic of DOM types. All you
              can do with it is add event listeners, remove them, and dispatch events. With this in mind, the <code
                class="calibre18">classList</code> errors start to make a bit more sense:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">handleDrag</code><code class="p">(</code><code class="nx">eDown</code>: <code class="nx">Event</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">targetEl</code> <code class="o">=</code> <code class="nx">eDown</code><code class="p">.</code><code class="nx">currentTarget</code><code class="p">;</code>
  <code class="nx">targetEl</code><code class="p">.</code><code class="nx">classList</code><code class="p">.</code><code class="nx">add</code><code class="p">(</code><code class="s">'dragging'</code><code class="p">);</code>
<code class="c">// ~~~~~~~           Object is possibly 'null'</code>
<code class="c">//         ~~~~~~~~~ Property 'classList' does not exist on type 'EventTarget'</code>
  <code class="c">// ...</code>
<code class="p">}</code></pre>

            <p class="author1">As its name implies, an <code class="calibre18">Event</code>’s <code
                class="calibre18">currentTarget</code> property is an <code class="calibre18">EventTarget</code>. It
              could even be <code class="calibre18">null</code>. TypeScript has no reason to believe that it has a <code
                class="calibre18">classList</code> property. While an <code class="calibre18">EventTarget</code>s <em
                class="calibre3">could</em> be an <code class="calibre18">HTMLElement</code> in practice, from the type
              system’s perspective there’s no reason it couldn’t be <code class="calibre18">window</code> or <code
                class="calibre18">XMLHTTPRequest</code>.</p>

            <p class="author1">Moving up the hierarchy we come to <code class="calibre18">Node</code>. A couple of
              examples of <code class="calibre18">Node</code>s that are not <code class="calibre18">Element</code>s are
              text fragments and comments. For instance, in this HTML:</p>

            <pre data-code-language="html" data-type="programlisting" class="calibre17"><code class="nt">&lt;p&gt;</code>
  And <code class="nt">&lt;i&gt;</code>yet<code class="nt">&lt;/i&gt;</code> it moves
  <code class="c1">&lt;!-- quote from Galileo --&gt;</code>
<code class="nt">&lt;/p&gt;</code></pre>

            <p class="author1">the outermost element is an <code class="calibre18">HTMLParagraphElement</code>. As you
              can see here, it has <code class="calibre18">children</code> and <code
                class="calibre18">childNodes</code>:</p>
            <pre data-type="programlisting" class="calibre17">&gt; <strong class="calibre32">p.children</strong>
HTMLCollection&nbsp;[i]
&gt; <strong class="calibre32">p.childNodes</strong>
NodeList(5)&nbsp;[text, i, text, comment, text]</pre>

            <p class="author1"><code class="calibre18">children</code> returns an <code
                class="calibre18">HTMLCollection</code>, an array-like structure containing just the child <code
                class="calibre18">Element</code>s (<code class="calibre18">&lt;i&gt;yet&lt;/i&gt;</code>). <code
                class="calibre18">childNodes</code> returns a <code class="calibre18">NodeList</code>, an Array-like
              collection of <code class="calibre18">Node</code>s. This includes not just <code
                class="calibre18">Element</code>s (<code class="calibre18">&lt;i&gt;yet&lt;/i&gt;</code>) but also text
              fragments (“And,” “it moves”) and comments (“quote from Galileo”).</p>

            <p class="author1">What’s the difference between an <code class="calibre18">Element</code> and an <code
                class="calibre18">HTMLElement</code>? There are non-HTML <code class="calibre18">Element</code>s
              including the whole hierarchy of SVG tags. These are <code class="calibre18">SVGElement</code>s, which are
              another type of <code class="calibre18">Element</code>. What’s the type of an <code
                class="calibre18">&lt;html&gt;</code> or <code class="calibre18">&lt;svg&gt;</code> tag? They’re <code
                class="calibre18">HTMLHtmlElement</code> and <code class="calibre18">SVGSvgElement</code>.</p>

            <p class="author1">Sometimes these specialized classes will have properties of their own&mdash;for example,
              an <code class="calibre18">HTMLImageElement</code> has a <code class="calibre18">src</code> property, and
              an <code class="calibre18">HTMLInputElement</code> has a <code class="calibre18">value</code> property. If
              you want to read one of these properties off a value, its type must be specific enough to have that
              property.</p>

            <p class="author1">TypeScript’s type declarations for the DOM make liberal use of literal types to try to
              get you the most specific type possible. For example:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="nb">document</code><code class="p">.</code><code class="nx">getElementsByTagName</code><code class="p">(</code><code class="s">'p'</code><code class="p">)[</code><code class="mi">0</code><code class="p">];</code>  <code class="c">// HTMLParagraphElement</code>
<code class="nb">document</code><code class="p">.</code><code class="nx">createElement</code><code class="p">(</code><code class="s">'button'</code><code class="p">);</code>  <code class="c">// HTMLButtonElement</code>
<code class="nb">document</code><code class="p">.</code><code class="nx">querySelector</code><code class="p">(</code><code class="s">'div'</code><code class="p">);</code>  <code class="c">// HTMLDivElement</code></pre>

            <p class="author1">but this is not always possible, notably with <code
                class="calibre18">document.getElementById</code>:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s">'my-div'</code><code class="p">);</code>  <code class="c">// HTMLElement</code></pre>

            <p class="author1">While type assertions are generally frowned upon (<a href="#calibre_link-27"
                class="calibre9">Item 9</a>), this is a case where you know more than TypeScript does and so they are
              appropriate. There’s nothing wrong with this, so long as you know that <code
                class="calibre18">#my-div</code> is a div:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s">'my-div'</code><code class="p">)</code> <code class="kd">as</code> <code class="nx">HTMLDivElement</code><code class="p">;</code></pre>

            <p class="author1">with <code class="calibre18">strictNullChecks</code> enabled, you will need to consider
              the case that <code class="calibre18">document.getElementById</code> returns <code
                class="calibre18">null</code>. Depending on whether this can really happen, you can either add an if
              statement or an assertion (<code class="calibre18">!</code>):</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">const</code> <code class="nx">div</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s">'my-div'</code><code class="p">)</code><code class="o">!</code><code class="p">;</code></pre>

            <p class="author1">These types are not specific to TypeScript. Rather, they are generated from the formal
              specification of the DOM. This is an example of the advice of <a href="#calibre_link-30"
                class="calibre9">Item 35</a> to generate types from specs when possible.</p>

            <p class="author1">So much for the DOM hierarchy. What about the <code class="calibre18">clientX</code> and
              <code class="calibre18">clientY</code> errors?
            </p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">handleDrag</code><code class="p">(</code><code class="nx">eDown</code>: <code class="nx">Event</code><code class="p">)</code> <code class="p">{</code>
  <code class="c">// ...</code>
  <code class="kd">const</code> <code class="nx">dragStart</code> <code class="o">=</code> <code class="p">[</code>
     <code class="nx">eDown</code><code class="p">.</code><code class="nx">clientX</code><code class="p">,</code> <code class="nx">eDown</code><code class="p">.</code><code class="nx">clientY</code><code class="p">];</code>
        <code class="c">// ~~~~~~~                Property 'clientX' does not exist on 'Event'</code>
        <code class="c">//                ~~~~~~~ Property 'clientY' does not exist on 'Event'</code>
  <code class="c">// ...</code>
<code class="p">}</code></pre>

            <p class="author1">In<a data-primary="Event" data-type="indexterm" id="calibre_link-257"
                class="calibre9"></a> addition to the hierarchy for <code class="calibre18">Node</code>s and <code
                class="calibre18">Element</code>s, there is also a hierarchy for <code class="calibre18">Event</code>s.
              The Mozilla documentation currently lists no fewer than 52 types of <code class="calibre18">Event</code>!
            </p>

            <p class="author1">Plain<a data-primary="MouseEvent" data-type="indexterm" id="calibre_link-406"
                class="calibre9"></a> <code class="calibre18">Event</code> is the most generic type of event. More
              specific types include:</p>
            <dl class="praise">
              <dt class="calibre19"><code class="calibre18">UIEvent</code></dt>
              <dd class="calibre20">
                <p class="author1">Any sort of user interface event</p>
              </dd>
              <dt class="calibre19"><code class="calibre18">MouseEvent</code></dt>
              <dd class="calibre20">
                <p class="author1">An event triggered by the mouse such as a click</p>
              </dd>
              <dt class="calibre19"><code class="calibre18">TouchEvent</code></dt>
              <dd class="calibre20">
                <p class="author1">A touch event on a mobile device</p>
              </dd>
              <dt class="calibre19"><code class="calibre18">WheelEvent</code></dt>
              <dd class="calibre20">
                <p class="author1">An event triggered by rotating the scroll wheel</p>
              </dd>
              <dt class="calibre19"><code class="calibre18">KeyboardEvent</code></dt>
              <dd class="calibre20">
                <p class="author1">A key press</p>
              </dd>
            </dl>

            <p class="author1">The problem in <code class="calibre18">handleDrag</code> is that the events are declared
              as <code class="calibre18">Event</code>, while <code class="calibre18">clientX</code> and <code
                class="calibre18">clientY</code> exist only on the more specific <code
                class="calibre18">MouseEvent</code> type.</p>

            <p class="author1">So how can you fix the example from the start of this item? TypeScript’s declarations for
              the DOM make extensive use of context (<a href="#calibre_link-760" class="calibre9">Item 26</a>). Inlining
              the mousedown handler gives TypeScript more information to work with and removes most of the errors. You
              can also declare the parameter type to be <code class="calibre18">MouseEvent</code> rather than <code
                class="calibre18">Event</code>. Here’s a version that uses both techniques to fix the errors:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">addDragHandler</code><code class="p">(</code><code class="nx">el</code>: <code class="nx">HTMLElement</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">el</code><code class="p">.</code><code class="nx">addEventListener</code><code class="p">(</code><code class="s">'mousedown'</code><code class="p">,</code> <code class="nx">eDown</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="kd">const</code> <code class="nx">dragStart</code> <code class="o">=</code> <code class="p">[</code><code class="nx">eDown</code><code class="p">.</code><code class="nx">clientX</code><code class="p">,</code> <code class="nx">eDown</code><code class="p">.</code><code class="nx">clientY</code><code class="p">];</code>
    <code class="kd">const</code> <code class="nx">handleUp</code> <code class="o">=</code> <code class="p">(</code><code class="nx">eUp</code>: <code class="nx">MouseEvent</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
      <code class="nx">el</code><code class="p">.</code><code class="nx">classList</code><code class="p">.</code><code class="nx">remove</code><code class="p">(</code><code class="s">'dragging'</code><code class="p">);</code>
      <code class="nx">el</code><code class="p">.</code><code class="nx">removeEventListener</code><code class="p">(</code><code class="s">'mouseup'</code><code class="p">,</code> <code class="nx">handleUp</code><code class="p">);</code>
      <code class="kd">const</code> <code class="nx">dragEnd</code> <code class="o">=</code> <code class="p">[</code><code class="nx">eUp</code><code class="p">.</code><code class="nx">clientX</code><code class="p">,</code> <code class="nx">eUp</code><code class="p">.</code><code class="nx">clientY</code><code class="p">];</code>
      <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s">'dx, dy = '</code><code class="p">,</code> <code class="p">[</code><code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">].</code><code class="nx">map</code><code class="p">(</code><code class="nx">i</code> <code class="o">=&gt;</code> <code class="nx">dragEnd</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code> <code class="o">-</code> <code class="nx">dragStart</code><code class="p">[</code><code class="nx">i</code><code class="p">]));</code>
    <code class="p">}</code>
    <code class="nx">el</code><code class="p">.</code><code class="nx">addEventListener</code><code class="p">(</code><code class="s">'mouseup'</code><code class="p">,</code> <code class="nx">handleUp</code><code class="p">);</code>
  <code class="p">});</code>
<code class="p">}</code>

<code class="kd">const</code> <code class="nx">div</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s">'surface'</code><code class="p">);</code>
<code class="kd">if</code> <code class="p">(</code><code class="nx">div</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">addDragHandler</code><code class="p">(</code><code class="nx">div</code><code class="p">);</code>
<code class="p">}</code></pre>

            <p class="author1">The <code class="calibre18">if</code> statement at the end handles the possibility that
              there is no <code class="calibre18">#surface</code> element. If you know that this element exists, you
              could use an assertion instead (<code class="calibre18">div!</code>). <code
                class="calibre18">addDragHandler</code> requires a non-null <code class="calibre18">HTMLElement</code>,
              so this is an example of pushing <code class="calibre18">null</code> values to the perimeter (<a
                href="#calibre_link-799" class="calibre9">Item 31</a>).</p>








            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-969">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">The DOM has a type hierarchy that you can usually ignore while writing
                      JavaScript. But these types become more important in TypeScript. Understanding them will help you
                      write TypeScript for the browser.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Know the differences between <code class="calibre18">Node</code>, <code
                        class="calibre18">Element</code>, <code class="calibre18">HTMLElement</code>, and <code
                        class="calibre18">EventTarget</code>, as well as those between <code
                        class="calibre18">Event</code> and <code class="calibre18">MouseEvent</code>.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Either use a specific enough type for DOM elements and Events in your code or
                      give TypeScript the context to infer it.<a data-primary="" data-startref="CWRdom07"
                        data-type="indexterm" id="calibre_link-169" class="calibre9"></a><a data-primary=""
                        data-startref="DOM07" data-type="indexterm" id="calibre_link-217" class="calibre9"></a><a
                        data-primary="" data-startref="TSbrowser07" data-type="indexterm" id="calibre_link-696"
                        class="calibre9"></a></p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>













        <section data-pdf-bookmark="Item 56: Don’t Rely on Private to Hide Information" data-type="sect1"
          class="praise">
          <div class="praise" id="calibre_link-769">
            <h1 class="calibre16">Item 56: Don’t Rely on Private to Hide Information</h1>

            <p class="author1">JavaScript<a data-primary="classes" data-secondary="private fields" data-type="indexterm"
                id="calibre_link-157" class="calibre9"></a><a data-primary="code, writing and running"
                data-secondary="hiding information" data-type="indexterm" id="calibre_link-172" class="calibre9"></a><a
                data-primary="private field modifier" data-type="indexterm" id="calibre_link-461"
                class="calibre9"></a><a data-primary="public field modifier" data-type="indexterm" id="calibre_link-478"
                class="calibre9"></a><a data-primary="protected field modifier" data-type="indexterm"
                id="calibre_link-473" class="calibre9"></a> has historically lacked a way to make properties of a class
              private. The usual workaround is a convention of prefixing fields that are not part of a public API with
              underscores:</p>

            <pre data-code-language="js" data-type="programlisting" class="calibre17"><code class="kd">class</code> <code class="nx">Foo</code> <code class="p">{</code>
  <code class="nx">_private</code> <code class="o">=</code> <code class="s">'secret123'</code><code class="p">;</code>
<code class="p">}</code></pre>

            <p class="author1">But this only discourages users from accessing private data. It is easy to circumvent:
            </p>

            <pre data-code-language="js" data-type="programlisting"
              class="calibre17"><code class="kd">const</code> <code class="nx">f</code> <code class="o">=</code> <code class="kd">new</code> <code class="nx">Foo</code><code class="p">();</code>
<code class="nx">f</code><code class="p">.</code><code class="nx">_private</code><code class="p">;</code>  <code class="c">// 'secret123'</code></pre>

            <p class="author1">TypeScript adds <code class="calibre18">public</code>, <code
                class="calibre18">protected</code>, and <code class="calibre18">private</code> field modifiers that seem
              to provide some enforcement:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">class</code> <code class="nx">Diary</code> <code class="p">{</code>
  <code class="kd">private</code> <code class="nx">secret</code> <code class="o">=</code> <code class="s">'cheated on my English test'</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">const</code> <code class="nx">diary</code> <code class="o">=</code> <code class="kd">new</code> <code class="nx">Diary</code><code class="p">();</code>
<code class="nx">diary</code><code class="p">.</code><code class="nx">secret</code>
   <code class="c">// ~~~~~~ Property 'secret' is private and only</code>
   <code class="c">//        accessible within class 'Diary'</code></pre>

            <p class="author1">But <code class="calibre18">private</code> is a feature of the type system and, like all
              features of the type system, it goes away at runtime (see <a href="#calibre_link-1" class="calibre9">Item
                3</a>). Here’s<a data-primary="ES2017" data-type="indexterm" id="calibre_link-250" class="calibre9"></a>
              what this snippet looks like when TypeScript compiles it to JavaScript (with <code
                class="calibre18">target=ES2017</code>):</p>

            <pre data-code-language="js" data-type="programlisting" class="calibre17"><code class="kd">class</code> <code class="nx">Diary</code> <code class="p">{</code>
  <code class="nx">constructor</code><code class="p">()</code> <code class="p">{</code>
    <code class="kd">this</code><code class="p">.</code><code class="nx">secret</code> <code class="o">=</code> <code class="s">'cheated on my English test'</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>
<code class="kd">const</code> <code class="nx">diary</code> <code class="o">=</code> <code class="kd">new</code> <code class="nx">Diary</code><code class="p">();</code>
<code class="nx">diary</code><code class="p">.</code><code class="nx">secret</code><code class="p">;</code></pre>

            <p class="author1">The <code class="calibre18">private</code> indicator is gone, and your secret is out!
              Much like the <code class="calibre18">_private</code> convention, TypeScript’s access modifiers only
              discourage you from accessing private data. With a type assertion, you can even access a private property
              from within TypeScript:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">class</code> <code class="nx">Diary</code> <code class="p">{</code>
  <code class="kd">private</code> <code class="nx">secret</code> <code class="o">=</code> <code class="s">'cheated on my English test'</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">const</code> <code class="nx">diary</code> <code class="o">=</code> <code class="kd">new</code> <code class="nx">Diary</code><code class="p">();</code>
<code class="p">(</code><code class="nx">diary</code><code class="si">&nbsp;</code><code class="kd">as</code> <code class="nx">any</code><code class="p">).</code><code class="nx">secret</code>  <code class="c">// OK</code></pre>

            <p class="author1">In other words, <em class="calibre3">don’t rely on <code class="calibre23">private</code>
                to hide information!</em></p>

            <p class="author1">So<a data-primary="closures" data-type="indexterm" id="calibre_link-162"
                class="calibre9"></a> what should you do if you want something more robust? The traditional answer has
              been to take advantage of one of JavaScript’s most reliable ways to hide information: closures. You can
              create one in a constructor:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">declare</code> <code class="kd">function</code> <code class="nx">hash</code><code class="p">(</code><code class="nx">text</code>: <code class="kd">string</code><code class="p">)</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>

<code class="kd">class</code> <code class="nx">PasswordChecker</code> <code class="p">{</code>
  <code class="nx">checkPassword</code><code class="o">:</code> <code class="p">(</code><code class="nx">password</code>: <code class="kd">string</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kd">boolean</code><code class="p">;</code>
  <code class="kd">constructor</code><code class="p">(</code><code class="nx">passwordHash</code>: <code class="nx">number</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">this</code><code class="p">.</code><code class="nx">checkPassword</code> <code class="o">=</code> <code class="p">(</code><code class="nx">password</code>: <code class="kd">string</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
      <code class="kd">return</code> <code class="nx">hash</code><code class="p">(</code><code class="nx">password</code><code class="p">)</code> <code class="o">===</code> <code class="nx">passwordHash</code><code class="p">;</code>
    <code class="p">}</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kd">const</code> <code class="nx">checker</code> <code class="o">=</code> <code class="kd">new</code> <code class="nx">PasswordChecker</code><code class="p">(</code><code class="nx">hash</code><code class="p">(</code><code class="s">'s3cret'</code><code class="p">));</code>
<code class="nx">checker</code><code class="p">.</code><code class="nx">checkPassword</code><code class="p">(</code><code class="s">'s3cret'</code><code class="p">);</code>  <code class="c">// Returns true</code></pre>

            <p class="author1">JavaScript offers no way to access the <code class="calibre18">passwordHash</code>
              variable from outside of the constructor of <code class="calibre18">PasswordChecker</code>. This does have
              a few downsides, however: specifically, because <code class="calibre18">passwordHash</code> can’t be seen
              outside the constructor, every method that uses it also has to be defined there. This results in a copy of
              each method being created for every class instance, which will lead to higher memory use. It also prevents
              other instances of the same class from accessing private data. Closures may be inconvenient, but they will
              certainly keep your data private!</p>

            <p class="author1">A<a data-primary="# (private field prefix)" data-type="indexterm" id="calibre_link-57"
                class="calibre9"></a> newer option is to use private fields, a proposed language feature that is
              solidifying as this book goes to print. In this proposal, to make a field private both for type checking
              and at runtime, prefix it with a <code class="calibre18">#</code>:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">class</code> <code class="nx">PasswordChecker</code> <code class="p">{</code>
  <code class="si">#</code><code class="nx">passwordHash</code>: <code class="nx">number</code><code class="p">;</code>

  <code class="kd">constructor</code><code class="p">(</code><code class="nx">passwordHash</code>: <code class="nx">number</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">this</code><code class="p">.</code><code class="si">#</code><code class="nx">passwordHash</code> <code class="o">=</code> <code class="nx">passwordHash</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nx">checkPassword</code><code class="p">(</code><code class="nx">password</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">return</code> <code class="nx">hash</code><code class="p">(</code><code class="nx">password</code><code class="p">)</code> <code class="o">===</code> <code class="kd">this</code><code class="p">.</code><code class="si">#</code><code class="nx">passwordHash</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kd">const</code> <code class="nx">checker</code> <code class="o">=</code> <code class="kd">new</code> <code class="nx">PasswordChecker</code><code class="p">(</code><code class="nx">hash</code><code class="p">(</code><code class="s">'s3cret'</code><code class="p">));</code>
<code class="nx">checker</code><code class="p">.</code><code class="nx">checkPassword</code><code class="p">(</code><code class="s">'secret'</code><code class="p">);</code>  <code class="c">// Returns false</code>
<code class="nx">checker</code><code class="p">.</code><code class="nx">checkPassword</code><code class="p">(</code><code class="s">'s3cret'</code><code class="p">);</code>  <code class="c">// Returns true</code></pre>

            <p class="author1">The <code class="calibre18">#passwordHash</code> property is not accessible from outside
              the class. In contrast to the closure technique, it <em class="calibre3">is</em> accessible from class
              methods and from other instances of the same class. For ECMAScript targets that don’t natively support
              private fields, a fallback implementation using <code class="calibre18">WeakMap</code>s is used instead.
              The upshot is that your data is still private. This proposal was stage 3 and support was being added to
              TypeScript as this book went to print. If you’d like to use it, check the TypeScript release notes to see
              if it’s generally available.</p>

            <p class="author1">Finally, if<a data-primary="security" data-type="indexterm" id="calibre_link-502"
                class="calibre9"></a> you are worried about <em class="calibre3">security</em>, rather than just
              encapsulation, then there are others concerns to be aware of such as modifications to built-in prototypes
              and functions.</p>








            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-970">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">The <code class="calibre18">private</code> access modifier is only enforced
                      through the type system. It has no effect at runtime and can be bypassed with an assertion. Don’t
                      assume it will keep data hidden.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">For more reliable information hiding, use a closure.</p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>













        <section data-pdf-bookmark="Item 57: Use Source Maps to Debug TypeScript" data-type="sect1" class="praise">
          <div class="praise" id="calibre_link-971">
            <h1 class="calibre16">Item 57: Use Source Maps to Debug TypeScript</h1>

            <p class="author1">When<a data-primary="code, writing and running"
                data-secondary="debugging with source maps" data-type="indexterm" id="calibre_link-166"
                class="calibre9"></a><a data-primary="debugging" data-secondary="with source maps"
                data-secondary-sortas="source maps" data-type="indexterm" id="calibre_link-204" class="calibre9"></a><a
                data-primary="source maps" data-type="indexterm" id="calibre_link-504" class="calibre9"></a> you run
              TypeScript code, you’re actually running the JavaScript that the TypeScript compiler generates. This is
              true of any source-to-source compiler, be it a minifier, a compiler, or a preprocessor. The hope is that
              this is mostly transparent, that you can pretend that the TypeScript source code is being executed without
              ever having to look at the JavaScript.</p>

            <p class="author1">This works well until you have to debug your code. Debuggers generally work on the code
              you’re executing and don’t know about the translation process it went through. Since JavaScript is such a
              popular target language, browser vendors collaborated to solve this problem. The result is source maps.
              They map positions and symbols in a generated file back to the corresponding positions and symbols in the
              original source. Most browsers and many IDEs support them. If you’re not using them to debug your
              TypeScript, you’re missing out!</p>

            <p class="author1">Suppose you’ve created a small script to add a button to an HTML page that increments
              every time you click it:</p>

            <pre data-code-language="ts" data-type="programlisting"
              class="calibre17"><code class="kd">function</code> <code class="nx">addCounter</code><code class="p">(</code><code class="nx">el</code>: <code class="nx">HTMLElement</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">clickCount</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
  <code class="kd">const</code> <code class="nx">button</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">createElement</code><code class="p">(</code><code class="s">'button'</code><code class="p">);</code>
  <code class="nx">button</code><code class="p">.</code><code class="nx">textContent</code> <code class="o">=</code> <code class="s">'Click me'</code><code class="p">;</code>
  <code class="nx">button</code><code class="p">.</code><code class="nx">addEventListener</code><code class="p">(</code><code class="s">'click'</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="nx">clickCount</code><code class="o">++</code><code class="p">;</code>
    <code class="nx">button</code><code class="p">.</code><code class="nx">textContent</code> <code class="o">=</code> <code class="s">`Click me (</code><code class="si">${</code><code class="nx">clickCount</code><code class="si">}</code><code class="s">)`</code><code class="p">;</code>
  <code class="p">});</code>
  <code class="nx">el</code><code class="p">.</code><code class="nx">appendChild</code><code class="p">(</code><code class="nx">button</code><code class="p">);</code>
<code class="p">}</code>

<code class="nx">addCounter</code><code class="p">(</code><code class="nb">document</code><code class="p">.</code><code class="nx">body</code><code class="p">);</code></pre>

            <p class="author1">If you load this in your browser and open the debugger, you’ll see the generated
              JavaScript. This closely matches the original source, so debugging isn’t too difficult, as you can see in
              <a data-type="xref" href="#calibre_link-820" class="calibre9">Figure&nbsp;7-1</a>.
            </p>

            <figure class="calibre28">
              <div class="figure" id="calibre_link-820">
                <img alt="efts 07in01" src="images/000028.png" class="calibre29" />
                <h6 class="calibre30"><span class="calibre">Figure 7-1. </span>Debugging generated JavaScript using
                  Chrome’s developer tools. For this simple example, the generated JavaScript closely resembles the
                  TypeScript source.</h6>
              </div>
            </figure>

            <p class="author1">Let’s make the page more fun by fetching an interesting fact about each number from
              numbersapi.com:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">addCounter</code><code class="p">(</code><code class="nx">el</code>: <code class="nx">HTMLElement</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">clickCount</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
  <code class="kd">const</code> <code class="nx">triviaEl</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">createElement</code><code class="p">(</code><code class="s">'p'</code><code class="p">);</code>
  <code class="kd">const</code> <code class="nx">button</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">createElement</code><code class="p">(</code><code class="s">'button'</code><code class="p">);</code>
  <code class="nx">button</code><code class="p">.</code><code class="nx">textContent</code> <code class="o">=</code> <code class="s">'Click me'</code><code class="p">;</code>
  <code class="nx">button</code><code class="p">.</code><code class="nx">addEventListener</code><code class="p">(</code><code class="s">'click'</code><code class="p">,</code> <code class="kd">async</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="nx">clickCount</code><code class="o">++</code><code class="p">;</code>
    <code class="kd">const</code> <code class="nx">response</code> <code class="o">=</code> <code class="kd">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="s">`http://numbersapi.com/</code><code class="si">${</code><code class="nx">clickCount</code><code class="si">}</code><code class="s">`</code><code class="p">);</code>
    <code class="kd">const</code> <code class="nx">trivia</code> <code class="o">=</code> <code class="kd">await</code> <code class="nx">response</code><code class="p">.</code><code class="nx">text</code><code class="p">();</code>
    <code class="nx">triviaEl</code><code class="p">.</code><code class="nx">textContent</code> <code class="o">=</code> <code class="nx">trivia</code><code class="p">;</code>
    <code class="nx">button</code><code class="p">.</code><code class="nx">textContent</code> <code class="o">=</code> <code class="s">`Click me (</code><code class="si">${</code><code class="nx">clickCount</code><code class="si">}</code><code class="s">)`</code><code class="p">;</code>
  <code class="p">});</code>
  <code class="nx">el</code><code class="p">.</code><code class="nx">appendChild</code><code class="p">(</code><code class="nx">triviaEl</code><code class="p">);</code>
  <code class="nx">el</code><code class="p">.</code><code class="nx">appendChild</code><code class="p">(</code><code class="nx">button</code><code class="p">);</code>
<code class="p">}</code></pre>

            <p class="author1">If you open up your browser’s debugger now, you’ll see that the generated source has
              gotten dramatically more complicated (see <a data-type="xref" href="#calibre_link-821"
                class="calibre9">Figure&nbsp;7-2</a>).</p>

            <figure class="calibre28">
              <div class="figure" id="calibre_link-821">
                <img alt="efts 07in02" src="images/000009.png" class="calibre29" />
                <h6 class="calibre30"><span class="calibre">Figure 7-2. </span>In this case the TypeScript compiler has
                  generated JavaScript that doesn’t closely resemble the original TypeScript source. This will make
                  debugging more difficult.</h6>
              </div>
            </figure>

            <p class="author1">To support <code class="calibre18">async</code> and <code class="calibre18">await</code>
              in older browsers, TypeScript has rewritten the event handler as a state machine. This has the same
              behavior, but the code no longer bears such a close resemblance to the original source.</p>

            <p class="author1">This<a data-primary="tsconfig.json" data-secondary="sourceMap option"
                data-type="indexterm" id="calibre_link-549" class="calibre9"></a> is where source maps can help. To tell
              TypeScript to generate one, set the <code class="calibre18">sourceMap</code> option in your <em
                class="calibre3">tsconfig.json</em>:</p>

            <pre data-code-language="json" data-type="programlisting" class="calibre17"><code class="p">{</code>
  <code class="nt">"compilerOptions"</code><code class="p">:</code> <code class="p">{</code>
    <code class="nt">"sourceMap"</code><code class="p">:</code> <code class="kd">true</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

            <p class="author1">Now when you run <code class="calibre18">tsc</code>, it generates two output files for
              each <em class="calibre3">.ts</em> file: a <em class="calibre3">.js</em> file and a <em
                class="calibre3">.js.map</em> file. The latter is the source map.</p>

            <p class="author1">With this file in place, a new <em class="calibre3">index.ts</em> file appears in your
              browser’s debugger. You can set breakpoints and inspect variables in it, just as you’d hope (see <a
                data-type="xref" href="#calibre_link-822" class="calibre9">Figure&nbsp;7-3</a>).</p>

            <figure class="calibre28">
              <div class="figure" id="calibre_link-822">
                <img alt="efts 07in03" src="images/000031.png" class="calibre29" />
                <h6 class="calibre30"><span class="calibre">Figure 7-3. </span>When a source map is present, you can
                  work with the original TypeScript source in your debugger, rather than the generated JavaScript.</h6>
              </div>
            </figure>

            <p class="author1">Note that <em class="calibre3">index.ts</em> appears in italics in the file list on the
              left. This indicates that it isn’t a “real” file in the sense that the web page included it. Rather, it
              was included via the source map. Depending on your settings, <em class="calibre3">index.js.map</em> will
              contain either a reference to <em class="calibre3">index.ts</em> (in which case the browser loads it over
              the network) or an inline copy of it (in which case no request is needed).</p>

            <p class="author1">There are a few things to be aware of with source maps:</p>

            <ul class="printings">
              <li class="calibre12">
                <p class="author1">If you are using a bundler or minifier with TypeScript, it may generate a source map
                  of its own. To get the best debugging experience, you want this to map all the way back to the
                  original TypeScript sources, not the generated JavaScript. If your bundler has built-in support for
                  TypeScript, then this should just work. If not, you may need to hunt down some flags to make it read
                  source map inputs.</p>
              </li>
              <li class="calibre12">
                <p class="author1">Be aware of whether you’re serving source maps in production. The browser won’t load
                  source maps unless the debugger is open, so there’s no performance impact for end users. But if the
                  source map contains an inline copy of your original source code, then there may be content that you
                  didn’t intend to publicize. Does the world really need to see your snarky comments or internal bug
                  tracker URLs?</p>
              </li>
            </ul>

            <p class="author1">You can also debug NodeJS programs using source maps. This is typically done via your
              editor or by connecting to your node process from a browser’s debugger. Consult the Node docs for details.
            </p>

            <p class="author1">The type checker can catch many errors before you run your code, but it is no substitute
              for a good debugger. Use source maps to get a great TypeScript debugging experience.</p>








            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-972">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">Don’t debug generated JavaScript. Use source maps to debug your TypeScript code
                      at runtime.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Make sure that your source maps are mapped all the way through to the code that
                      you run.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Depending on your settings, your source maps might contain an inline copy of your
                      original code. Don’t publish them unless you know what you’re doing!<a data-primary=""
                        data-startref="sm07" data-type="indexterm" id="calibre_link-505" class="calibre9"></a><a
                        data-primary="" data-startref="Dsourcem07" data-type="indexterm" id="calibre_link-205"
                        class="calibre9"></a><a data-primary="" data-startref="CWRdebug07" data-type="indexterm"
                        id="calibre_link-167" class="calibre9"></a></p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>







      </div>
    </section>
  </div>

  <div data-type="book" class="calibre1" id="calibre_link-13">
    <section data-pdf-bookmark="Chapter 8. Migrating to TypeScript" data-type="chapter" type="chapter" class="praise">
      <div class="praise" id="calibre_link-39">
        <h1 class="calibre14"><span class="calibre">Chapter 8. </span>Migrating to TypeScript</h1>


        <p class="author1">You’ve<a data-primary="TypeScript" data-secondary="migrating to" data-type="indexterm"
            id="calibre_link-680" class="calibre9"></a><a data-primary="JavaScript"
            data-secondary="migrating to TypeScript" data-type="indexterm" id="calibre_link-349" class="calibre9"></a><a
            data-primary="migration" data-secondary="overview of" data-type="indexterm" id="calibre_link-403"
            class="calibre9"></a> heard that TypeScript is great. You also know from painful experience that maintaining
          your 15-year-old, 100,000-line JavaScript library isn’t. If only it could become a TypeScript library!</p>

        <p class="author1">This chapter offers some advice about migrating your JavaScript project to TypeScript without
          losing your sanity and abandoning the effort.</p>

        <p class="author1">Only the smallest codebases can be migrated in one fell swoop. The key for larger projects is
          to migrate gradually. <a href="#calibre_link-14" class="calibre9">Item 60</a> discusses how to do this. For a
          long migration, it’s essential to track your progress and make sure you don’t backslide. This creates a sense
          of momentum and inevitability to the change. <a href="#calibre_link-15" class="calibre9">Item 61</a> discusses
          ways to do this.</p>

        <p class="author1">Migrating a large project to TypeScript won’t necessarily be easy, but it does offer a huge
          potential upside. A 2017 study found that 15% of bugs fixed in JavaScript projects on GitHub could have been
          prevented with TypeScript.<sup class="calibre44"><a data-type="noteref" href="#calibre_link-16"
              id="calibre_link-35" class="calibre45">1</a></sup> Even more impressive, a survey of six months’ worth of
          postmortems at AirBnb found that 38% of them could have been prevented by TypeScript.<sup class="calibre44"><a
              data-type="noteref" href="#calibre_link-17" id="calibre_link-36" class="calibre45">2</a></sup> If you’re
          advocating for TypeScript at your organization, stats like these will help! So will running some experiments
          and finding early adopters. <a href="#calibre_link-18" class="calibre9">Item 59</a> discusses how to
          experiment with TypeScript before you begin migration.</p>

        <p class="author1">Since this chapter is largely about JavaScript, many of the code samples are either pure
          JavaScript (and not expected to pass the type checker) or checked with looser settings (e.g., with <code
            class="calibre18">noImplicitAny</code> off).</p>






        <section data-pdf-bookmark="Item 58: Write Modern JavaScript" data-type="sect1" class="praise">
          <div class="praise" id="calibre_link-29">
            <h1 class="calibre16">Item 58: Write Modern JavaScript</h1>

            <p class="author1">In<a data-primary="ES2015" data-secondary="writing modern JavaScript"
                data-type="indexterm" id="calibre_link-248" class="calibre9"></a><a data-primary="migration"
                data-secondary="writing modern JavaScript" data-type="indexterm" id="calibre_link-404"
                class="calibre9"></a><a data-primary="JavaScript" data-secondary="writing modern" data-type="indexterm"
                id="calibre_link-359" class="calibre9"></a> addition to checking your code for type safety, TypeScript
              compiles your TypeScript code to any version of JavaScript code, all the way back to 1999 vintage ES3.
              Since TypeScript is a superset of the <em class="calibre3">latest</em> version of JavaScript, this means
              that you can use <code class="calibre18">tsc</code> as a “transpiler”: something that takes new JavaScript
              and converts it to older, more widely supported JavaScript.</p>

            <p class="author1">Taking a different perspective, this means that when you decide to convert an existing
              JavaScript codebase to TypeScript, there’s no downside to adopting all the latest JavaScript features. In
              fact, there’s quite a bit of upside: because TypeScript is designed to work with modern JavaScript,
              modernizing your JS is a great first step toward adopting TypeScript.</p>

            <p class="author1">And because TypeScript is a superset of JavaScript, learning to write more modern and
              idiomatic JavaScript means you’re learning to write better TypeScript, too.</p>

            <p class="author1">This item gives a quick tour of some of the features in modern JavaScript, which I’m
              defining here as everything introduced in ES2015 (aka ES6) and after. This material is covered in much
              greater detail in other books and online. If any of the topics mentioned here are unfamiliar, you owe it
              to yourself to learn more about them. TypeScript can be tremendously helpful when you’re learning a new
              language feature like <code class="calibre18">async</code>/<code class="calibre18">await</code>: it almost
              certainly understands the feature better than you do and can guide you toward correct usage.</p>

            <p class="author1">These are all worth understanding, but by far the most important for adopting TypeScript
              are ECMAScript Modules and ES2015 classes.</p>








            <section class="praise" data-pdf-bookmark="Use ECMAScript Modules" data-type="sect2">
              <div class="praise" id="calibre_link-973">
                <h2 class="calibre31">Use ECMAScript Modules</h2>

                <p class="author1">Before<a data-primary="ECMAScript" data-type="indexterm" id="calibre_link-235"
                    class="calibre9"></a><a data-primary="callbacks" data-secondary="ECMAScript modules"
                    data-type="indexterm" id="calibre_link-147" class="calibre9"></a> the 2015 version of ECMAScript
                  there was no standard way to break your code into separate modules. There were many solutions, from
                  multiple <code class="calibre18">&lt;script&gt;</code> tags, manual concatenation, and Makefiles to
                  node.js-style <code class="calibre18">require</code> statements or AMD-style <code
                    class="calibre18">define</code> callbacks. TypeScript even had its own module system (<a
                    href="#calibre_link-19" class="calibre9">Item 53</a>).</p>

                <p class="author1">Today there is one standard: ECMAScript modules, aka <code
                    class="calibre18">import</code> and <code class="calibre18">export</code>. If your JavaScript
                  codebase is still a single file, if you use concatenation or one of the other module systems, it’s
                  time to switch to ES modules. This may require setting up a tool like<a data-primary="webpack"
                    data-type="indexterm" id="calibre_link-745" class="calibre9"></a><a data-primary="ts-node"
                    data-type="indexterm" id="calibre_link-543" class="calibre9"></a> webpack or ts-node. TypeScript
                  works best with ES modules, and adopting them will facilitate your transition, not least because it
                  will allow you to migrate modules one at a time (see <a href="#calibre_link-15" class="calibre9">Item
                    61</a>).</p>

                <p class="author1">The details will vary depending on your setup, but if you’re using CommonJS like
                  this:</p>

                <pre data-code-language="js" data-type="programlisting"
                  class="calibre17"><code class="c">// CommonJS</code>
<code class="c">// a.js</code>
<code class="kd">const</code> <code class="nx">b</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s">'./b'</code><code class="p">);</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">b</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code>

<code class="c">// b.js</code>
<code class="kd">const</code> <code class="nx">name</code> <code class="o">=</code> <code class="s">'Module B'</code><code class="p">;</code>
<code class="nx">module</code><code class="p">.</code><code class="nx">exports</code> <code class="o">=</code> <code class="p">{</code><code class="nx">name</code><code class="p">};</code></pre>

                <p class="author1">then the ES module equivalent would look like:</p>

                <pre data-code-language="js" data-type="programlisting"
                  class="calibre17"><code class="c">// ECMAScript module</code>
<code class="c">// a.ts</code>
<code class="kd">import</code> <code class="o">*</code> <code class="nx">as</code> <code class="nx">b</code> <code class="nx">from</code> <code class="s">'./b'</code><code class="p">;</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">b</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code>

<code class="c">// b.ts</code>
<code class="kd">export</code> <code class="kd">const</code> <code class="nx">name</code> <code class="o">=</code> <code class="s">'Module B'</code><code class="p">;</code></pre>
              </div>
            </section>













            <section class="praise" data-pdf-bookmark="Use Classes Instead of Prototypes" data-type="sect2">
              <div class="praise" id="calibre_link-974">
                <h2 class="calibre31">Use Classes Instead of Prototypes</h2>

                <p class="author1">JavaScript<a data-primary="prototypes" data-type="indexterm" id="calibre_link-475"
                    class="calibre9"></a><a data-primary="classes" data-secondary="ES2015" data-type="indexterm"
                    id="calibre_link-153" class="calibre9"></a><a data-primary="classes, versus prototypes"
                    data-type="indexterm" id="calibre_link-160" class="calibre9"></a> has a flexible prototype-based
                  object model. But by and large JS developers have ignored this in favor of a more rigid class-based
                  model. This was officially enshrined into the language with the introduction<a data-primary="ES2015"
                    data-secondary="class keyword" data-type="indexterm" id="calibre_link-242" class="calibre9"></a> of
                  the <code class="calibre18">class</code> keyword in ES2015.</p>

                <p class="author1">If<a data-primary="Curie, Marie" data-type="indexterm" id="calibre_link-200"
                    class="calibre9"></a> your code uses prototypes in a straightforward way, switch to using classes.
                  That is, instead of:</p>

                <pre data-code-language="js" data-type="programlisting"
                  class="calibre17"><code class="kd">function</code> <code class="nx">Person</code><code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">this</code><code class="p">.</code><code class="nx">first</code> <code class="o">=</code> <code class="nx">first</code><code class="p">;</code>
  <code class="kd">this</code><code class="p">.</code><code class="nx">last</code> <code class="o">=</code> <code class="nx">last</code><code class="p">;</code>
<code class="p">}</code>

<code class="nx">Person</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">getName</code> <code class="o">=</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="kd">this</code><code class="p">.</code><code class="nx">first</code> <code class="o">+</code> <code class="s">' '</code> <code class="o">+</code> <code class="kd">this</code><code class="p">.</code><code class="nx">last</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">const</code> <code class="nx">marie</code> <code class="o">=</code> <code class="kd">new</code> <code class="nx">Person</code><code class="p">(</code><code class="s">'Marie'</code><code class="p">,</code> <code class="s">'Curie'</code><code class="p">);</code>
<code class="kd">const</code> <code class="nx">personName</code> <code class="o">=</code> <code class="nx">marie</code><code class="p">.</code><code class="nx">getName</code><code class="p">();</code></pre>

                <p class="author1">write:</p>

                <pre data-code-language="ts" data-type="programlisting"
                  class="calibre17"><code class="kd">class</code> <code class="nx">Person</code> <code class="p">{</code>
  <code class="nx">first</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">last</code>: <code class="kd">string</code><code class="p">;</code>

  <code class="kd">constructor</code><code class="p">(</code><code class="nx">first</code>: <code class="kd">string</code><code class="p">,</code> <code class="nx">last</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">this</code><code class="p">.</code><code class="nx">first</code> <code class="o">=</code> <code class="nx">first</code><code class="p">;</code>
    <code class="kd">this</code><code class="p">.</code><code class="nx">last</code> <code class="o">=</code> <code class="nx">last</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nx">getName() {</code>
    <code class="kd">return</code> <code class="kd">this</code><code class="p">.</code><code class="nx">first</code> <code class="o">+</code> <code class="s">' '</code> <code class="o">+</code> <code class="kd">this</code><code class="p">.</code><code class="nx">last</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kd">const</code> <code class="nx">marie</code> <code class="o">=</code> <code class="kd">new</code> <code class="nx">Person</code><code class="p">(</code><code class="s">'Marie'</code><code class="p">,</code> <code class="s">'Curie'</code><code class="p">);</code>
<code class="kd">const</code> <code class="nx">personName</code> <code class="o">=</code> <code class="nx">marie</code><code class="p">.</code><code class="nx">getName</code><code class="p">();</code></pre>

                <p class="author1">TypeScript struggles with the prototype version of <code
                    class="calibre18">Person</code> but understands the class-based version with minimal annotations. If
                  you’re unfamiliar with the syntax, TypeScript will help you get it right.</p>

                <p class="author1">For<a data-primary="ES2015" data-secondary="Convert function" data-type="indexterm"
                    id="calibre_link-243" class="calibre9"></a> code that uses older-style classes, the TypeScript
                  language service offers a “Convert function to an ES2015 class” quick fix that can speed this up (<a
                    data-type="xref" href="#calibre_link-20" class="calibre9">Figure&nbsp;8-1</a>).</p>

                <figure class="width">
                  <div class="figure" id="calibre_link-20">
                    <img alt="efts 08in01" src="images/000012.png" class="calibre50" />
                    <h6 class="calibre30"><span class="calibre">Figure 8-1. </span>The TypeScript language service
                      offers a quick fix to convert older-style classes to ES2015 classes.</h6>
                  </div>
                </figure>
              </div>
            </section>













            <section class="praise" data-pdf-bookmark="Use let/const Instead of var" data-type="sect2">
              <div class="praise" id="calibre_link-975">
                <h2 class="calibre31">Use let/const Instead of var</h2>

                <p class="author1">JavaScript’s<a data-primary="var" data-type="indexterm" id="calibre_link-735"
                    class="calibre9"></a><a data-primary="let/const" data-type="indexterm" id="calibre_link-380"
                    class="calibre9"></a> <code class="calibre18">var</code> has some famously quirky scoping rules. If
                  you’re curious to learn more about them, read <em class="calibre3">Effective JavaScript</em>. But
                  better to avoid <code class="calibre18">var</code> and not worry! Instead, use <code
                    class="calibre18">let</code> and <code class="calibre18">const</code>. They’re truly block-scoped
                  and work in much more intuitive ways than <code class="calibre18">var</code>.</p>

                <p class="author1">Again, TypeScript will help you here. If changing <code class="calibre18">var</code>
                  to <code class="calibre18">let</code> results in an error, then you’re almost certainly doing
                  something you shouldn’t be.</p>

                <p class="author1">Nested function statements also have <code class="calibre18">var</code>-like scoping
                  rules:</p>

                <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">foo() {</code>
  <code class="nx">bar</code><code class="p">();</code>
  <code class="kd">function</code> <code class="nx">bar() {</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s">'hello'</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

                <p class="author1">When you call <code class="calibre18">foo()</code>, it logs <code
                    class="calibre18">hello</code> because the definition of <code class="calibre18">bar</code> is
                  hoisted to the top of <code class="calibre18">foo</code>. This is surprising! Prefer function
                  expressions (<code class="calibre18">const bar = () =&gt; { ... }</code>) instead.</p>
              </div>
            </section>













            <section class="praise" data-pdf-bookmark="Use for-of or Array Methods Instead of for(;;)"
              data-type="sect2">
              <div class="praise" id="calibre_link-976">
                <h2 class="calibre31">Use for-of or Array Methods Instead of for(;;)</h2>

                <p class="author1">In<a data-primary="for-of" data-type="indexterm" id="calibre_link-274"
                    class="calibre9"></a><a data-primary="for(;;)" data-type="indexterm" id="calibre_link-270"
                    class="calibre9"></a><a data-primary="array methods" data-type="indexterm" id="calibre_link-106"
                    class="calibre9"></a> classic JavaScript you used a C-style for loop to iterate over an array:</p>

                <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">for</code> <code class="p">(</code><code class="kd">var</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">array</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">el</code> <code class="o">=</code> <code class="nx">array</code><code class="p">[</code><code class="nx">i</code><code class="p">];</code>
  <code class="c">// ...</code>
<code class="p">}</code></pre>

                <p class="author1">In modern JavaScript you can use a for-of loop instead:</p>

                <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="nx">el</code> <code class="nx">of</code> <code class="nx">array</code><code class="p">)</code> <code class="p">{</code>
  <code class="c">// ...</code>
<code class="p">}</code></pre>

                <p class="author1">This is less prone to typos and doesn’t introduce an index variable. If you want the
                  index variable, you can use <code class="calibre18">forEach</code>:</p>

                <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="nx">array</code><code class="p">.</code><code class="nx">forEach</code><code class="p">((</code><code class="nx">el</code><code class="p">,</code> <code class="nx">i</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="c">// ...</code>
<code class="p">});</code></pre>

                <p class="author1">Avoid using the for-in construct to iterate over arrays as it has many surprises (see
                  <a href="#calibre_link-21" class="calibre9">Item 16</a>).
                </p>
              </div>
            </section>













            <section class="praise" data-pdf-bookmark="Prefer Arrow Functions Over Function Expressions"
              data-type="sect2">
              <div class="praise" id="calibre_link-977">
                <h2 class="calibre31">Prefer Arrow Functions Over Function Expressions</h2>

                <p class="author1">The<a data-primary="arrow functions" data-type="indexterm" id="calibre_link-111"
                    class="calibre9"></a><a data-primary="functions" data-secondary="arrow functions"
                    data-type="indexterm" id="calibre_link-279" class="calibre9"></a><a
                    data-primary="function expressions" data-type="indexterm" id="calibre_link-275"
                    class="calibre9"></a><a data-primary="this keyword" data-type="indexterm" id="calibre_link-538"
                    class="calibre9"></a><a data-primary="JavaScript" data-secondary="this keyword"
                    data-type="indexterm" id="calibre_link-358" class="calibre9"></a> <code
                    class="calibre18">this</code> keyword is one of the most famously confusing aspects of JavaScript
                  because it has different scoping rules than other variables:</p>

                <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">class</code> <code class="nx">Foo</code> <code class="p">{</code>
  <code class="nx">method() {</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="kd">this</code><code class="p">);</code>
    <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">].</code><code class="nx">forEach</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">i</code><code class="p">)</code> <code class="p">{</code>
      <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="kd">this</code><code class="p">);</code>
    <code class="p">});</code>
  <code class="p">}</code>
<code class="p">}</code>
<code class="kd">const</code> <code class="nx">f</code> <code class="o">=</code> <code class="kd">new</code> <code class="nx">Foo</code><code class="p">();</code>
<code class="nx">f</code><code class="p">.</code><code class="nx">method</code><code class="p">();</code>
<code class="c">// Prints Foo, undefined, undefined in strict mode</code>
<code class="c">// Prints Foo, window, window (!) in non-strict mode</code></pre>

                <p class="author1">Generally you want <code class="calibre18">this</code> to refer to the relevant
                  instance of whichever class you’re in. Arrow functions help you do that by keeping the <code
                    class="calibre18">this</code> value from their enclosing scope:</p>

                <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">class</code> <code class="nx">Foo</code> <code class="p">{</code>
  <code class="nx">method() {</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="kd">this</code><code class="p">);</code>
    <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">].</code><code class="nx">forEach</code><code class="p">(</code><code class="nx">i</code> <code class="o">=&gt;</code> <code class="p">{</code>
      <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="kd">this</code><code class="p">);</code>
    <code class="p">});</code>
  <code class="p">}</code>
<code class="p">}</code>
<code class="kd">const</code> <code class="nx">f</code> <code class="o">=</code> <code class="kd">new</code> <code class="nx">Foo</code><code class="p">();</code>
<code class="nx">f</code><code class="p">.</code><code class="nx">method</code><code class="p">();</code>
<code class="c">// Always prints Foo, Foo, Foo</code></pre>

                <p class="author1">In addition to having simpler semantics, arrow functions are more concise. You should
                  use them whenever possible. For more on <code class="calibre18">this</code> binding, see <a
                    href="#calibre_link-12" class="calibre9">Item 49</a>. With<a data-primary="noImplicitThis"
                    data-type="indexterm" id="calibre_link-424" class="calibre9"></a> the <code
                    class="calibre18">noImplicitThis</code> (or <code class="calibre18">strict</code>) compiler<a
                    data-primary="compiling" data-secondary="compiler options" data-type="indexterm"
                    id="calibre_link-176" class="calibre9"></a> option, TypeScript will help you get your <code
                    class="calibre18">this</code>-binding right.</p>
              </div>
            </section>













            <section class="praise" data-pdf-bookmark="Use Compact Object Literals and Destructuring Assignment"
              data-type="sect2">
              <div class="praise" id="calibre_link-978">
                <h2 class="calibre31">Use Compact Object Literals and Destructuring Assignment</h2>

                <p class="author1">Instead<a data-primary="destructuring assignment" data-type="indexterm"
                    id="calibre_link-213" class="calibre9"></a><a data-primary="compact object literals"
                    data-type="indexterm" id="calibre_link-174" class="calibre9"></a><a data-primary="objects"
                    data-secondary="compact object literals" data-type="indexterm" id="calibre_link-446"
                    class="calibre9"></a> of writing:</p>

                <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">x</code> <code class="o">=</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">y</code> <code class="o">=</code> <code class="mi">2</code><code class="p">,</code> <code class="nx">z</code> <code class="o">=</code> <code class="mi">3</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">pt</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">x</code>: <code class="nx">x</code><code class="p">,</code>
  <code class="nx">y</code>: <code class="nx">y</code><code class="p">,</code>
  <code class="nx">z</code>: <code class="nx">z</code>
<code class="p">};</code></pre>

                <p class="author1">you can simply write:</p>

                <pre data-code-language="ts" data-type="programlisting"
                  class="calibre17"><code class="kd">const</code> <code class="nx">x</code> <code class="o">=</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">y</code> <code class="o">=</code> <code class="mi">2</code><code class="p">,</code> <code class="nx">z</code> <code class="o">=</code> <code class="mi">3</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">pt</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">,</code> <code class="nx">z</code> <code class="p">};</code></pre>

                <p class="author1">In addition to being more concise, this encourages consistent naming of variables and
                  properties, something your human readers will appreciate as well (<a href="#calibre_link-22"
                    class="calibre9">Item 36</a>).</p>

                <p class="author1">To return an object literal from an arrow function, wrap it in parentheses:</p>

                <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="p">[</code><code class="s">'A'</code><code class="p">,</code> <code class="s">'B'</code><code class="p">,</code> <code class="s">'C'</code><code class="p">].</code><code class="nx">map</code><code class="p">((</code><code class="kd">char</code><code class="p">,</code> <code class="nx">idx</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">({</code><code class="kd">char</code><code class="p">,</code> <code class="nx">idx</code><code class="p">}));</code>
<code class="c">// [ { char: 'A', idx: 0 },  { char: 'B', idx: 1 }, { char: 'C', idx: 2 } ]</code></pre>

                <p class="author1">There is also shorthand for properties whose values are functions:</p>

                <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">obj</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">onClickLong</code>: <code class="nx">function</code><code class="p">(</code><code class="nx">e</code><code class="p">)</code> <code class="p">{</code>
    <code class="c">// ...</code>
  <code class="p">},</code>
  <code class="nx">onClickCompact</code><code class="p">(</code><code class="nx">e</code><code class="p">)</code> <code class="p">{</code>
    <code class="c">// ...</code>
  <code class="p">}</code>
<code class="p">};</code></pre>

                <p class="author1">The inverse of compact object literals is object destructuring. Instead of writing:
                </p>

                <pre data-code-language="ts" data-type="programlisting"
                  class="calibre17"><code class="kd">const</code> <code class="nx">props</code> <code class="o">=</code> <code class="nx">obj</code><code class="p">.</code><code class="nx">props</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">a</code> <code class="o">=</code> <code class="nx">props</code><code class="p">.</code><code class="nx">a</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">b</code> <code class="o">=</code> <code class="nx">props</code><code class="p">.</code><code class="nx">b</code><code class="p">;</code></pre>

                <p class="author1">you can write:</p>

                <pre data-code-language="ts" data-type="programlisting"
                  class="calibre17"><code class="kd">const</code> <code class="p">{</code><code class="nx">props</code><code class="p">}</code> <code class="o">=</code> <code class="nx">obj</code><code class="p">;</code>
<code class="kd">const</code> <code class="p">{</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">}</code> <code class="o">=</code> <code class="nx">props</code><code class="p">;</code></pre>

                <p class="author1">or even:</p>

                <pre data-code-language="ts" data-type="programlisting"
                  class="calibre17"><code class="kd">const</code> <code class="p">{</code><code class="nx">props</code><code class="o">:</code> <code class="p">{</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">}}</code> <code class="o">=</code> <code class="nx">obj</code><code class="p">;</code></pre>

                <p class="author1">In this last example only <code class="calibre18">a</code> and <code
                    class="calibre18">b</code> become variables, not <code class="calibre18">props</code>.</p>

                <p class="author1">You may specify default values when destructuring. Instead of writing:</p>

                <pre data-code-language="ts" data-type="programlisting"
                  class="calibre17"><code class="kd">let</code> <code class="p">{</code><code class="nx">a</code><code class="p">}</code> <code class="o">=</code> <code class="nx">obj</code><code class="p">.</code><code class="nx">props</code><code class="p">;</code>
<code class="kd">if</code> <code class="p">(</code><code class="nx">a</code> <code class="o">===</code> <code class="kd">undefined</code><code class="p">)</code> <code class="nx">a</code> <code class="o">=</code> <code class="s">'default'</code><code class="p">;</code></pre>

                <p class="author1">write this:</p>

                <pre data-code-language="ts" data-type="programlisting"
                  class="calibre17"><code class="kd">const</code> <code class="p">{</code><code class="nx">a</code> <code class="o">=</code> <code class="s">'default'</code><code class="p">}</code> <code class="o">=</code> <code class="nx">obj</code><code class="p">.</code><code class="nx">props</code><code class="p">;</code></pre>

                <p class="author1">You can also destructure arrays. This is particularly useful with tuple types:</p>

                <pre data-code-language="ts" data-type="programlisting"
                  class="calibre17"><code class="kd">const</code> <code class="nx">point</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">];</code>
<code class="kd">const</code> <code class="p">[</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">,</code> <code class="nx">z</code><code class="p">]</code> <code class="o">=</code> <code class="nx">point</code><code class="p">;</code>
<code class="kd">const</code> <code class="p">[,</code> <code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">]</code> <code class="o">=</code> <code class="nx">point</code><code class="p">;</code>  <code class="c">// Ignore the first one</code></pre>

                <p class="author1">Destructuring can also be used in function parameters:</p>

                <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">points</code> <code class="o">=</code> <code class="p">[</code>
  <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">],</code>
  <code class="p">[</code><code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">6</code><code class="p">],</code>
<code class="p">];</code>
<code class="nx">points</code><code class="p">.</code><code class="nx">forEach</code><code class="p">(([</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">,</code> <code class="nx">z</code><code class="p">])</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">x</code> <code class="o">+</code> <code class="nx">y</code> <code class="o">+</code> <code class="nx">z</code><code class="p">));</code>
<code class="c">// Logs 6, 15</code></pre>

                <p class="author1">As with compact object literal syntax, destructuring is concise and encourages
                  consistent variable naming. Use it!</p>
              </div>
            </section>













            <section class="praise" data-pdf-bookmark="Use Default Function Parameters" data-type="sect2">
              <div class="praise" id="calibre_link-979">
                <h2 class="calibre31">Use Default Function Parameters</h2>

                <p class="author1">In<a data-primary="functions" data-secondary="default function parameters"
                    data-type="indexterm" id="calibre_link-282" class="calibre9"></a> JavaScript, all function
                  parameters are optional:</p>

                <pre data-code-language="js" data-type="programlisting" id="calibre_link-980" class="calibre17"><code class="kd">function</code> <code class="nx">log2</code><code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">);</code>
<code class="p">}</code>
<code class="nx">log2</code><code class="p">();</code></pre>

                <p class="author1">This outputs:</p>

                <pre data-type="programlisting" id="calibre_link-981" class="calibre17">undefined undefined</pre>

                <p class="author1">This is often used to implement default values for parameters:</p>

                <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">parseNum</code><code class="p">(</code><code class="nx">str</code><code class="p">,</code> <code class="nx">base</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">base</code> <code class="o">=</code> <code class="nx">base</code> <code class="o">||</code> <code class="mi">10</code><code class="p">;</code>
  <code class="kd">return</code> <code class="nb">parseInt</code><code class="p">(</code><code class="nx">str</code><code class="p">,</code> <code class="nx">base</code><code class="p">);</code>
<code class="p">}</code></pre>

                <p class="author1">In modern JavaScript, you can specify the default value directly in the parameter
                  list:</p>

                <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">parseNum</code><code class="p">(</code><code class="nx">str</code><code class="p">,</code> <code class="nx">base</code><code class="o">=</code><code class="mi">10</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nb">parseInt</code><code class="p">(</code><code class="nx">str</code><code class="p">,</code> <code class="nx">base</code><code class="p">);</code>
<code class="p">}</code></pre>

                <p class="author1">In addition to being more concise, this makes it clear that <code
                    class="calibre18">base</code> is an optional parameter. Default parameters have another benefit when
                  you migrate to TypeScript: they help the type checker infer the type of the parameter, removing the
                  need for a type annotation. See <a href="#calibre_link-11" class="calibre9">Item 19</a>.</p>
              </div>
            </section>













            <section class="praise" data-pdf-bookmark="Use async/await Instead of Raw Promises or Callbacks"
              data-type="sect2">
              <div class="praise" id="calibre_link-982">
                <h2 class="calibre31">Use async/await Instead of Raw Promises or Callbacks</h2>

                <p class="author1"><a href="#calibre_link-23" class="calibre9">Item 25</a> explains<a
                    data-primary="async/await" data-type="indexterm" id="calibre_link-121" class="calibre9"></a><a
                    data-primary="Promises" data-type="indexterm" id="calibre_link-465" class="calibre9"></a><a
                    data-primary="callbacks" data-secondary="versus async/await" data-secondary-sortas="async/await"
                    data-type="indexterm" id="calibre_link-146" class="calibre9"></a><a data-primary="await keyword"
                    data-type="indexterm" id="calibre_link-128" class="calibre9"></a> why <code
                    class="calibre18">async</code> and <code class="calibre18">await</code> are preferable, but the gist
                  is that they’ll simplify your code, prevent bugs, and help types flow through your asynchronous code.
                </p>

                <p class="author1">Instead of either of these:</p>

                <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">getJSON</code><code class="p">(</code><code class="nx">url</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">url</code><code class="p">).</code><code class="nx">then</code><code class="p">(</code><code class="nx">response</code> <code class="o">=&gt;</code> <code class="nx">response</code><code class="p">.</code><code class="nx">json</code><code class="p">());</code>
<code class="p">}</code>
<code class="kd">function</code> <code class="nx">getJSONCallback</code><code class="p">(</code><code class="nx">url</code>: <code class="kd">string</code><code class="p">,</code> <code class="nx">cb</code><code class="o">:</code> <code class="p">(</code><code class="nx">result</code>: <code class="nx">unknown</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kd">void</code><code class="p">)</code> <code class="p">{</code>
  <code class="c">// ...</code>
<code class="p">}</code></pre>

                <p class="author1">write this:</p>

                <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">async</code> <code class="kd">function</code> <code class="nx">getJSON</code><code class="p">(</code><code class="nx">url</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">response</code> <code class="o">=</code> <code class="kd">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">url</code><code class="p">);</code>
  <code class="kd">return</code> <code class="nx">response</code><code class="p">.</code><code class="nx">json</code><code class="p">();</code>
<code class="p">}</code></pre>
              </div>
            </section>













            <section class="praise" data-pdf-bookmark="Don’t Put use strict in TypeScript" data-type="sect2">
              <div class="praise" id="calibre_link-983">
                <h2 class="calibre31">Don’t Put use strict in TypeScript</h2>

                <p class="author1">ES5<a data-primary="ES5" data-secondary="strict mode" data-type="indexterm"
                    id="calibre_link-255" class="calibre9"></a><a data-primary="use strict" data-type="indexterm"
                    id="calibre_link-719" class="calibre9"></a><a data-primary="strict mode" data-type="indexterm"
                    id="calibre_link-507" class="calibre9"></a> introduced “strict mode” to make some suspect patterns
                  more explicit errors. You enable it by putting <code class="calibre18">'use strict'</code> in your
                  code:</p>

                <pre data-code-language="js" data-type="programlisting" class="calibre17"><code class="s">'use strict'</code><code class="p">;</code>
<code class="kd">function</code> <code class="nx">foo</code><code class="p">()</code> <code class="p">{</code>
  <code class="nx">x</code> <code class="o">=</code> <code class="mi">10</code><code class="p">;</code>  <code class="c">// Throws in strict mode, defines a global in non-strict.</code>
<code class="p">}</code></pre>

                <p class="author1">If you’ve never used strict mode in your JavaScript codebase, then give it a try. The
                  errors it finds are likely to be ones that the TypeScript compiler will find, too.</p>

                <p class="author1">But as you transition to TypeScript, there’s not much value in keeping <code
                    class="calibre18">'use strict'</code> in your source code. By and large, the sanity checks that
                  TypeScript provides are far stricter than those offered by strict mode.</p>

                <p class="author1">There<a data-primary="compiling" data-secondary="compiler options"
                    data-type="indexterm" id="calibre_link-177" class="calibre9"></a> is some value in having a <code
                    class="calibre18">'use strict'</code> in the JavaScript that <code class="calibre18">tsc</code>
                  emits. If you set the <code class="calibre18">alwaysStrict</code> or <code
                    class="calibre18">strict</code> compiler options, TypeScript will parse your code in strict mode and
                  put a <code class="calibre18">'use strict'</code> in the JavaScript output for you.</p>

                <p class="author1">In short, don’t write <code class="calibre18">'use strict'</code> in your TypeScript.
                  Use <code class="calibre18">alwaysStrict</code> instead.</p>

                <p class="author1">These are just a few of the many new JavaScript features that TypeScript lets you
                  use. TC39, the body that governs JS standards, is very active, and new features are added year to
                  year. The TypeScript team is currently committed to implementing any feature that reaches stage 3 (out
                  of 4) in the standardization process, so you don’t even have to wait for the ink to dry. Check out the
                  TC39 GitHub repo<sup class="calibre44"><a data-type="noteref" href="#calibre_link-24"
                      id="calibre_link-37" class="calibre45">3</a></sup> for the latest. As of this writing, the
                  pipeline and decorators proposals in particular have great potential to impact TypeScript.</p>
              </div>
            </section>













            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-984">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">TypeScript lets you write modern JavaScript whatever your runtime environment.
                      Take advantage of this by using the language features it enables. In addition to improving your
                      codebase, this will help TypeScript understand your code.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Use TypeScript to learn language features like classes, destructuring, and <code
                        class="calibre18">async</code>/<code class="calibre18">await</code>.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Don’t bother with <code class="calibre18">'use strict'</code>: TypeScript is
                      stricter.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Check<a data-primary="TC39" data-type="indexterm" id="calibre_link-532"
                        class="calibre9"></a><a data-primary="TypeScript" data-secondary="release notes"
                        data-type="indexterm" id="calibre_link-686" class="calibre9"></a> the TC39 GitHub repo and
                      TypeScript release notes to learn about all the latest language features.<a data-primary=""
                        data-startref="Mmodern08" data-type="indexterm" id="calibre_link-405" class="calibre9"></a><a
                        data-primary="" data-startref="JSmodern08" data-type="indexterm" id="calibre_link-360"
                        class="calibre9"></a></p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>













        <section data-pdf-bookmark="Item 59: Use @ts-check and JSDoc to Experiment with TypeScript" data-type="sect1"
          class="praise">
          <div class="praise" id="calibre_link-18">
            <h1 class="calibre16">Item 59: Use @ts-check and JSDoc to Experiment with TypeScript</h1>

            <p class="author1">Before<a data-primary="migration" data-secondary="experimenting with TypeScript"
                data-type="indexterm" id="calibre_link-399" class="calibre9"></a><a data-primary="@ts-check"
                data-type="indexterm" id="calibre_link-66" class="calibre9"></a><a data-primary="JSDoc-style comments"
                data-type="indexterm" id="calibre_link-366" class="calibre9"></a><a data-primary="TypeScript"
                data-secondary="experimenting with" data-type="indexterm" id="calibre_link-675" class="calibre9"></a>
              you begin the process of converting your source files from JavaScript to TypeScript (<a
                href="#calibre_link-14" class="calibre9">Item 60</a>), you may want to experiment with type checking to
              get an initial read on the sorts of issues that will come up. TypeScript’s <code
                class="calibre18">@ts-check</code> directive lets you do exactly this. It directs the type checker to
              analyze a single file and report whatever issues it finds. You can think of it as an extremely loose
              version of type checking: looser even than TypeScript with <code class="calibre18">noImplicitAny</code>
              off (<a href="#calibre_link-25" class="calibre9">Item 2</a>).<a data-primary="Hopper, Grace"
                data-type="indexterm" id="calibre_link-305" class="calibre9"></a></p>

            <p class="author1">Here’s how it works:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="c">// @ts-check</code>
<code class="kd">const</code> <code class="nx">person</code> <code class="o">=</code> <code class="p">{</code><code class="nx">first</code><code class="o">:</code> <code class="s">'Grace'</code><code class="p">,</code> <code class="nx">last</code><code class="o">:</code> <code class="s">'Hopper'</code><code class="p">};</code>
<code class="mi">2</code> <code class="o">*</code> <code class="nx">person</code><code class="p">.</code><code class="nx">first</code>
 <code class="c">// ~~~~~~~~~~~~ The right-hand side of an arithmetic operation must be of type</code>
 <code class="c">//              'any', 'number', 'bigint', or an enum type</code></pre>

            <p class="author1">TypeScript infers the type of <code class="calibre18">person.first</code> as <code
                class="calibre18">string</code>, so <code class="calibre18">2 * person.first</code> is a type error, no
              type annotations required.</p>

            <p class="author1">While it may surface this sort of blatant type error, or functions called with too many
              arguments, in practice, <code class="calibre18">// @ts-check</code> tends to turn up a few specific types
              of errors:</p>








            <section class="praise" data-pdf-bookmark="Undeclared Globals" data-type="sect2">
              <div class="praise" id="calibre_link-985">
                <h2 class="calibre31">Undeclared Globals</h2>

                <p class="author1">If<a data-primary="global variables" data-type="indexterm" id="calibre_link-302"
                    class="calibre9"></a><a data-primary="undeclared globals" data-type="indexterm"
                    id="calibre_link-701" class="calibre9"></a> these are symbols that you’re defining, then declare
                  them with <code class="calibre18">let</code> or <code class="calibre18">const</code>. If they are
                  “ambient” symbols that are defined elsewhere (in a <code class="calibre18">&lt;script&gt;</code> tag
                  in an HTML file, for instance), then you can create a type declarations file to describe them.</p>

                <p class="author1">For example, if you have JavaScript like this:</p>

                <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="c">// @ts-check</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">user</code><code class="p">.</code><code class="nx">firstName</code><code class="p">);</code>
         <code class="c">// ~~~~ Cannot find name 'user'</code></pre>

                <p class="author1">then you could create a file called <em class="calibre3">types.d.ts</em>:</p>

                <pre data-code-language="ts" data-type="programlisting"
                  class="calibre17"><code class="kd">interface</code> <code class="nx">UserData</code> <code class="p">{</code>
  <code class="nx">firstName</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">lastName</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">declare</code> <code class="kd">let</code> <code class="nx">user</code>: <code class="nx">UserData</code><code class="p">;</code></pre>

                <p class="author1">Creating this file on its own may fix the issue. If it does not, you may need to
                  explicitly import it with a “triple-slash” reference:</p>

                <pre data-code-language="ts" data-type="programlisting"
                  class="calibre17"><code class="c">// @ts-check</code>
<code class="c">/// &lt;reference path="./types.d.ts" /&gt;</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">user</code><code class="p">.</code><code class="nx">firstName</code><code class="p">);</code>  <code class="c">// OK</code></pre>

                <p class="author1">This <em class="calibre3">types.d.ts</em> file is a valuable artifact that will
                  become the basis for your project’s type declarations.</p>
              </div>
            </section>













            <section class="praise" data-pdf-bookmark="Unknown Libraries" data-type="sect2">
              <div class="praise" id="calibre_link-986">
                <h2 class="calibre31">Unknown Libraries</h2>

                <p class="author1">If<a data-primary="libraries" data-secondary="unknown third-party"
                    data-type="indexterm" id="calibre_link-382" class="calibre9"></a><a data-primary="unknown libraries"
                    data-type="indexterm" id="calibre_link-714" class="calibre9"></a> you’re using a third-party
                  library, TypeScript needs to know about it. For example, you might use jQuery to set the size of an
                  HTML element. With <code class="calibre18">@ts-check</code>, TypeScript will flag an error:</p>

                <pre data-code-language="js" data-type="programlisting" class="calibre17"><code class="c">// @ts-check</code>
   <code class="nx">$</code><code class="p">(</code><code class="s">'#graph'</code><code class="p">).</code><code class="nx">style</code><code class="p">({</code><code class="s">'width'</code><code class="o">:</code> <code class="s">'100px'</code><code class="p">,</code> <code class="s">'height'</code><code class="o">:</code> <code class="s">'100px'</code><code class="p">});</code>
<code class="c">// ~ Cannot find name '$'</code></pre>

                <p class="author1">The<a data-primary="jQuery" data-secondary="type declarations for"
                    data-type="indexterm" id="calibre_link-363" class="calibre9"></a> solution is to install the type
                  declarations for jQuery:</p>
                <pre data-type="programlisting"
                  class="calibre17">$ <strong class="calibre32">npm install --save-dev @types/jquery</strong></pre>

                <p class="author1">Now the error is specific to jQuery:</p>

                <pre data-code-language="js" data-type="programlisting" class="calibre17"><code class="c">// @ts-check</code>
<code class="nx">$</code><code class="p">(</code><code class="s">'#graph'</code><code class="p">).</code><code class="nx">style</code><code class="p">({</code><code class="s">'width'</code><code class="o">:</code> <code class="s">'100px'</code><code class="p">,</code> <code class="s">'height'</code><code class="o">:</code> <code class="s">'100px'</code><code class="p">});</code>
         <code class="c">// ~~~~~ Property 'style' does not exist on type 'JQuery&lt;HTMLElement&gt;'</code></pre>

                <p class="author1">In fact, it should be <code class="calibre18">.css</code>, not <code
                    class="calibre18">.style</code>.</p>

                <p class="author1"><code class="calibre18">@ts-check</code> lets you take advantage of the TypeScript
                  declarations for popular JavaScript libraries without migrating to TypeScript yourself. This is one of
                  the best reasons to use it.</p>
              </div>
            </section>













            <section class="praise" data-pdf-bookmark="DOM Issues" data-type="sect2">
              <div class="praise" id="calibre_link-987">
                <h2 class="calibre31">DOM Issues</h2>

                <p class="author1">Assuming<a data-primary="DOM hierarchy" data-type="indexterm" id="calibre_link-218"
                    class="calibre9"></a> you’re writing code that runs in a web browser, TypeScript is likely to flag
                  issues around your handling of DOM elements. For example:</p>

                <pre data-code-language="js" data-type="programlisting" class="calibre17"><code class="c">// @ts-check</code>
<code class="kd">const</code> <code class="nx">ageEl</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s">'age'</code><code class="p">);</code>
<code class="nx">ageEl</code><code class="p">.</code><code class="nx">value</code> <code class="o">=</code> <code class="s">'12'</code><code class="p">;</code>
   <code class="c">// ~~~~~ Property 'value' does not exist on type 'HTMLElement'</code></pre>

                <p class="author1">The issue is that only <code class="calibre18">HTMLInputElement</code>s have a <code
                    class="calibre18">value</code> property, but <code class="calibre18">document.getElementById</code>
                  returns the more generic <code class="calibre18">HTMLElement</code> (see <a href="#calibre_link-26"
                    class="calibre9">Item 55</a>). If you know that the <code class="calibre18">#age</code> element
                  really is an <code class="calibre18">input</code> element, then this is an appropriate time to use a
                  type assertion (<a href="#calibre_link-27" class="calibre9">Item 9</a>). But this is still a JS file,
                  so you can’t write <code class="calibre18">as HTMLInputElement</code>. Instead, you can assert a type
                  using JSDoc:</p>

                <pre data-code-language="js" data-type="programlisting"
                  class="calibre17"><code class="c">// @ts-check</code>
<code class="kd">const</code> <code class="nx">ageEl</code> <code class="o">=</code> <code class="c">/** @type {HTMLInputElement} */</code><code class="p">(</code><code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s">'age'</code><code class="p">));</code>
<code class="nx">ageEl</code><code class="p">.</code><code class="nx">value</code> <code class="o">=</code> <code class="s">'12'</code><code class="p">;</code>  <code class="c">// OK</code></pre>

                <p class="author1">If you mouse over <code class="calibre18">ageEl</code> in your editor, you’ll see
                  that TypeScript now considers it an <code class="calibre18">HTMLInputElement</code>. Take care as you
                  type the JSDoc <code class="calibre18">@type</code> annotation: the parentheses after the comment are
                  required.</p>

                <p class="author1">This leads to another type of error that comes up with <code
                    class="calibre18">@ts-check</code>, inaccurate JSDoc, as explained next.</p>
              </div>
            </section>













            <section class="praise" data-pdf-bookmark="Inaccurate JSDoc" data-type="sect2">
              <div class="praise" id="calibre_link-988">
                <h2 class="calibre31">Inaccurate JSDoc</h2>

                <p class="author1">If your project already has JSDoc-style comments, TypeScript will begin checking them
                  when you flip on <code class="calibre18">@ts-check</code>. If you previously used a system like the<a
                    data-primary="Closure Compiler" data-type="indexterm" id="calibre_link-161" class="calibre9"></a>
                  Closure Compiler that used these comments to enforce type safety, then this shouldn’t cause major
                  headaches. But you may be in for some surprises if your comments were more like “aspirational JSDoc”:
                </p>

                <pre data-code-language="js" data-type="programlisting" class="calibre17"><code class="c">// @ts-check</code>
<code class="c">/**</code>
<code class="c"> * Gets the size (in pixels) of an element.</code>
<code class="c"> * @param {Node} el The element</code>
<code class="c"> * @return {{w: number, h: number}} The size</code>
<code class="c"> */</code>
<code class="kd">function</code> <code class="nx">getSize</code><code class="p">(</code><code class="nx">el</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">bounds</code> <code class="o">=</code> <code class="nx">el</code><code class="p">.</code><code class="nx">getBoundingClientRect</code><code class="p">();</code>
                 <code class="c">// ~~~~~~~~~~~~~~~~~~~~~ Property 'getBoundingClientRect'</code>
                 <code class="c">//                       does not exist on type 'Node'</code>
  <code class="kd">return</code> <code class="p">{</code><code class="nx">width</code><code class="o">:</code> <code class="nx">bounds</code><code class="p">.</code><code class="nx">width</code><code class="p">,</code> <code class="nx">height</code><code class="o">:</code> <code class="nx">bounds</code><code class="p">.</code><code class="nx">height</code><code class="p">};</code>
       <code class="c">// ~~~~~~~~~~~~~~~~~~~ Type '{ width: any; height: any; }' is not</code>
       <code class="c">//                     assignable to type '{ w: number; h: number; }'</code>
<code class="p">}</code></pre>

                <p class="author1">The first issue is a misunderstanding of the DOM: <code
                    class="calibre18">getBoundingClientRect()</code> is defined on <code
                    class="calibre18">Element</code>, not <code class="calibre18">Node</code>. So the <code
                    class="calibre18">@param</code> tag should be updated. The second is a mismatch between proprties
                  specified in the <code class="calibre18">@return</code> tag and the implementation. Presumably the
                  rest of the project uses the <code class="calibre18">width</code> and <code
                    class="calibre18">height</code> properties, so the <code class="calibre18">@return</code> tag should
                  be updated.</p>

                <p class="author1">You can use JSDoc to gradually add type annotations to your project. The TypeScript
                  language service will offer to infer type annotations as a quick fix for code where it’s clear from
                  usage, as shown here and in <a data-type="xref" href="#calibre_link-28"
                    class="calibre9">Figure&nbsp;8-2</a>:</p>

                <pre data-code-language="js" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="kd">double</code><code class="p">(</code><code class="nx">val</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="mi">2</code> <code class="o">*</code> <code class="nx">val</code><code class="p">;</code>
<code class="p">}</code></pre>

                <figure class="calibre28">
                  <div class="figure" id="calibre_link-28">
                    <img alt="efts 08in02" src="images/000033.png" class="calibre29" />
                    <h6 class="calibre30"><span class="calibre">Figure 8-2. </span>The TypeScript Language Services
                      offer a quick fix to infer paramter types from usage.</h6>
                  </div>
                </figure>

                <p class="author1">This results in a correct JSDoc annotation:</p>

                <pre data-code-language="js" data-type="programlisting" class="calibre17"><code class="c">// @ts-check</code>
<code class="c">/**</code>
<code class="c"> * @param {number} val</code>
<code class="c"> */</code>
<code class="kd">function</code> <code class="kd">double</code><code class="p">(</code><code class="nx">val</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="mi">2</code> <code class="o">*</code> <code class="nx">val</code><code class="p">;</code>
<code class="p">}</code></pre>

                <p class="author1">This can be helpful to encourage types to flow through your code with <code
                    class="calibre18">@ts-check</code>. But it doesn’t always work so well. For instance:</p>

                <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">loadData</code><code class="p">(</code><code class="nx">data</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">data</code><code class="p">.</code><code class="nx">files</code><code class="p">.</code><code class="nx">forEach</code><code class="p">(</code><code class="kd">async</code> <code class="nx">file</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="c">// ...</code>
  <code class="p">});</code>
<code class="p">}</code></pre>

                <p class="author1">If you use the quick fix to annotate <code class="calibre18">data</code>, you’ll wind
                  up with:</p>

                <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="c">/**</code>
<code class="c"> * @param {{</code>
<code class="c"> *  files: { forEach: (arg0: (file: any) =&gt; Promise&lt;void&gt;) =&gt; void; };</code>
<code class="c"> * }} data</code>
<code class="c"> */</code>
<code class="kd">function</code> <code class="nx">loadData</code><code class="p">(</code><code class="nx">data</code><code class="p">)</code> <code class="p">{</code>
  <code class="c">// ...</code>
<code class="p">}</code></pre>

                <p class="author1">This is structural typing gone awry (<a href="#calibre_link-10" class="calibre9">Item
                    4</a>). While the function would technically work on any sort of object with a <code
                    class="calibre18">forEach</code> method with that signature, the intent was most likely for the
                  parameter to be <code class="calibre18">{files: string[]}</code>.</p>

                <p class="author1">You can get much of the TypeScript experience in a JavaScript project using JSDoc
                  annotations and <code class="calibre18">@ts-check</code>. This is appealing because it requires no
                  changes in your tooling. But it’s best not to go too far in this direction. Comment boilerplate has
                  real costs: it’s easy for your logic to get lost in a sea of JSDoc. TypeScript works best with <em
                    class="calibre3">.ts</em> files, not <em class="calibre3">.js</em> files. The goal is ultimately to
                  convert your project to TypeScript, not to JavaScript with JSDoc annotations. But <code
                    class="calibre18">@ts-check</code> can be a useful way to experiment with types and find some
                  initial errors, especially for projects that already have extensive JSDoc annotations.</p>
              </div>
            </section>













            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-989">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">Add "<code class="calibre18">// @ts-check</code>" to the top of a JavaScript file
                      to enable type checking.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Recognize common errors. Know how to declare globals and add type declarations
                      for third-party libraries.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Use JSDoc annotations for type assertions and better type inference.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Don’t spend too much time getting your code perfectly typed with JSDoc. Remember
                      that the goal is to convert to <em class="calibre3">.ts</em>!<a data-primary=""
                        data-startref="Mexper08" data-type="indexterm" id="calibre_link-400" class="calibre9"></a><a
                        data-primary="" data-startref="attscheck08" data-type="indexterm" id="calibre_link-67"
                        class="calibre9"></a><a data-primary="" data-startref="jsdoc08" data-type="indexterm"
                        id="calibre_link-367" class="calibre9"></a><a data-primary="" data-startref="TSexper08"
                        data-type="indexterm" id="calibre_link-676" class="calibre9"></a></p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>













        <section data-pdf-bookmark="Item 60: Use allowJs to Mix TypeScript and JavaScript" data-type="sect1"
          class="praise">
          <div class="praise" id="calibre_link-14">
            <h1 class="calibre16">Item 60: Use allowJs to Mix TypeScript and JavaScript</h1>

            <p class="author1">For<a data-primary="migration" data-secondary="mixing TypeScript with JavaScript"
                data-type="indexterm" id="calibre_link-401" class="calibre9"></a><a data-primary="allowJs"
                data-type="indexterm" id="calibre_link-84" class="calibre9"></a><a data-primary="TypeScript"
                data-secondary="mixing with JavaScript" data-type="indexterm" id="calibre_link-682"
                class="calibre9"></a><a data-primary="JavaScript" data-secondary="mixing with TypeScript"
                data-type="indexterm" id="calibre_link-351" class="calibre9"></a> a small project, you may be able to
              convert from JavaScript to TypeScript in one fell swoop. But for a larger project this “stop the world”
              approach won’t work. You need to be able to transition gradually. That means you need a way for TypeScript
              and JavaScript to coexist.</p>

            <p class="author1">The<a data-primary="compiling" data-secondary="compiler options" data-type="indexterm"
                id="calibre_link-178" class="calibre9"></a> key to this is the <code class="calibre18">allowJs</code>
              compiler option. With <code class="calibre18">allowJs</code>, TypeScript files and JavaScript files may
              import one another. For JavaScript files this mode is extremely permissive. Unless you use <code
                class="calibre18">@ts-check</code> (<a href="#calibre_link-18" class="calibre9">Item 59</a>), the only
              errors you’ll see are syntax errors. This is “TypeScript is a superset of JavaScript” in the most trivial
              sense.</p>

            <p class="author1">While it’s unlikely to catch errors, <code class="calibre18">allowJs</code> does give you
              an opportunity to introduce TypeScript into your build chain before you start making code changes. This is
              a good idea because you’ll want to be able to run your tests as you convert modules to TypeScript (<a
                href="#calibre_link-15" class="calibre9">Item 61</a>).</p>

            <p class="author1">If your bundler includes TypeScript integration or has a plug-in available, that’s
              usually the easiest path forward. With<a data-primary="browserify" data-type="indexterm"
                id="calibre_link-137" class="calibre9"></a> <code class="calibre18">browserify</code>, for instance, you
              run <code class="calibre18">npm install --sav-dev tsify</code> and add it as a plug-in:</p>
            <pre data-type="programlisting"
              class="calibre17">$ <strong class="calibre32">browserify index.ts -p [ tsify --noImplicitAny ] &gt; bundle.js</strong></pre>

            <p class="author1">Most unit testing tools have an option like this as well. With the <code
                class="calibre18">jest</code> tool, for instance, you install <code class="calibre18">ts-jest</code> and
              pass TypeScript sources through it by specifying a <code class="calibre18">jest.config.js</code> like:</p>

            <pre data-code-language="js" data-type="programlisting" class="calibre17"><code class="nx">module</code><code class="p">.</code><code class="nx">exports</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">transform</code><code class="o">:</code> <code class="p">{</code>
    <code class="s">'^.+\\.tsx?$'</code><code class="o">:</code> <code class="s">'ts-jest'</code><code class="p">,</code>
  <code class="p">},</code>
<code class="p">};</code></pre>

            <p class="author1">If your build chain is custom, your task will be more involved. But there’s always a good
              fallback option: when you specify the <code class="calibre18">outDir</code> option, TypeScript will
              generate pure JavaScript sources in a directory that parallels your source tree. Usually your existing
              build chain can be run over that. You may need to tweak TypeScript’s JavaScript output so that it closely
              matches your original JavaScript source, (e.g., by specifying the <code class="calibre18">target</code>
              and <code class="calibre18">module</code> options).</p>

            <p class="author1">Adding TypeScript into your build and test process may not be the most enjoyable task,
              but it is an essential one that will let you begin to migrate your code with <span
                class="calibre">confidence.</span></p>








            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-990">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">Use the <code class="calibre18">allowJs</code> compiler option to support mixed
                      JavaScript and TypeScript as you transition your project.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Get your tests and build chain working with TypeScript before beginning
                      large-scale migration.</p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>













        <section data-pdf-bookmark="Item 61: Convert Module by Module Up Your Dependency Graph" data-type="sect1"
          class="praise">
          <div class="praise" id="calibre_link-15">
            <h1 class="calibre16">Item 61: Convert Module by Module Up Your Dependency Graph</h1>

            <p class="author1">You’ve<a data-primary="migration" data-secondary="converting module by module"
                data-type="indexterm" id="calibre_link-397" class="calibre9"></a> adopted modern JavaScript, converting
              your project to use ECMAScript modules and classes (<a href="#calibre_link-29" class="calibre9">Item
                58</a>). You’ve integrated TypeScript into your build chain and have all your tests passing (<a
                href="#calibre_link-14" class="calibre9">Item 60</a>). Now for the fun part: converting your JavaScript
              to TypeScript. But where to begin?</p>

            <p class="author1">When you add types to a module, it’s likely to surface new type errors in all the modules
              that depend on it. Ideally you’d like to convert each module once and be done with it. This implies that
              you should convert modules going <em class="calibre3">up</em> the dependency graph: starting with the
              leaves (modules that depend on no others) and moving up to the root.</p>

            <p class="author1">The very first modules to migrate are your third-party dependencies since, by definition,
              you depend on them but they do not depend on you. Usually this means installing <code
                class="calibre18">@types</code> modules. If you use the <code class="calibre18">lodash</code> utility
              library, for example, you’d run <code class="calibre18">npm install --save-dev @types/lodash</code>. These
              typings will help types flow through your code and surface issues in your use of the libraries.</p>

            <p class="author1">If your code calls external APIs, you may also want to add type declarations for these
              early on. Although these calls may happen anywhere in your code, this is still in the spirit of moving up
              the dependency graph since you depend on the APIs but they do not depend on you. Many types flow from API
              calls, and these are generally difficult to infer from context. If you can find a spec for the API,
              generate types from that (see <a href="#calibre_link-30" class="calibre9">Item 35</a>).</p>

            <p class="author1">As you migrate your own modules, it’s helpful to visualize the dependency graph. <a
                data-type="xref" href="#calibre_link-31" class="calibre9">Figure&nbsp;8-3</a> shows an example graph
              from a medium-sized JavaScript project, made using the excellent <code class="calibre18">madge</code>
              tool.</p>

            <figure class="calibre28">
              <div class="figure" id="calibre_link-31">
                <img alt="efts 0801" src="images/000014.png" class="calibre29" />
                <h6 class="calibre30"><span class="calibre">Figure 8-3. </span>The dependency graph for a medium-sized
                  JavaScript project. Arrows indicate dependencies. Darker-shaded boxes indicate that a module is
                  involved in a circular dependency.</h6>
              </div>
            </figure>

            <p class="author1">The bottom of this dependency graph is the circular dependency between <em
                class="calibre3">utils.js</em> and <em class="calibre3">tickers.js</em>. There are many modules that
              depend on these two, but they only depend on one another. This pattern is quite common: most projects will
              have some sort of utility module at the bottom of the dependency graph.</p>

            <p class="author1">As you migrate your code, focus on adding types rather than refactoring. If this is an
              old project, you’re likely to notice some strange things and want to fix them. Resist this urge! The
              immediate goal is to convert your project to TypeScript, not to improve its design. Instead, write down
              code smells as you detect them and make a list of future refactors.</p>

            <p class="author1">There are a few common errors you’ll run into as you convert to TypeScript. Some of these
              were covered in <a href="#calibre_link-18" class="calibre9">Item 59</a>, but new ones include:</p>








            <section class="praise" data-pdf-bookmark="Undeclared Class Members" data-type="sect2">
              <div class="praise" id="calibre_link-991">
                <h2 class="calibre31">Undeclared Class Members</h2>

                <p class="author1">Classes in JavaScript do not need to declare their members, but classes in TypeScript
                  do. When you rename a class’s <em class="calibre3">.js</em> file to <em class="calibre3">.ts</em>,
                  it’s likely to show errors for every single property you reference:</p>

                <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">class</code> <code class="nx">Greeting</code> <code class="p">{</code>
  <code class="kd">constructor</code><code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">this</code><code class="p">.</code><code class="nx">greeting</code> <code class="o">=</code> <code class="s">'Hello'</code><code class="p">;</code>
      <code class="c">// ~~~~~~~~ Property 'greeting' does not exist on type 'Greeting'</code>
    <code class="kd">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code><code class="p">;</code>
      <code class="c">// ~~~~ Property 'name' does not exist on type 'Greeting'</code>
  <code class="p">}</code>
  <code class="nx">greet() {</code>
    <code class="kd">return</code> <code class="kd">this</code><code class="p">.</code><code class="nx">greeting</code> <code class="o">+</code> <code class="s">' '</code> <code class="o">+</code> <code class="kd">this</code><code class="p">.</code><code class="nx">name</code><code class="p">;</code>
             <code class="c">// ~~~~~~~~              ~~~~ Property ... does not exist</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

                <p class="author1">There’s a helpful quick fix (see <a data-type="xref" href="#calibre_link-32"
                    class="calibre9">Figure&nbsp;8-4</a>) for this that you should take advantage of.</p>

                <figure class="calibre28">
                  <div class="figure" id="calibre_link-32">
                    <img alt="efts 08in03" src="images/000000.png" class="calibre29" />
                    <h6 class="calibre30"><span class="calibre">Figure 8-4. </span>The quick fix to add declarations for
                      missing members is particularly helpful in converting a class to TypeScript.</h6>
                  </div>
                </figure>

                <p class="author1">This will add declarations for the missing members based on usage:</p>

                <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">class</code> <code class="nx">Greeting</code> <code class="p">{</code>
  <code class="nx">greeting</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">name</code>: <code class="nx">any</code><code class="p">;</code>
  <code class="kd">constructor</code><code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">this</code><code class="p">.</code><code class="nx">greeting</code> <code class="o">=</code> <code class="s">'Hello'</code><code class="p">;</code>
    <code class="kd">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="nx">greet() {</code>
    <code class="kd">return</code> <code class="kd">this</code><code class="p">.</code><code class="nx">greeting</code> <code class="o">+</code> <code class="s">' '</code> <code class="o">+</code> <code class="kd">this</code><code class="p">.</code><code class="nx">name</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

                <p class="author1">TypeScript was able to get the type for <code class="calibre18">greeting</code>
                  correct, but not the type for <code class="calibre18">name</code>. After applying this quick fix, you
                  should look through the property list and fix the <code class="calibre18">any</code> types.</p>

                <p class="author1">If<a data-primary="dygraph.js" data-type="indexterm" id="calibre_link-230"
                    class="calibre9"></a> this is the first time you’ve seen the full property list for your class, you
                  may be in for a shock. When I converted the main class in <em class="calibre3">dygraph.js</em> (the
                  root module in <a data-type="xref" href="#calibre_link-31" class="calibre9">Figure&nbsp;8-3</a>), I
                  discovered that it had no fewer than 45 member variables! Migrating to TypeScript has a way of
                  surfacing bad designs like this that were previously implicit. It’s harder to justify a bad design if
                  you have to look at it. But again, resist the urge to refactor now. Note the oddity and think about
                  how you’d fix it some other day.</p>
              </div>
            </section>













            <section class="praise" data-pdf-bookmark="Values with Changing Types" data-type="sect2">
              <div class="praise" id="calibre_link-992">
                <h2 class="calibre31">Values with Changing Types</h2>

                <p class="author1">TypeScript will complain about code like this:</p>

                <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">state</code> <code class="o">=</code> <code class="p">{};</code>
<code class="nx">state</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="s">'New York'</code><code class="p">;</code>
   <code class="c">// ~~~~ Property 'name' does not exist on type '{}'</code>
<code class="nx">state</code><code class="p">.</code><code class="nx">capital</code> <code class="o">=</code> <code class="s">'Albany'</code><code class="p">;</code>
   <code class="c">// ~~~~~~~ Property 'capital' does not exist on type '{}'</code></pre>

                <p class="author1">This topic is covered in more depth in <a href="#calibre_link-33"
                    class="calibre9">Item 23</a>, so you may want to brush up on that item if you run into this error.
                  If the fix is trivial, you can build the object all at once:</p>

                <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">state</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">name</code><code class="o">:</code> <code class="s">'New York'</code><code class="p">,</code>
  <code class="nx">capital</code><code class="o">:</code> <code class="s">'Albany'</code><code class="p">,</code>
<code class="p">};</code>  <code class="c">// OK</code></pre>

                <p class="author1">If it is not, then this is an appropriate time to use a type assertion:</p>

                <pre data-code-language="ts" data-type="programlisting"
                  class="calibre17"><code class="kd">interface</code> <code class="nx">State</code> <code class="p">{</code>
  <code class="nx">name</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">capital</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">const</code> <code class="nx">state</code> <code class="o">=</code> <code class="p">{}</code> <code class="kd">as</code> <code class="nx">State</code><code class="p">;</code>
<code class="nx">state</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="s">'New York'</code><code class="p">;</code>  <code class="c">// OK</code>
<code class="nx">state</code><code class="p">.</code><code class="nx">capital</code> <code class="o">=</code> <code class="s">'Albany'</code><code class="p">;</code>  <code class="c">// OK</code></pre>

                <p class="author1">You should fix this eventually (see <a href="#calibre_link-27" class="calibre9">Item
                    9</a>), but this is expedient and will help you keep the migration going.</p>

                <p class="author1">If you’ve been using JSDoc and <code class="calibre18">@ts-check</code> (<a
                    href="#calibre_link-18" class="calibre9">Item 59</a>), be aware that you can actually <em
                    class="calibre3">lose</em> type safety by converting to TypeScript. For instance, TypeScript flags
                  an error in this JavaScript:</p>

                <pre data-code-language="js" data-type="programlisting" class="calibre17"><code class="c">// @ts-check</code>
<code class="c">/**</code>
<code class="c"> * @param {number} num</code>
<code class="c"> */</code>
<code class="kd">function</code> <code class="kd">double</code><code class="p">(</code><code class="nx">num</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="mi">2</code> <code class="o">*</code> <code class="nx">num</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">double</code><code class="p">(</code><code class="s">'trouble'</code><code class="p">);</code>
    <code class="c">// ~~~~~~~~~ Argument of type '"trouble"' is not assignable to</code>
    <code class="c">//           parameter of type 'number'</code></pre>

                <p class="author1">When you convert to TypeScript, the <code class="calibre18">@ts-check</code> and
                  JSDoc stop being enforced. This means the type of <code class="calibre18">num</code> is implicitly
                  <code class="calibre18">any</code>, so there’s no error:
                </p>

                <pre data-code-language="ts" data-type="programlisting"
                  class="calibre17"><code class="c">/**</code>
<code class="c"> * @param {number} num</code>
<code class="c"> */</code>
<code class="kd">function</code> <code class="kd">double</code><code class="p">(</code><code class="nx">num</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="mi">2</code> <code class="o">*</code> <code class="nx">num</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">double</code><code class="p">(</code><code class="s">'trouble'</code><code class="p">);</code>  <code class="c">// OK</code></pre>

                <p class="author1">Fortunately there’s a quick fix available to move JSDoc types to TypeScript types. If
                  you have any JSDoc, you should use what’s shown in <a data-type="xref" href="#calibre_link-34"
                    class="calibre9">Figure&nbsp;8-5</a>.</p>

                <figure class="width1">
                  <div class="figure" id="calibre_link-34">
                    <img alt="efts 08in04" src="images/000017.png" class="calibre29" />
                    <h6 class="calibre30"><span class="calibre">Figure 8-5. </span>Quick fix to copy JSDoc annotations
                      to TypeScript type annotations</h6>
                  </div>
                </figure>

                <p class="author1">Once you’ve copied type annotations to TypeScript, make sure to remove them from the
                  JSDoc to avoid redundancy (see <a href="#calibre_link-9" class="calibre9">Item 30</a>):</p>

                <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="kd">double</code><code class="p">(</code><code class="nx">num</code>: <code class="nx">number</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="mi">2</code> <code class="o">*</code> <code class="nx">num</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">double</code><code class="p">(</code><code class="s">'trouble'</code><code class="p">);</code>
    <code class="c">// ~~~~~~~~~ Argument of type '"trouble"' is not assignable to</code>
    <code class="c">//           parameter of type 'number'</code></pre>

                <p class="author1">This issue will also be caught when you turn on <code
                    class="calibre18">noImplicitAny</code>, but you may as well add the types now.</p>

                <p class="author1">Migrate your tests last. They should be at the top of your dependency graph (since
                  your code doesn’t depend on them), and it’s extremely helpful to know that your tests continue to pass
                  during the migration despite your not having changed them at all.</p>
              </div>
            </section>













            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-993">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">Start migration by adding <code class="calibre18">@types</code> for third-party
                      modules and external API calls.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Begin migrating your modules from the bottom of the dependency graph upwards. The
                      first module will usually be some sort of utility code. Consider visualizing the dependency graph
                      to help you track progress.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Resist the urge to refactor your code as you uncover odd designs. Keep a list of
                      ideas for future refactors, but stay focused on TypeScript conversion.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Be aware of common errors that come up during conversion. Copy JSDoc annotations
                      if necessary to avoid losing type safety as you convert.<a data-primary=""
                        data-startref="Mconvert08" data-type="indexterm" id="calibre_link-398" class="calibre9"></a></p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>













        <section data-pdf-bookmark="Item 62: Don’t Consider Migration Complete Until You Enable noImplicitAny"
          data-type="sect1" class="praise">
          <div class="praise" id="calibre_link-994">
            <h1 class="calibre16">Item 62: Don’t Consider Migration Complete Until You Enable noImplicitAny</h1>

            <p class="author1">Converting<a data-primary="migration" data-secondary="noImplicitAny"
                data-type="indexterm" id="calibre_link-402" class="calibre9"></a><a data-primary="noImplicitAny"
                data-type="indexterm" id="calibre_link-422" class="calibre9"></a> your whole project to <em
                class="calibre3">.ts</em> is a big accomplishment. But your work isn’t done quite yet. Your next goal is
              to turn on the <code class="calibre18">noImplicitAny</code> option (<a href="#calibre_link-25"
                class="calibre9">Item 2</a>). TypeScript code without <code class="calibre18">noImplicitAny</code> is
              best thought of as transitional because it can mask real errors you’ve made in your type declarations.</p>

            <p class="author1">For example, perhaps you’ve used the “Add all missing members” quick fix to add property
              declarations to a class (<a href="#calibre_link-15" class="calibre9">Item 61</a>). You’re left with an
              <code class="calibre18">any</code> type and would like to fix it:
            </p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">class</code> <code class="nx">Chart</code> <code class="p">{</code>
  <code class="nx">indices</code>: <code class="nx">any</code><code class="p">;</code>

  <code class="c">// ...</code>
<code class="p">}</code></pre>

            <p class="author1"><code class="calibre18">indices</code> sounds like it should be an array of numbers, so
              you plug in that type:</p>

            <pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">class</code> <code class="nx">Chart</code> <code class="p">{</code>
  <code class="nx">indices</code>: <code class="nx">number</code><code class="p">[];</code>

  <code class="c">// ...</code>
<code class="p">}</code></pre>

            <p class="author1">No new errors result, so you then keep moving. Unfortunately, you’ve made a mistake:
              <code class="calibre18">number[]</code> is the wrong type. Here’s some code from elsewhere in the class:
            </p>

            <pre data-code-language="ts" data-type="programlisting" id="calibre_link-995" class="calibre17"><code class="nx">getRanges() {</code>
  <code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="nx">r</code> <code class="nx">of</code> <code class="kd">this</code><code class="p">.</code><code class="nx">indices</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">const</code> <code class="nx">low</code> <code class="o">=</code> <code class="nx">r</code><code class="p">[</code><code class="mi">0</code><code class="p">];</code>  <code class="c">// Type is any</code>
    <code class="kd">const</code> <code class="nx">high</code> <code class="o">=</code> <code class="nx">r</code><code class="p">[</code><code class="mi">1</code><code class="p">];</code>  <code class="c">// Type is any</code>
    <code class="c">// ...</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

            <p class="author1">Clearly <code class="calibre18">number[][]</code> or <code
                class="calibre18">[number, number][]</code> would be a more accurate type. Does it surprise you that
              indexing into a <code class="calibre18">number</code> is allowed? Take this as an indication of just how
              loose TypeScript can be without <code class="calibre18">noImplicitAny</code>.</p>

            <p class="author1">When you turn on <code class="calibre18">noImplicitAny</code>, this becomes an error:</p>

            <pre data-code-language="ts" data-type="programlisting" id="calibre_link-996" class="calibre17"><code class="nx">getRanges() {</code>
  <code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="nx">r</code> <code class="nx">of</code> <code class="kd">this</code><code class="p">.</code><code class="nx">indices</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">const</code> <code class="nx">low</code> <code class="o">=</code> <code class="nx">r</code><code class="p">[</code><code class="mi">0</code><code class="p">];</code>
             <code class="c">// ~~~~ Element implicitly has an 'any' type because</code>
             <code class="c">//      type 'Number' has no index signature</code>
    <code class="kd">const</code> <code class="nx">high</code> <code class="o">=</code> <code class="nx">r</code><code class="p">[</code><code class="mi">1</code><code class="p">];</code>
              <code class="c">// ~~~~ Element implicitly has an 'any' type because</code>
              <code class="c">//      type 'Number' has no index signature</code>
    <code class="c">// ...</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

            <p class="author1">A<a data-primary="tsconfig.json" data-secondary="noImplicitAny" data-type="indexterm"
                id="calibre_link-548" class="calibre9"></a> good strategy for enabling <code
                class="calibre18">noImplicitAny</code> is to set it in your local client and start fixing errors. The
              number of errors you get from the type checker gives you a good sense of your progress. You can commit the
              type corrections without committing the <em class="calibre3">tsconfig.json</em> change until you get the
              number of errors down to zero.</p>

            <p class="author1">There are many other knobs you can turn to increase the strictness of type checking,
              culminating with <code class="calibre18">"strict": true</code>. But <code
                class="calibre18">noImplicitAny</code> is the most important one and your project will get most of the
              benefits of TypeScript even if you don’t adopt other settings like <code
                class="calibre18">strictNullChecks</code>. Give everyone on your team a chance to get used to TypeScript
              before you adopt stricter settings.</p>








            <section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2">
              <div class="praise" id="calibre_link-997">
                <h2 class="calibre31">Things to Remember</h2>

                <ul class="printings">
                  <li class="calibre12">
                    <p class="author1">Don’t consider your TypeScript migration done until you adopt <code
                        class="calibre18">noImplicitAny</code>. Loose type checking can mask real mistakes in type
                      declarations.</p>
                  </li>
                  <li class="calibre12">
                    <p class="author1">Fix type errors gradually before enforcing <code
                        class="calibre18">noImplicitAny</code>. Give your team a chance to get comfortable with
                      TypeScript before adopting stricter checks.<a data-primary="" data-startref="JSmig08"
                        data-type="indexterm" id="calibre_link-350" class="calibre9"></a><a data-primary=""
                        data-startref="TSmig08" data-type="indexterm" id="calibre_link-681" class="calibre9"></a></p>
                  </li>
                </ul>
              </div>
            </section>





          </div>
        </section>







        <div data-type="footnotes" class="calibre46">
          <p data-type="footnote" id="calibre_link-16" class="calibre47"><sup class="calibre48"><a
                href="#calibre_link-35" class="calibre49">1</a></sup> Z. Gao, C. Bird, and E. T. Barr, “To Type or Not
            to Type: Quantifying Detectable Bugs in JavaScript,” ICSE 2017, <a
              href="http://earlbarr.com/publications/typestudy.pdf" class="calibre9"><em
                class="calibre3">http://earlbarr.com/publications/typestudy.pdf</em></a>.</p>
          <p data-type="footnote" id="calibre_link-17" class="calibre47"><sup class="calibre48"><a
                href="#calibre_link-36" class="calibre49">2</a></sup> Brie Bunge, “Adopting TypeScript at Scale,” JSConf
            Hawaii 2019, <a href="https://youtu.be/P-J9Eg7hJwE" class="calibre9"><em
                class="calibre3">https://youtu.be/P-J9Eg7hJwE</em></a>.</p>
          <p data-type="footnote" id="calibre_link-24" class="calibre47"><sup class="calibre48"><a
                href="#calibre_link-37" class="calibre49">3</a></sup> <a href="https://github.com/tc39/proposals"
              class="calibre9"><em class="calibre3">https://github.com/tc39/proposals</em></a></p>
        </div>
      </div>
    </section>
  </div>

  <div data-type="book" class="calibre1" id="calibre_link-55">
    <section data-type="index" type="index" class="praise">
      <div class="index" id="calibre_link-998">
        <h1 class="calibre14">Index</h1>
        <div data-type="index" class="praise">
          <div data-type="indexdiv" class="praise">
            <h3 class="calibre54"><span data-gentext="indexsymbols" class="calibre">Symbols</span></h3>
            <ul class="calibre55">
              <li class="calibre11"><span data-type="index-term" class="calibre">! operator</span>, <a
                  data-type="index:locator" href="#calibre_link-56" class="calibre9">Item 9: Prefer Type Declarations to
                  Type Assertions</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre"># (private field prefix)</span>, <a
                  data-type="index:locator" href="#calibre_link-57" class="calibre9">Item 56: Don’t Rely on Private to
                  Hide Information</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">&amp; operator</span>, <a
                  data-type="index:locator" href="#calibre_link-58" class="calibre9">Item 7: Think of Types as Sets of
                  Values</a>, <a data-type="index:locator" href="#calibre_link-59" class="calibre9">Item 8: Know How to
                  Tell Whether a Symbol Is in the Type Space or Value Space</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">() =&gt; any</span>, <a
                  data-type="index:locator" href="#calibre_link-60" class="calibre9">Item 39: Prefer More Precise
                  Variants of any to Plain any</a>-<a data-type="index:locator" href="#calibre_link-61"
                  class="calibre9">Things to Remember</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">.js/.jsx extension</span>, <a
                  data-type="index:locator" href="#calibre_link-62" class="calibre9">Item 1: Understand the Relationship
                  Between TypeScript and JavaScript</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">.ts/.tsx extension</span>, <a
                  data-type="index:locator" href="#calibre_link-63" class="calibre9">Item 1: Understand the Relationship
                  Between TypeScript and JavaScript</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">@param type</span>, <a
                  data-type="index:locator" href="#calibre_link-64" class="calibre9">Item 48: Use TSDoc for API
                  Comments</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">@returns type</span>, <a
                  data-type="index:locator" href="#calibre_link-65" class="calibre9">Item 48: Use TSDoc for API
                  Comments</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">@ts-check</span>, <a
                  data-type="index:locator" href="#calibre_link-66" class="calibre9">Item 59: Use @ts-check and JSDoc to
                  Experiment with TypeScript</a>-<a data-type="index:locator" href="#calibre_link-67"
                  class="calibre9">Things to Remember</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">@ts-ignore</span>, <a
                  data-type="index:locator" href="#calibre_link-68" class="calibre9">Item 38: Use the Narrowest Possible
                  Scope for any Types</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">@types (type dependencies)</span>
                <ul class="calibre56">
                  <li class="calibre11"><span data-type="index-term" class="calibre">installing in
                      devDependencies</span>, <a data-type="index:locator" href="#calibre_link-69" class="calibre9">Item
                      45: Put TypeScript and @types in devDependencies</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">JavaScript developers and</span>,
                    <a data-type="index:locator" href="#calibre_link-70" class="calibre9">Item 51: Mirror Types to Sever
                      Dependencies</a>
                  </li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">preventing regressions in type
                      safety</span>, <a data-type="index:locator" href="#calibre_link-71" class="calibre9">Item 44:
                      Track Your Type Coverage to Prevent Regressions in Type Safety</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">three versions involved in</span>,
                    <a data-type="index:locator" href="#calibre_link-72" class="calibre9">Item 46: Understand the Three
                      Versions Involved in Type Declarations</a>-<a data-type="index:locator" href="#calibre_link-73"
                      class="calibre9">Things to Remember</a>
                  </li>
                </ul>
              </li>
              <li class="calibre11"><span data-type="index-term" class="calibre">[ ] property accessor</span>, <a
                  data-type="index:locator" href="#calibre_link-74" class="calibre9">Item 8: Know How to Tell Whether a
                  Symbol Is in the Type Space or Value Space</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">{ } type</span>, <a
                  data-type="index:locator" href="#calibre_link-75" class="calibre9">Item 42: Use unknown Instead of any
                  for Values with an Unknown Type</a>-<a data-type="index:locator" href="#calibre_link-76"
                  class="calibre9">Things to Remember</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">{[id: string]: any}</span>, <a
                  data-type="index:locator" href="#calibre_link-77" class="calibre9">Item 39: Prefer More Precise
                  Variants of any to Plain any</a>-<a data-type="index:locator" href="#calibre_link-78"
                  class="calibre9">Things to Remember</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">{[key: string]: any} type</span>, <a
                  data-type="index:locator" href="#calibre_link-79" class="calibre9">Item 39: Prefer More Precise
                  Variants of any to Plain any</a>, <a data-type="index:locator" href="#calibre_link-80"
                  class="calibre9">Item 44: Track Your Type Coverage to Prevent Regressions in Type Safety</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">| operator</span>, <a
                  data-type="index:locator" href="#calibre_link-81" class="calibre9">Item 8: Know How to Tell Whether a
                  Symbol Is in the Type Space or Value Space</a></li>
            </ul>
          </div>
          <div data-type="indexdiv" class="praise">
            <h3 class="calibre54">A</h3>
            <ul class="calibre55">
              <li class="calibre11"><span data-type="index-term" class="calibre">aliases</span>, <a
                  data-type="index:locator" href="#calibre_link-82" class="calibre9">Item 24: Be Consistent in Your Use
                  of Aliases</a>-<a data-type="index:locator" href="#calibre_link-83" class="calibre9">Things to
                  Remember</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">allowJs</span>, <a
                  data-type="index:locator" href="#calibre_link-84" class="calibre9">Item 60: Use allowJs to Mix
                  TypeScript and JavaScript</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">Angular</span>, <a
                  data-type="index:locator" href="#calibre_link-85" class="calibre9">Decorators</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">any types</span>
                <ul class="calibre56">
                  <li class="calibre11"><span data-type="index-term" class="calibre">drawbacks of</span>, <a
                      data-type="index:locator" href="#calibre_link-86" class="calibre9">Item 5: Limit Use of the any
                      Type</a>-<a data-type="index:locator" href="#calibre_link-87" class="calibre9">Things to
                      Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">evolving</span>, <a
                      data-type="index:locator" href="#calibre_link-88" class="calibre9">Item 41: Understand Evolving
                      any</a>-<a data-type="index:locator" href="#calibre_link-89" class="calibre9">Things to
                      Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">hiding unsafe type
                      assertions</span>, <a data-type="index:locator" href="#calibre_link-90" class="calibre9">Item 40:
                      Hide Unsafe Type Assertions in Well-Typed Functions</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">versus inaccurate models</span>, <a
                      data-type="index:locator" href="#calibre_link-91" class="calibre9">Item 33: Prefer More Precise
                      Alternatives to String Types</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">plain any versus more precise
                      variants</span>, <a data-type="index:locator" href="#calibre_link-92" class="calibre9">Item 39:
                      Prefer More Precise Variants of any to Plain any</a>-<a data-type="index:locator"
                      href="#calibre_link-93" class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">preventing regressions in type
                      safety</span>, <a data-type="index:locator" href="#calibre_link-94" class="calibre9">Item 44:
                      Track Your Type Coverage to Prevent Regressions in Type Safety</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">type-safe approaches versus
                      monkey-patching</span>, <a data-type="index:locator" href="#calibre_link-95" class="calibre9">Item
                      43: Prefer Type-Safe Approaches to Monkey Patching</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">unknown versus any types</span>, <a
                      data-type="index:locator" href="#calibre_link-96" class="calibre9">Item 42: Use unknown Instead of
                      any for Values with an Unknown Type</a>-<a data-type="index:locator" href="#calibre_link-97"
                      class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">using narrow scope for</span>, <a
                      data-type="index:locator" href="#calibre_link-98" class="calibre9">Item 38: Use the Narrowest
                      Possible Scope for any Types</a>-<a data-type="index:locator" href="#calibre_link-99"
                      class="calibre9">Things to Remember</a></li>
                </ul>
              </li>
              <li class="calibre11"><span data-type="index-term" class="calibre">any[ ] types</span>, <a
                  data-type="index:locator" href="#calibre_link-100" class="calibre9">Item 39: Prefer More Precise
                  Variants of any to Plain any</a>-<a data-type="index:locator" href="#calibre_link-101"
                  class="calibre9">Things to Remember</a>, <a data-type="index:locator" href="#calibre_link-102"
                  class="calibre9">Item 41: Understand Evolving any</a>-<a data-type="index:locator"
                  href="#calibre_link-103" class="calibre9">Things to Remember</a>, <a data-type="index:locator"
                  href="#calibre_link-104" class="calibre9">Item 44: Track Your Type Coverage to Prevent Regressions in
                  Type Safety</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">Array interface</span>, <a
                  data-type="index:locator" href="#calibre_link-105" class="calibre9">Item 13: Know the Differences
                  Between type and interface</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">array methods</span>, <a
                  data-type="index:locator" href="#calibre_link-106" class="calibre9">Use for-of or Array Methods
                  Instead of for(;;)</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">Array type</span>, <a
                  data-type="index:locator" href="#calibre_link-107" class="calibre9">Item 16: Prefer Arrays, Tuples,
                  and ArrayLike to number Index Signatures</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">ArrayLike type</span>, <a
                  data-type="index:locator" href="#calibre_link-108" class="calibre9">Item 16: Prefer Arrays, Tuples,
                  and ArrayLike to number Index Signatures</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">arrays</span>, <a
                  data-type="index:locator" href="#calibre_link-109" class="calibre9">Item 16: Prefer Arrays, Tuples,
                  and ArrayLike to number Index Signatures</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">arrow functions</span>, <a
                  data-type="index:locator" href="#calibre_link-110" class="calibre9">Item 9: Prefer Type Declarations
                  to Type Assertions</a>, <a data-type="index:locator" href="#calibre_link-111" class="calibre9">Prefer
                  Arrow Functions Over Function Expressions</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">as const</span>, <a
                  data-type="index:locator" href="#calibre_link-112" class="calibre9">Item 21: Understand Type
                  Widening</a>, <a data-type="index:locator" href="#calibre_link-113" class="calibre9">Objects</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">assignable to</span>, <a
                  data-type="index:locator" href="#calibre_link-114" class="calibre9">Item 7: Think of Types as Sets of
                  Values</a>, <a data-type="index:locator" href="#calibre_link-115" class="calibre9">Item 52: Be Aware
                  of the Pitfalls of Testing Types</a>, <a data-type="index:locator" href="#calibre_link-116"
                  class="calibre9">Item 54: Know How to Iterate Over Objects</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">Astaire, Fred</span>, <a
                  data-type="index:locator" href="#calibre_link-117" class="calibre9">Item 14: Use Type Operations and
                  Generics to Avoid Repeating Yourself</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">async arrow functions</span>, <a
                  data-type="index:locator" href="#calibre_link-118" class="calibre9">Item 25: Use async Functions
                  Instead of Callbacks for Asynchronous Code</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">async functions</span>, <a
                  data-type="index:locator" href="#calibre_link-119" class="calibre9">Item 25: Use async Functions
                  Instead of Callbacks for Asynchronous Code</a>-<a data-type="index:locator" href="#calibre_link-120"
                  class="calibre9">Things to Remember</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">async/await</span>, <a
                  data-type="index:locator" href="#calibre_link-121" class="calibre9">Use async/await Instead of Raw
                  Promises or Callbacks</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">asynchronous code</span>, <a
                  data-type="index:locator" href="#calibre_link-122" class="calibre9">Item 25: Use async Functions
                  Instead of Callbacks for Asynchronous Code</a>-<a data-type="index:locator" href="#calibre_link-123"
                  class="calibre9">Things to Remember</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">augmentation</span>, <a
                  data-type="index:locator" href="#calibre_link-124" class="calibre9">Item 13: Know the Differences
                  Between type and interface</a>, <a data-type="index:locator" href="#calibre_link-125"
                  class="calibre9">Item 43: Prefer Type-Safe Approaches to Monkey Patching</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">await keyword</span>, <a
                  data-type="index:locator" href="#calibre_link-126" class="calibre9">Item 25: Use async Functions
                  Instead of Callbacks for Asynchronous Code</a>-<a data-type="index:locator" href="#calibre_link-127"
                  class="calibre9">Things to Remember</a>, <a data-type="index:locator" href="#calibre_link-128"
                  class="calibre9">Use async/await Instead of Raw Promises or Callbacks</a></li>
            </ul>
          </div>
          <div data-type="indexdiv" class="praise">
            <h3 class="calibre54">B</h3>
            <ul class="calibre55">
              <li class="calibre11"><span data-type="index-term" class="calibre">bigint primitive</span>, <a
                  data-type="index:locator" href="#calibre_link-129" class="calibre9">Item 10: Avoid Object Wrapper
                  Types (String, Number, Boolean, Symbol, BigInt)</a>-<a data-type="index:locator"
                  href="#calibre_link-130" class="calibre9">Things to Remember</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">boolean primitives</span>, <a
                  data-type="index:locator" href="#calibre_link-131" class="calibre9">Item 10: Avoid Object Wrapper
                  Types (String, Number, Boolean, Symbol, BigInt)</a>-<a data-type="index:locator"
                  href="#calibre_link-132" class="calibre9">Things to Remember</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">brands</span>, <a
                  data-type="index:locator" href="#calibre_link-133" class="calibre9">Item 37: Consider “Brands” for
                  Nominal Typing</a>-<a data-type="index:locator" href="#calibre_link-134" class="calibre9">Things to
                  Remember</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">Brooks, Fred</span>, <a
                  data-type="index:locator" href="#calibre_link-135" class="calibre9">Type Design</a>, <a
                  data-type="index:locator" href="#calibre_link-136" class="calibre9">Item 28: Prefer Types That Always
                  Represent Valid States</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">browserify</span>, <a
                  data-type="index:locator" href="#calibre_link-137" class="calibre9">Item 60: Use allowJs to Mix
                  TypeScript and JavaScript</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">built-in types, storing data on</span>,
                <a data-type="index:locator" href="#calibre_link-138" class="calibre9">Item 43: Prefer Type-Safe
                  Approaches to Monkey Patching</a>
              </li>
              <li class="calibre11"><span data-type="index-term" class="calibre">bundling types</span>, <a
                  data-type="index:locator" href="#calibre_link-139" class="calibre9">Item 46: Understand the Three
                  Versions Involved in Type Declarations</a></li>
            </ul>
          </div>
          <div data-type="indexdiv" class="praise">
            <h3 class="calibre54">C</h3>
            <ul class="calibre55">
              <li class="calibre11"><span data-type="index-term" class="calibre">C++</span>, <a
                  data-type="index:locator" href="#calibre_link-140" class="calibre9">You Cannot Overload a Function
                  Based on TypeScript Types</a>, <a data-type="index:locator" href="#calibre_link-141"
                  class="calibre9">Item 4: Get Comfortable with Structural Typing</a>, <a data-type="index:locator"
                  href="#calibre_link-142" class="calibre9">Type Inference</a>, <a data-type="index:locator"
                  href="#calibre_link-143" class="calibre9">Item 27: Use Functional Constructs and Libraries to Help
                  Types Flow</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">callbacks</span>
                <ul class="calibre56">
                  <li class="calibre11"><span data-type="index-term" class="calibre">async functions versus
                      callbacks</span>, <a data-type="index:locator" href="#calibre_link-144" class="calibre9">Item 25:
                      Use async Functions Instead of Callbacks for Asynchronous Code</a>-<a data-type="index:locator"
                      href="#calibre_link-145" class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">versus async/await</span>, <a
                      data-type="index:locator" href="#calibre_link-146" class="calibre9">Use async/await Instead of Raw
                      Promises or Callbacks</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">ECMAScript modules</span>, <a
                      data-type="index:locator" href="#calibre_link-147" class="calibre9">Use ECMAScript Modules</a>
                  </li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">providing types for this keyword
                      in</span>, <a data-type="index:locator" href="#calibre_link-148" class="calibre9">Item 49: Provide
                      a Type for this in Callbacks</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">testing inferred types</span>, <a
                      data-type="index:locator" href="#calibre_link-149" class="calibre9">Item 52: Be Aware of the
                      Pitfalls of Testing Types</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">type declarations for</span>, <a
                      data-type="index:locator" href="#calibre_link-150" class="calibre9">Item 12: Apply Types to Entire
                      Function Expressions When Possible</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">type inference and</span>, <a
                      data-type="index:locator" href="#calibre_link-151" class="calibre9">Callbacks</a></li>
                </ul>
              </li>
              <li class="calibre11"><span data-type="index-term" class="calibre">class construct</span>, <a
                  data-type="index:locator" href="#calibre_link-152" class="calibre9">Item 8: Know How to Tell Whether a
                  Symbol Is in the Type Space or Value Space</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">classes</span>
                <ul class="calibre56">
                  <li class="calibre11"><span data-type="index-term" class="calibre">ES2015</span>, <a
                      data-type="index:locator" href="#calibre_link-153" class="calibre9">Use Classes Instead of
                      Prototypes</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">implements</span>, <a
                      data-type="index:locator" href="#calibre_link-154" class="calibre9">Item 13: Know the Differences
                      Between type and interface</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">nominal typing</span>, <a
                      data-type="index:locator" href="#calibre_link-155" class="calibre9">Item 37: Consider “Brands” for
                      Nominal Typing</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">parameter properties</span>, <a
                      data-type="index:locator" href="#calibre_link-156" class="calibre9">Parameter Properties</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">private fields</span>, <a
                      data-type="index:locator" href="#calibre_link-157" class="calibre9">Item 56: Don’t Rely on Private
                      to Hide Information</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">this</span>, <a
                      data-type="index:locator" href="#calibre_link-158" class="calibre9">Parameter Properties</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">type versus value</span>, <a
                      data-type="index:locator" href="#calibre_link-159" class="calibre9">Item 8: Know How to Tell
                      Whether a Symbol Is in the Type Space or Value Space</a></li>
                </ul>
              </li>
              <li class="calibre11"><span data-type="index-term" class="calibre">classes, versus prototypes</span>, <a
                  data-type="index:locator" href="#calibre_link-160" class="calibre9">Use Classes Instead of
                  Prototypes</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">Closure Compiler</span>, <a
                  data-type="index:locator" href="#calibre_link-161" class="calibre9">Inaccurate JSDoc</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">closures</span>, <a
                  data-type="index:locator" href="#calibre_link-162" class="calibre9">Item 56: Don’t Rely on Private to
                  Hide Information</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">code generation, independent of
                  types</span>, <a data-type="index:locator" href="#calibre_link-163" class="calibre9">Item 3:
                  Understand That Code Generation Is Independent of Types</a>-<a data-type="index:locator"
                  href="#calibre_link-164" class="calibre9">Things to Remember</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">code samples, conventions used
                  in</span>, <a data-type="index:locator" href="#calibre_link-165" class="calibre9">Conventions in
                  TypeScript Code Samples</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">code, writing and running</span>
                <ul class="calibre56">
                  <li class="calibre11"><span data-type="index-term" class="calibre">debugging with source maps</span>,
                    <a data-type="index:locator" href="#calibre_link-166" class="calibre9">Item 57: Use Source Maps to
                      Debug TypeScript</a>-<a data-type="index:locator" href="#calibre_link-167" class="calibre9">Things
                      to Remember</a>
                  </li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">DOM hierarchy</span>, <a
                      data-type="index:locator" href="#calibre_link-168" class="calibre9">Item 55: Understand the DOM
                      hierarchy</a>-<a data-type="index:locator" href="#calibre_link-169" class="calibre9">Things to
                      Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">ECMAScript versus TypeScript
                      features</span>, <a data-type="index:locator" href="#calibre_link-170" class="calibre9">Item 53:
                      Prefer ECMAScript Features to TypeScript Features</a>-<a data-type="index:locator"
                      href="#calibre_link-171" class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">hiding information</span>, <a
                      data-type="index:locator" href="#calibre_link-172" class="calibre9">Item 56: Don’t Rely on Private
                      to Hide Information</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">iterating over objects</span>, <a
                      data-type="index:locator" href="#calibre_link-173" class="calibre9">Item 54: Know How to Iterate
                      Over Objects</a></li>
                </ul>
              </li>
              <li class="calibre11"><span data-type="index-term" class="calibre">compact object literals</span>, <a
                  data-type="index:locator" href="#calibre_link-174" class="calibre9">Use Compact Object Literals and
                  Destructuring Assignment</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">compiling</span>
                <ul class="calibre56">
                  <li class="calibre11"><span data-type="index-term" class="calibre">compiler options</span>, <a
                      data-type="index:locator" href="#calibre_link-175" class="calibre9">Item 2: Know Which TypeScript
                      Options You’re Using</a>, <a data-type="index:locator" href="#calibre_link-176"
                      class="calibre9">Prefer Arrow Functions Over Function Expressions</a>, <a
                      data-type="index:locator" href="#calibre_link-177" class="calibre9">Don’t Put use strict in
                      TypeScript</a>, <a data-type="index:locator" href="#calibre_link-178" class="calibre9">Item 60:
                      Use allowJs to Mix TypeScript and JavaScript</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">compiling versus type
                      checking</span>, <a data-type="index:locator" href="#calibre_link-179" class="calibre9">Code with
                      Type Errors Can Produce Output</a>-<a data-type="index:locator" href="#calibre_link-180"
                      class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">in TypeScript</span>, <a
                      data-type="index:locator" href="#calibre_link-181" class="calibre9">Getting to Know TypeScript</a>
                  </li>
                </ul>
              </li>
              <li class="calibre11"><span data-type="index-term" class="calibre">conditional types</span>, <a
                  data-type="index:locator" href="#calibre_link-182" class="calibre9">Item 50: Prefer Conditional Types
                  to Overloaded Declarations</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">configuration settings</span>, <a
                  data-type="index:locator" href="#calibre_link-183" class="calibre9">Item 2: Know Which TypeScript
                  Options You’re Using</a>-<a data-type="index:locator" href="#calibre_link-184" class="calibre9">Things
                  to Remember</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">const</span>
                <ul class="calibre56">
                  <li class="calibre11"><span data-type="index-term" class="calibre">avoiding errors associated with
                      mutation</span>, <a data-type="index:locator" href="#calibre_link-185" class="calibre9">Item 17:
                      Use readonly to Avoid Errors Associated with Mutation</a>-<a data-type="index:locator"
                      href="#calibre_link-186" class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">const versus as const</span>, <a
                      data-type="index:locator" href="#calibre_link-187" class="calibre9">Item 8: Know How to Tell
                      Whether a Symbol Is in the Type Space or Value Space</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">need for context</span>, <a
                      data-type="index:locator" href="#calibre_link-188" class="calibre9">Item 21: Understand Type
                      Widening</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">type declarations and</span>, <a
                      data-type="index:locator" href="#calibre_link-189" class="calibre9">Tuple Types</a></li>
                </ul>
              </li>
              <li class="calibre11"><span data-type="index-term" class="calibre">const assertion</span>, <a
                  data-type="index:locator" href="#calibre_link-190" class="calibre9">Item 21: Understand Type
                  Widening</a>, <a data-type="index:locator" href="#calibre_link-191" class="calibre9">Objects</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">context</span>, <a
                  data-type="index:locator" href="#calibre_link-192" class="calibre9">Item 21: Understand Type
                  Widening</a>, <a data-type="index:locator" href="#calibre_link-193" class="calibre9">Item 26:
                  Understand How Context Is Used in Type Inference</a>-<a data-type="index:locator"
                  href="#calibre_link-194" class="calibre9">Things to Remember</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">contracts, breaking with any
                  type</span>, <a data-type="index:locator" href="#calibre_link-195" class="calibre9">any Lets You Break
                  Contracts</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">CSV</span>, <a
                  data-type="index:locator" href="#calibre_link-196" class="calibre9">Item 15: Use Index Signatures for
                  Dynamic Data</a>-<a data-type="index:locator" href="#calibre_link-197" class="calibre9">Things to
                  Remember</a>, <a data-type="index:locator" href="#calibre_link-198" class="calibre9">Item 27: Use
                  Functional Constructs and Libraries to Help Types Flow</a>, <a data-type="index:locator"
                  href="#calibre_link-199" class="calibre9">Item 51: Mirror Types to Sever Dependencies</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">Curie, Marie</span>, <a
                  data-type="index:locator" href="#calibre_link-200" class="calibre9">Use Classes Instead of
                  Prototypes</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">Curry, Stephen</span>, <a
                  data-type="index:locator" href="#calibre_link-201" class="calibre9">Item 27: Use Functional Constructs
                  and Libraries to Help Types Flow</a></li>
            </ul>
          </div>
          <div data-type="indexdiv" class="praise">
            <h3 class="calibre54">D</h3>
            <ul class="calibre55">
              <li class="calibre11"><span data-type="index-term" class="calibre">Davis, Miles</span>, <a
                  data-type="index:locator" href="#calibre_link-202" class="calibre9">Item 33: Prefer More Precise
                  Alternatives to String Types</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">debugging</span>
                <ul class="calibre56">
                  <li class="calibre11"><span data-type="index-term" class="calibre">any type drawbacks</span>, <a
                      data-type="index:locator" href="#calibre_link-203" class="calibre9">any Types Mask Bugs When You
                      Refactor Code</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">with source maps</span>, <a
                      data-type="index:locator" href="#calibre_link-204" class="calibre9">Item 57: Use Source Maps to
                      Debug TypeScript</a>-<a data-type="index:locator" href="#calibre_link-205" class="calibre9">Things
                      to Remember</a></li>
                </ul>
              </li>
              <li class="calibre11"><span data-type="index-term" class="calibre">declaration merging</span>, <a
                  data-type="index:locator" href="#calibre_link-206" class="calibre9">Item 13: Know the Differences
                  Between type and interface</a>, <a data-type="index:locator" href="#calibre_link-207"
                  class="calibre9">Item 43: Prefer Type-Safe Approaches to Monkey Patching</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">declared types</span>, <a
                  data-type="index:locator" href="#calibre_link-208" class="calibre9">Runtime Types May Not Be the Same
                  as Declared Types</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">decorators</span>, <a
                  data-type="index:locator" href="#calibre_link-209" class="calibre9">Decorators</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">DefinitelyTyped</span>, <a
                  data-type="index:locator" href="#calibre_link-210" class="calibre9">Item 45: Put TypeScript and @types
                  in devDependencies</a>, <a data-type="index:locator" href="#calibre_link-211" class="calibre9">Item
                  46: Understand the Three Versions Involved in Type Declarations</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">dependencies</span>, <a
                  data-type="index:locator" href="#calibre_link-212" class="calibre9">Item 45: Put TypeScript and @types
                  in devDependencies</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">destructuring assignment</span>, <a
                  data-type="index:locator" href="#calibre_link-213" class="calibre9">Use Compact Object Literals and
                  Destructuring Assignment</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">devDependencies</span>, <a
                  data-type="index:locator" href="#calibre_link-214" class="calibre9">Item 45: Put TypeScript and @types
                  in devDependencies</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">discriminated unions</span> (<span
                  data-gentext="see" class="calibre">see</span> tagged unions)</li>
              <li class="calibre11"><span data-type="index-term" class="calibre">documentation, type information
                  in</span>, <a data-type="index:locator" href="#calibre_link-215" class="calibre9">Item 30: Don’t
                  Repeat Type Information in Documentation</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">DOM hierarchy</span>, <a
                  data-type="index:locator" href="#calibre_link-216" class="calibre9">Item 55: Understand the DOM
                  hierarchy</a>-<a data-type="index:locator" href="#calibre_link-217" class="calibre9">Things to
                  Remember</a>, <a data-type="index:locator" href="#calibre_link-218" class="calibre9">DOM Issues</a>
              </li>
              <li class="calibre11"><span data-type="index-term" class="calibre">domain of a type</span>, <a
                  data-type="index:locator" href="#calibre_link-219" class="calibre9">Item 7: Think of Types as Sets of
                  Values</a>-<a data-type="index:locator" href="#calibre_link-220" class="calibre9">Things to
                  Remember</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">double assertion</span>, <a
                  data-type="index:locator" href="#calibre_link-221" class="calibre9">Item 42: Use unknown Instead of
                  any for Values with an Unknown Type</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">DRY (don’t repeat yourself)
                  principle</span>, <a data-type="index:locator" href="#calibre_link-222" class="calibre9">Item 14: Use
                  Type Operations and Generics to Avoid Repeating Yourself</a>-<a data-type="index:locator"
                  href="#calibre_link-223" class="calibre9">Things to Remember</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">dtslint</span>, <a
                  data-type="index:locator" href="#calibre_link-224" class="calibre9">Item 52: Be Aware of the Pitfalls
                  of Testing Types</a>, <a data-type="index:locator" href="#calibre_link-225" class="calibre9">Item 52:
                  Be Aware of the Pitfalls of Testing Types</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">duck typing</span>, <a
                  data-type="index:locator" href="#calibre_link-226" class="calibre9">Item 4: Get Comfortable with
                  Structural Typing</a>-<a data-type="index:locator" href="#calibre_link-227" class="calibre9">Things to
                  Remember</a>, <a data-type="index:locator" href="#calibre_link-228" class="calibre9">Item 37: Consider
                  “Brands” for Nominal Typing</a>-<a data-type="index:locator" href="#calibre_link-229"
                  class="calibre9">Things to Remember</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">dygraph.js</span>, <a
                  data-type="index:locator" href="#calibre_link-230" class="calibre9">Undeclared Class Members</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">dynamic data</span>, <a
                  data-type="index:locator" href="#calibre_link-231" class="calibre9">Item 15: Use Index Signatures for
                  Dynamic Data</a>-<a data-type="index:locator" href="#calibre_link-232" class="calibre9">Things to
                  Remember</a></li>
            </ul>
          </div>
          <div data-type="indexdiv" class="praise">
            <h3 class="calibre54">E</h3>
            <ul class="calibre55">
              <li class="calibre11"><span data-type="index-term" class="calibre">ECMAScript</span>, <a
                  data-type="index:locator" href="#calibre_link-233" class="calibre9">Item 53: Prefer ECMAScript
                  Features to TypeScript Features</a>-<a data-type="index:locator" href="#calibre_link-234"
                  class="calibre9">Things to Remember</a>, <a data-type="index:locator" href="#calibre_link-235"
                  class="calibre9">Use ECMAScript Modules</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">editors, using to interrogate and
                  explore type system</span>, <a data-type="index:locator" href="#calibre_link-236"
                  class="calibre9">Item 6: Use Your Editor to Interrogate and Explore the Type System</a>-<a
                  data-type="index:locator" href="#calibre_link-237" class="calibre9">Things to Remember</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">Element</span>, <a
                  data-type="index:locator" href="#calibre_link-238" class="calibre9">Item 55: Understand the DOM
                  hierarchy</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">enums (enumerations)</span>, <a
                  data-type="index:locator" href="#calibre_link-239" class="calibre9">Item 8: Know How to Tell Whether a
                  Symbol Is in the Type Space or Value Space</a>, <a data-type="index:locator" href="#calibre_link-240"
                  class="calibre9">Enums</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">equality</span>, <a
                  data-type="index:locator" href="#calibre_link-241" class="calibre9">Item 52: Be Aware of the Pitfalls
                  of Testing Types</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">ES2015</span>
                <ul class="calibre56">
                  <li class="calibre11"><span data-type="index-term" class="calibre">class keyword</span>, <a
                      data-type="index:locator" href="#calibre_link-242" class="calibre9">Use Classes Instead of
                      Prototypes</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">Convert function</span>, <a
                      data-type="index:locator" href="#calibre_link-243" class="calibre9">Use Classes Instead of
                      Prototypes</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">keys in</span>, <a
                      data-type="index:locator" href="#calibre_link-244" class="calibre9">Item 16: Prefer Arrays,
                      Tuples, and ArrayLike to number Index Signatures</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">merging and</span>, <a
                      data-type="index:locator" href="#calibre_link-245" class="calibre9">Item 13: Know the Differences
                      Between type and interface</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">Promises in</span>, <a
                      data-type="index:locator" href="#calibre_link-246" class="calibre9">Item 25: Use async Functions
                      Instead of Callbacks for Asynchronous Code</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">symbol primitive</span>, <a
                      data-type="index:locator" href="#calibre_link-247" class="calibre9">Item 10: Avoid Object Wrapper
                      Types (String, Number, Boolean, Symbol, BigInt)</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">writing modern JavaScript</span>,
                    <a data-type="index:locator" href="#calibre_link-248" class="calibre9">Item 58: Write Modern
                      JavaScript</a>
                  </li>
                </ul>
              </li>
              <li class="calibre11"><span data-type="index-term" class="calibre">ES2017</span>, <a
                  data-type="index:locator" href="#calibre_link-249" class="calibre9">Item 25: Use async Functions
                  Instead of Callbacks for Asynchronous Code</a>, <a data-type="index:locator" href="#calibre_link-250"
                  class="calibre9">Item 56: Don’t Rely on Private to Hide Information</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">ES5</span>
                <ul class="calibre56">
                  <li class="calibre11"><span data-type="index-term" class="calibre">async and await in</span>, <a
                      data-type="index:locator" href="#calibre_link-251" class="calibre9">Item 25: Use async Functions
                      Instead of Callbacks for Asynchronous Code</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">generator functions</span>, <a
                      data-type="index:locator" href="#calibre_link-252" class="calibre9">TypeScript Types Have No
                      Effect on Runtime Performance</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">merging and</span>, <a
                      data-type="index:locator" href="#calibre_link-253" class="calibre9">Item 13: Know the Differences
                      Between type and interface</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">numeric keys and</span>, <a
                      data-type="index:locator" href="#calibre_link-254" class="calibre9">Item 16: Prefer Arrays,
                      Tuples, and ArrayLike to number Index Signatures</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">strict mode</span>, <a
                      data-type="index:locator" href="#calibre_link-255" class="calibre9">Don’t Put use strict in
                      TypeScript</a></li>
                </ul>
              </li>
              <li class="calibre11"><span data-type="index-term" class="calibre">eslint</span>, <a
                  data-type="index:locator" href="#calibre_link-256" class="calibre9">Item 19: Avoid Cluttering Your
                  Code with Inferable Types</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">Event</span>, <a
                  data-type="index:locator" href="#calibre_link-257" class="calibre9">Item 55: Understand the DOM
                  hierarchy</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">EventTarget</span>, <a
                  data-type="index:locator" href="#calibre_link-258" class="calibre9">Item 55: Understand the DOM
                  hierarchy</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">evolving any</span>, <a
                  data-type="index:locator" href="#calibre_link-259" class="calibre9">Item 41: Understand Evolving
                  any</a>-<a data-type="index:locator" href="#calibre_link-260" class="calibre9">Things to Remember</a>
              </li>
              <li class="calibre11"><span data-type="index-term" class="calibre">excess property checking</span>
                <ul class="calibre56">
                  <li class="calibre11"><span data-type="index-term" class="calibre">limits of</span>, <a
                      data-type="index:locator" href="#calibre_link-261" class="calibre9">Item 11: Recognize the Limits
                      of Excess Property Checking</a>-<a data-type="index:locator" href="#calibre_link-262"
                      class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">type declaration and</span>, <a
                      data-type="index:locator" href="#calibre_link-263" class="calibre9">Item 9: Prefer Type
                      Declarations to Type Assertions</a></li>
                </ul>
              </li>
              <li class="calibre11"><span data-type="index-term" class="calibre">explicitly typed languages</span>, <a
                  data-type="index:locator" href="#calibre_link-264" class="calibre9">Type Inference</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">extends</span>, <a
                  data-type="index:locator" href="#calibre_link-265" class="calibre9">Item 7: Think of Types as Sets of
                  Values</a>, <a data-type="index:locator" href="#calibre_link-266" class="calibre9">Item 8: Know How to
                  Tell Whether a Symbol Is in the Type Space or Value Space</a>, <a data-type="index:locator"
                  href="#calibre_link-267" class="calibre9">Item 14: Use Type Operations and Generics to Avoid Repeating
                  Yourself</a></li>
            </ul>
          </div>
          <div data-type="indexdiv" class="praise">
            <h3 class="calibre54">F</h3>
            <ul class="calibre55">
              <li class="calibre11"><span data-type="index-term" class="calibre">flatMap</span>, <a
                  data-type="index:locator" href="#calibre_link-268" class="calibre9">Item 27: Use Functional Constructs
                  and Libraries to Help Types Flow</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">for(;;)</span>, <a
                  data-type="index:locator" href="#calibre_link-269" class="calibre9">Item 16: Prefer Arrays, Tuples,
                  and ArrayLike to number Index Signatures</a>, <a data-type="index:locator" href="#calibre_link-270"
                  class="calibre9">Use for-of or Array Methods Instead of for(;;)</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">for-in loops</span>, <a
                  data-type="index:locator" href="#calibre_link-271" class="calibre9">Item 16: Prefer Arrays, Tuples,
                  and ArrayLike to number Index Signatures</a>, <a data-type="index:locator" href="#calibre_link-272"
                  class="calibre9">Item 54: Know How to Iterate Over Objects</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">for-of</span>, <a
                  data-type="index:locator" href="#calibre_link-273" class="calibre9">Item 16: Prefer Arrays, Tuples,
                  and ArrayLike to number Index Signatures</a>, <a data-type="index:locator" href="#calibre_link-274"
                  class="calibre9">Use for-of or Array Methods Instead of for(;;)</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">function expressions</span>, <a
                  data-type="index:locator" href="#calibre_link-275" class="calibre9">Prefer Arrow Functions Over
                  Function Expressions</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">functions</span>
                <ul class="calibre56">
                  <li class="calibre11"><span data-type="index-term" class="calibre">applying type annotations to
                      function expressions</span>, <a data-type="index:locator" href="#calibre_link-276"
                      class="calibre9">Item 12: Apply Types to Entire Function Expressions When Possible</a>-<a
                      data-type="index:locator" href="#calibre_link-277" class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">arrow functions</span>, <a
                      data-type="index:locator" href="#calibre_link-278" class="calibre9">Item 9: Prefer Type
                      Declarations to Type Assertions</a>, <a data-type="index:locator" href="#calibre_link-279"
                      class="calibre9">Prefer Arrow Functions Over Function Expressions</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">avoid returning any types
                      from</span>, <a data-type="index:locator" href="#calibre_link-280" class="calibre9">Item 38: Use
                      the Narrowest Possible Scope for any Types</a>-<a data-type="index:locator"
                      href="#calibre_link-281" class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">default function parameters</span>,
                    <a data-type="index:locator" href="#calibre_link-282" class="calibre9">Use Default Function
                      Parameters</a>
                  </li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">hiding unsafe type assertions
                      in</span>, <a data-type="index:locator" href="#calibre_link-283" class="calibre9">Item 40: Hide
                      Unsafe Type Assertions in Well-Typed Functions</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">inspecting with editors</span>, <a
                      data-type="index:locator" href="#calibre_link-284" class="calibre9">Item 6: Use Your Editor to
                      Interrogate and Explore the Type System</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">overloading</span>, <a
                      data-type="index:locator" href="#calibre_link-285" class="calibre9">You Cannot Overload a Function
                      Based on TypeScript Types</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">robustness principle</span>, <a
                      data-type="index:locator" href="#calibre_link-286" class="calibre9">Item 29: Be Liberal in What
                      You Accept and Strict in What You Produce</a>-<a data-type="index:locator"
                      href="#calibre_link-287" class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">testing inferred types of
                      callbacks</span>, <a data-type="index:locator" href="#calibre_link-288" class="calibre9">Item 52:
                      Be Aware of the Pitfalls of Testing Types</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">utility libraries versus
                      hand-rolled</span>, <a data-type="index:locator" href="#calibre_link-289" class="calibre9">Item
                      27: Use Functional Constructs and Libraries to Help Types Flow</a>-<a data-type="index:locator"
                      href="#calibre_link-290" class="calibre9">Things to Remember</a></li>
                </ul>
              </li>
            </ul>
          </div>
          <div data-type="indexdiv" class="praise">
            <h3 class="calibre54">G</h3>
            <ul class="calibre55">
              <li class="calibre11"><span data-type="index-term" class="calibre">generic types</span>, <a
                  data-type="index:locator" href="#calibre_link-291" class="calibre9">Item 14: Use Type Operations and
                  Generics to Avoid Repeating Yourself</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">GeoJSON</span>, <a
                  data-type="index:locator" href="#calibre_link-292" class="calibre9">Item 29: Be Liberal in What You
                  Accept and Strict in What You Produce</a>, <a data-type="index:locator" href="#calibre_link-293"
                  class="calibre9">Item 34: Prefer Incomplete Types to Inaccurate Types</a>-<a data-type="index:locator"
                  href="#calibre_link-294" class="calibre9">Item 34: Prefer Incomplete Types to Inaccurate Types</a>, <a
                  data-type="index:locator" href="#calibre_link-295" class="calibre9">Item 35: Generate Types from APIs
                  and Specs, Not Data</a>-<a data-type="index:locator" href="#calibre_link-296" class="calibre9">Things
                  to Remember</a>, <a data-type="index:locator" href="#calibre_link-297" class="calibre9">Item 42: Use
                  unknown Instead of any for Values with an Unknown Type</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">Geometry</span>, <a
                  data-type="index:locator" href="#calibre_link-298" class="calibre9">Item 34: Prefer Incomplete Types
                  to Inaccurate Types</a>, <a data-type="index:locator" href="#calibre_link-299" class="calibre9">Item
                  35: Generate Types from APIs and Specs, Not Data</a>, <a data-type="index:locator"
                  href="#calibre_link-300" class="calibre9">Item 42: Use unknown Instead of any for Values with an
                  Unknown Type</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">global variables</span>, <a
                  data-type="index:locator" href="#calibre_link-301" class="calibre9">Item 43: Prefer Type-Safe
                  Approaches to Monkey Patching</a>, <a data-type="index:locator" href="#calibre_link-302"
                  class="calibre9">Undeclared Globals</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">Griffin, Blake</span>, <a
                  data-type="index:locator" href="#calibre_link-303" class="calibre9">Item 27: Use Functional Constructs
                  and Libraries to Help Types Flow</a></li>
            </ul>
          </div>
          <div data-type="indexdiv" class="praise">
            <h3 class="calibre54">H</h3>
            <ul class="calibre55">
              <li class="calibre11"><span data-type="index-term" class="calibre">Hejlsberg, Anders</span>, <a
                  data-type="index:locator" href="#calibre_link-304" class="calibre9">Item 26: Understand How Context Is
                  Used in Type Inference</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">Hopper, Grace</span>, <a
                  data-type="index:locator" href="#calibre_link-305" class="calibre9">Item 59: Use @ts-check and JSDoc
                  to Experiment with TypeScript</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">HTMLElement</span>, <a
                  data-type="index:locator" href="#calibre_link-306" class="calibre9">Item 55: Understand the DOM
                  hierarchy</a></li>
            </ul>
          </div>
          <div data-type="indexdiv" class="praise">
            <h3 class="calibre54">I</h3>
            <ul class="calibre55">
              <li class="calibre11"><span data-type="index-term" class="calibre">implicit anys</span>, <a
                  data-type="index:locator" href="#calibre_link-307" class="calibre9">Item 2: Know Which TypeScript
                  Options You’re Using</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">in construct</span>
                <ul class="calibre56">
                  <li class="calibre11"><span data-type="index-term" class="calibre">in (for-in)</span>, <a
                      data-type="index:locator" href="#calibre_link-308" class="calibre9">Item 16: Prefer Arrays,
                      Tuples, and ArrayLike to number Index Signatures</a>, <a data-type="index:locator"
                      href="#calibre_link-309" class="calibre9">Item 54: Know How to Iterate Over Objects</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">in (mapped type)</span>, <a
                      data-type="index:locator" href="#calibre_link-310" class="calibre9">Item 14: Use Type Operations
                      and Generics to Avoid Repeating Yourself</a>, <a data-type="index:locator"
                      href="#calibre_link-311" class="calibre9">Item 15: Use Index Signatures for Dynamic Data</a>, <a
                      data-type="index:locator" href="#calibre_link-312" class="calibre9">Item 18: Use Mapped Types to
                      Keep Values in Sync</a>-<a data-type="index:locator" href="#calibre_link-313"
                      class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">value versus type space
                      meanings</span>, <a data-type="index:locator" href="#calibre_link-314" class="calibre9">Item 8:
                      Know How to Tell Whether a Symbol Is in the Type Space or Value Space</a></li>
                </ul>
              </li>
              <li class="calibre11"><span data-type="index-term" class="calibre">index signatures</span>
                <ul class="calibre56">
                  <li class="calibre11"><span data-type="index-term" class="calibre">versus arrays, tuples, and
                      ArrayLike</span>, <a data-type="index:locator" href="#calibre_link-315" class="calibre9">Item 16:
                      Prefer Arrays, Tuples, and ArrayLike to number Index Signatures</a>-<a data-type="index:locator"
                      href="#calibre_link-316" class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">for dynamic data</span>, <a
                      data-type="index:locator" href="#calibre_link-317" class="calibre9">Item 15: Use Index Signatures
                      for Dynamic Data</a>-<a data-type="index:locator" href="#calibre_link-318" class="calibre9">Things
                      to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">readonly and</span>, <a
                      data-type="index:locator" href="#calibre_link-319" class="calibre9">Item 17: Use readonly to Avoid
                      Errors Associated with Mutation</a></li>
                </ul>
              </li>
              <li class="calibre11"><span data-type="index-term" class="calibre">indexing</span>, <a
                  data-type="index:locator" href="#calibre_link-320" class="calibre9">Item 14: Use Type Operations and
                  Generics to Avoid Repeating Yourself</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">inferable types</span>, <a
                  data-type="index:locator" href="#calibre_link-321" class="calibre9">Item 19: Avoid Cluttering Your
                  Code with Inferable Types</a>-<a data-type="index:locator" href="#calibre_link-322"
                  class="calibre9">Things to Remember</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">inferringPick</span>, <a
                  data-type="index:locator" href="#calibre_link-323" class="calibre9">Item 14: Use Type Operations and
                  Generics to Avoid Repeating Yourself</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">interface construct</span>
                <ul class="calibre56">
                  <li class="calibre11"><span data-type="index-term" class="calibre">as alternative to index
                      signatures</span>, <a data-type="index:locator" href="#calibre_link-324" class="calibre9">Item 15:
                      Use Index Signatures for Dynamic Data</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">existence in type space</span>, <a
                      data-type="index:locator" href="#calibre_link-325" class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">type versus interface</span>, <a
                      data-type="index:locator" href="#calibre_link-326" class="calibre9">Item 13: Know the Differences
                      Between type and interface</a>-<a data-type="index:locator" href="#calibre_link-327"
                      class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">unions of interfaces versus
                      interfaces of unions</span>, <a data-type="index:locator" href="#calibre_link-328"
                      class="calibre9">Item 32: Prefer Unions of Interfaces to Interfaces of Unions</a>-<a
                      data-type="index:locator" href="#calibre_link-329" class="calibre9">Things to Remember</a></li>
                </ul>
              </li>
              <li class="calibre11"><span data-type="index-term" class="calibre">invalid states</span>, <a
                  data-type="index:locator" href="#calibre_link-330" class="calibre9">Item 28: Prefer Types That Always
                  Represent Valid States</a>-<a data-type="index:locator" href="#calibre_link-331"
                  class="calibre9">Things to Remember</a></li>
            </ul>
          </div>
          <div data-type="indexdiv" class="praise">
            <h3 class="calibre54">J</h3>
            <ul class="calibre55">
              <li class="calibre11"><span data-type="index-term" class="calibre">James, LeBron</span>, <a
                  data-type="index:locator" href="#calibre_link-332" class="calibre9">Item 27: Use Functional Constructs
                  and Libraries to Help Types Flow</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">Java</span>
                <ul class="calibre56">
                  <li class="calibre11"><span data-type="index-term" class="calibre">addition of var</span>, <a
                      data-type="index:locator" href="#calibre_link-333" class="calibre9">Type Inference</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">declaring parameters in</span>, <a
                      data-type="index:locator" href="#calibre_link-334" class="calibre9">Item 4: Get Comfortable with
                      Structural Typing</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">hashable objects in</span>, <a
                      data-type="index:locator" href="#calibre_link-335" class="calibre9">Item 16: Prefer Arrays,
                      Tuples, and ArrayLike to number Index Signatures</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">rewriting code in</span>, <a
                      data-type="index:locator" href="#calibre_link-336" class="calibre9">Item 1: Understand the
                      Relationship Between TypeScript and JavaScript</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">standard libraries in</span>, <a
                      data-type="index:locator" href="#calibre_link-337" class="calibre9">Item 27: Use Functional
                      Constructs and Libraries to Help Types Flow</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">String objects</span>, <a
                      data-type="index:locator" href="#calibre_link-338" class="calibre9">Item 10: Avoid Object Wrapper
                      Types (String, Number, Boolean, Symbol, BigInt)</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">type checking and output in</span>,
                    <a data-type="index:locator" href="#calibre_link-339" class="calibre9">Code with Type Errors Can
                      Produce Output</a>
                  </li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">versus TypeScript</span>, <a
                      data-type="index:locator" href="#calibre_link-340" class="calibre9">Getting to Know
                      TypeScript</a>, <a data-type="index:locator" href="#calibre_link-341" class="calibre9">Item 27:
                      Use Functional Constructs and Libraries to Help Types Flow</a></li>
                </ul>
              </li>
              <li class="calibre11"><span data-type="index-term" class="calibre">JavaScript</span>
                <ul class="calibre56">
                  <li class="calibre11"><span data-type="index-term" class="calibre">duck typing</span>, <a
                      data-type="index:locator" href="#calibre_link-342" class="calibre9">Item 4: Get Comfortable with
                      Structural Typing</a>-<a data-type="index:locator" href="#calibre_link-343"
                      class="calibre9">Things to Remember</a>, <a data-type="index:locator" href="#calibre_link-344"
                      class="calibre9">Item 37: Consider “Brands” for Nominal Typing</a>-<a data-type="index:locator"
                      href="#calibre_link-345" class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">function statements versus function
                      expressions</span>, <a data-type="index:locator" href="#calibre_link-346" class="calibre9">Item
                      12: Apply Types to Entire Function Expressions When Possible</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">implicit type coercions in</span>,
                    <a data-type="index:locator" href="#calibre_link-347" class="calibre9">Item 16: Prefer Arrays,
                      Tuples, and ArrayLike to number Index Signatures</a>
                  </li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">migrating to TypeScript</span>, <a
                      data-type="index:locator" href="#calibre_link-348" class="calibre9">Item 1: Understand the
                      Relationship Between TypeScript and JavaScript</a>, <a data-type="index:locator"
                      href="#calibre_link-349" class="calibre9">Migrating to TypeScript</a>-<a data-type="index:locator"
                      href="#calibre_link-350" class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">mixing with TypeScript</span>, <a
                      data-type="index:locator" href="#calibre_link-351" class="calibre9">Item 60: Use allowJs to Mix
                      TypeScript and JavaScript</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">objects in</span>, <a
                      data-type="index:locator" href="#calibre_link-352" class="calibre9">Item 16: Prefer Arrays,
                      Tuples, and ArrayLike to number Index Signatures</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">open classes in</span>, <a
                      data-type="index:locator" href="#calibre_link-353" class="calibre9">Item 43: Prefer Type-Safe
                      Approaches to Monkey Patching</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">relationship to TypeScript</span>,
                    <a data-type="index:locator" href="#calibre_link-354" class="calibre9">Item 1: Understand the
                      Relationship Between TypeScript and JavaScript</a>-<a data-type="index:locator"
                      href="#calibre_link-355" class="calibre9">Things to Remember</a>, <a data-type="index:locator"
                      href="#calibre_link-356" class="calibre9">Item 53: Prefer ECMAScript Features to TypeScript
                      Features</a>
                  </li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">this keyword</span>, <a
                      data-type="index:locator" href="#calibre_link-357" class="calibre9">Item 49: Provide a Type for
                      this in Callbacks</a>, <a data-type="index:locator" href="#calibre_link-358"
                      class="calibre9">Prefer Arrow Functions Over Function Expressions</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">writing modern</span>, <a
                      data-type="index:locator" href="#calibre_link-359" class="calibre9">Item 58: Write Modern
                      JavaScript</a>-<a data-type="index:locator" href="#calibre_link-360" class="calibre9">Things to
                      Remember</a></li>
                </ul>
              </li>
              <li class="calibre11"><span data-type="index-term" class="calibre">jQuery</span>
                <ul class="calibre56">
                  <li class="calibre11"><span data-type="index-term" class="calibre">dependencies</span>, <a
                      data-type="index:locator" href="#calibre_link-361" class="calibre9">Item 45: Put TypeScript and
                      @types in devDependencies</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">interacting with DOM</span>, <a
                      data-type="index:locator" href="#calibre_link-362" class="calibre9">Item 27: Use Functional
                      Constructs and Libraries to Help Types Flow</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">type declarations for</span>, <a
                      data-type="index:locator" href="#calibre_link-363" class="calibre9">Unknown Libraries</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">type-safe approaches versus
                      monkey-patching</span>, <a data-type="index:locator" href="#calibre_link-364"
                      class="calibre9">Item 43: Prefer Type-Safe Approaches to Monkey Patching</a></li>
                </ul>
              </li>
              <li class="calibre11"><span data-type="index-term" class="calibre">JSDoc-style comments</span>, <a
                  data-type="index:locator" href="#calibre_link-365" class="calibre9">Item 48: Use TSDoc for API
                  Comments</a>, <a data-type="index:locator" href="#calibre_link-366" class="calibre9">Item 59: Use
                  @ts-check and JSDoc to Experiment with TypeScript</a>-<a data-type="index:locator"
                  href="#calibre_link-367" class="calibre9">Things to Remember</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">JSON</span>, <a
                  data-type="index:locator" href="#calibre_link-368" class="calibre9">Item 12: Apply Types to Entire
                  Function Expressions When Possible</a>, <a data-type="index:locator" href="#calibre_link-369"
                  class="calibre9">Item 34: Prefer Incomplete Types to Inaccurate Types</a>, <a
                  data-type="index:locator" href="#calibre_link-370" class="calibre9">Item 42: Use unknown Instead of
                  any for Values with an Unknown Type</a>, <a data-type="index:locator" href="#calibre_link-371"
                  class="calibre9">Item 42: Use unknown Instead of any for Values with an Unknown Type</a></li>
            </ul>
          </div>
          <div data-type="indexdiv" class="praise">
            <h3 class="calibre54">K</h3>
            <ul class="calibre55">
              <li class="calibre11"><span data-type="index-term" class="calibre">Karlton, Phil</span>, <a
                  data-type="index:locator" href="#calibre_link-372" class="calibre9">Item 36: Name Types Using the
                  Language of Your Problem Domain</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">keyof</span>, <a
                  data-type="index:locator" href="#calibre_link-373" class="calibre9">Item 14: Use Type Operations and
                  Generics to Avoid Repeating Yourself</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">keyof T</span>, <a
                  data-type="index:locator" href="#calibre_link-374" class="calibre9">Item 33: Prefer More Precise
                  Alternatives to String Types</a></li>
            </ul>
          </div>
          <div data-type="indexdiv" class="praise">
            <h3 class="calibre54">L</h3>
            <ul class="calibre55">
              <li class="calibre11"><span data-type="index-term" class="calibre">language services</span>
                <ul class="calibre56">
                  <li class="calibre11"><span data-type="index-term" class="calibre">commenting convention supported
                      by</span>, <a data-type="index:locator" href="#calibre_link-375" class="calibre9">Item 48: Use
                      TSDoc for API Comments</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">components of</span>, <a
                      data-type="index:locator" href="#calibre_link-376" class="calibre9">Item 6: Use Your Editor to
                      Interrogate and Explore the Type System</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">drawbacks of any types</span>, <a
                      data-type="index:locator" href="#calibre_link-377" class="calibre9">There Are No Language Services
                      for any Types</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">navigating libraries and type
                      declarations</span>, <a data-type="index:locator" href="#calibre_link-378" class="calibre9">Item
                      6: Use Your Editor to Interrogate and Explore the Type System</a></li>
                </ul>
              </li>
              <li class="calibre11"><span data-type="index-term" class="calibre">let k: keyof T</span>, <a
                  data-type="index:locator" href="#calibre_link-379" class="calibre9">Item 54: Know How to Iterate Over
                  Objects</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">let/const</span>, <a
                  data-type="index:locator" href="#calibre_link-380" class="calibre9">Use let/const Instead of var</a>
              </li>
              <li class="calibre11"><span data-type="index-term" class="calibre">libraries</span>
                <ul class="calibre56">
                  <li class="calibre11"><span data-type="index-term" class="calibre">navigating libraries and type
                      declarations</span>, <a data-type="index:locator" href="#calibre_link-381" class="calibre9">Item
                      6: Use Your Editor to Interrogate and Explore the Type System</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">unknown third-party</span>, <a
                      data-type="index:locator" href="#calibre_link-382" class="calibre9">Unknown Libraries</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">using utility libraries</span>, <a
                      data-type="index:locator" href="#calibre_link-383" class="calibre9">Item 27: Use Functional
                      Constructs and Libraries to Help Types Flow</a>-<a data-type="index:locator"
                      href="#calibre_link-384" class="calibre9">Things to Remember</a></li>
                </ul>
              </li>
              <li class="calibre11"><span data-type="index-term" class="calibre">Lodash library</span>, <a
                  data-type="index:locator" href="#calibre_link-385" class="calibre9">Item 27: Use Functional Constructs
                  and Libraries to Help Types Flow</a>-<a data-type="index:locator" href="#calibre_link-386"
                  class="calibre9">Things to Remember</a>, <a data-type="index:locator" href="#calibre_link-387"
                  class="calibre9">Item 45: Put TypeScript and @types in devDependencies</a>-<a
                  data-type="index:locator" href="#calibre_link-388" class="calibre9">Item 46: Understand the Three
                  Versions Involved in Type Declarations</a>, <a data-type="index:locator" href="#calibre_link-389"
                  class="calibre9">Item 52: Be Aware of the Pitfalls of Testing Types</a>, <a data-type="index:locator"
                  href="#calibre_link-390" class="calibre9">Item 52: Be Aware of the Pitfalls of Testing Types</a></li>
            </ul>
          </div>
          <div data-type="indexdiv" class="praise">
            <h3 class="calibre54">M</h3>
            <ul class="calibre55">
              <li class="calibre11"><span data-type="index-term" class="calibre">Mapbox library</span>, <a
                  data-type="index:locator" href="#calibre_link-391" class="calibre9">Item 34: Prefer Incomplete Types
                  to Inaccurate Types</a>, <a data-type="index:locator" href="#calibre_link-392" class="calibre9">Item
                  34: Prefer Incomplete Types to Inaccurate Types</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">mapped types</span>, <a
                  data-type="index:locator" href="#calibre_link-393" class="calibre9">Item 14: Use Type Operations and
                  Generics to Avoid Repeating Yourself</a>, <a data-type="index:locator" href="#calibre_link-394"
                  class="calibre9">Item 15: Use Index Signatures for Dynamic Data</a>, <a data-type="index:locator"
                  href="#calibre_link-395" class="calibre9">Item 18: Use Mapped Types to Keep Values in Sync</a>-<a
                  data-type="index:locator" href="#calibre_link-396" class="calibre9">Things to Remember</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">migration</span>
                <ul class="calibre56">
                  <li class="calibre11"><span data-type="index-term" class="calibre">converting module by module</span>,
                    <a data-type="index:locator" href="#calibre_link-397" class="calibre9">Item 61: Convert Module by
                      Module Up Your Dependency Graph</a>-<a data-type="index:locator" href="#calibre_link-398"
                      class="calibre9">Things to Remember</a>
                  </li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">experimenting with
                      TypeScript</span>, <a data-type="index:locator" href="#calibre_link-399" class="calibre9">Item 59:
                      Use @ts-check and JSDoc to Experiment with TypeScript</a>-<a data-type="index:locator"
                      href="#calibre_link-400" class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">mixing TypeScript with
                      JavaScript</span>, <a data-type="index:locator" href="#calibre_link-401" class="calibre9">Item 60:
                      Use allowJs to Mix TypeScript and JavaScript</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">noImplicitAny</span>, <a
                      data-type="index:locator" href="#calibre_link-402" class="calibre9">Item 62: Don’t Consider
                      Migration Complete Until You Enable noImplicitAny</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">overview of</span>, <a
                      data-type="index:locator" href="#calibre_link-403" class="calibre9">Migrating to TypeScript</a>
                  </li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">writing modern JavaScript</span>,
                    <a data-type="index:locator" href="#calibre_link-404" class="calibre9">Item 58: Write Modern
                      JavaScript</a>-<a data-type="index:locator" href="#calibre_link-405" class="calibre9">Things to
                      Remember</a>
                  </li>
                </ul>
              </li>
              <li class="calibre11"><span data-type="index-term" class="calibre">MouseEvent</span>, <a
                  data-type="index:locator" href="#calibre_link-406" class="calibre9">Item 55: Understand the DOM
                  hierarchy</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">mutations, avoiding errors associated
                  with</span>, <a data-type="index:locator" href="#calibre_link-407" class="calibre9">Item 17: Use
                  readonly to Avoid Errors Associated with Mutation</a>-<a data-type="index:locator"
                  href="#calibre_link-408" class="calibre9">Things to Remember</a></li>
            </ul>
          </div>
          <div data-type="indexdiv" class="praise">
            <h3 class="calibre54">N</h3>
            <ul class="calibre55">
              <li class="calibre11"><span data-type="index-term" class="calibre">named types</span>, <a
                  data-type="index:locator" href="#calibre_link-409" class="calibre9">Item 33: Prefer More Precise
                  Alternatives to String Types</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">names and naming</span>, <a
                  data-type="index:locator" href="#calibre_link-410" class="calibre9">Item 36: Name Types Using the
                  Language of Your Problem Domain</a>-<a data-type="index:locator" href="#calibre_link-411"
                  class="calibre9">Things to Remember</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">namespace</span>
                <ul class="calibre56">
                  <li class="calibre11"><span data-type="index-term" class="calibre">triple-slash imports and</span>, <a
                      data-type="index:locator" href="#calibre_link-412" class="calibre9">Namespaces and Triple-Slash
                      Imports</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">type declarations and</span>, <a
                      data-type="index:locator" href="#calibre_link-413" class="calibre9">Item 46: Understand the Three
                      Versions Involved in Type Declarations</a></li>
                </ul>
              </li>
              <li class="calibre11"><span data-type="index-term" class="calibre">narrowing</span>, <a
                  data-type="index:locator" href="#calibre_link-414" class="calibre9">Item 22: Understand Type
                  Narrowing</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">never type</span>, <a
                  data-type="index:locator" href="#calibre_link-415" class="calibre9">Item 42: Use unknown Instead of
                  any for Values with an Unknown Type</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">Node</span>, <a
                  data-type="index:locator" href="#calibre_link-416" class="calibre9">Item 55: Understand the DOM
                  hierarchy</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">Node Package Manager (npm), dependency
                  distinctions in</span>, <a data-type="index:locator" href="#calibre_link-417" class="calibre9">Item
                  45: Put TypeScript and @types in devDependencies</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">NodeJS</span>, <a
                  data-type="index:locator" href="#calibre_link-418" class="calibre9">Item 51: Mirror Types to Sever
                  Dependencies</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">noImplicitAny</span>, <a
                  data-type="index:locator" href="#calibre_link-419" class="calibre9">Item 2: Know Which TypeScript
                  Options You’re Using</a>-<a data-type="index:locator" href="#calibre_link-420" class="calibre9">Things
                  to Remember</a>, <a data-type="index:locator" href="#calibre_link-421" class="calibre9">Item 44: Track
                  Your Type Coverage to Prevent Regressions in Type Safety</a>, <a data-type="index:locator"
                  href="#calibre_link-422" class="calibre9">Item 62: Don’t Consider Migration Complete Until You Enable
                  noImplicitAny</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">noImplicitThis</span>, <a
                  data-type="index:locator" href="#calibre_link-423" class="calibre9">Item 2: Know Which TypeScript
                  Options You’re Using</a>, <a data-type="index:locator" href="#calibre_link-424"
                  class="calibre9">Prefer Arrow Functions Over Function Expressions</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">nominal typing</span>, <a
                  data-type="index:locator" href="#calibre_link-425" class="calibre9">Item 37: Consider “Brands” for
                  Nominal Typing</a>-<a data-type="index:locator" href="#calibre_link-426" class="calibre9">Things to
                  Remember</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">non-null assertions</span>, <a
                  data-type="index:locator" href="#calibre_link-427" class="calibre9">Item 9: Prefer Type Declarations
                  to Type Assertions</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">non-null values</span>, <a
                  data-type="index:locator" href="#calibre_link-428" class="calibre9">Item 31: Push Null Values to the
                  Perimeter of Your Types</a>-<a data-type="index:locator" href="#calibre_link-429"
                  class="calibre9">Things to Remember</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">null primitive</span>, <a
                  data-type="index:locator" href="#calibre_link-430" class="calibre9">Item 10: Avoid Object Wrapper
                  Types (String, Number, Boolean, Symbol, BigInt)</a>-<a data-type="index:locator"
                  href="#calibre_link-431" class="calibre9">Things to Remember</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">null values</span>, <a
                  data-type="index:locator" href="#calibre_link-432" class="calibre9">Item 31: Push Null Values to the
                  Perimeter of Your Types</a>-<a data-type="index:locator" href="#calibre_link-433"
                  class="calibre9">Things to Remember</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">number primitives</span>, <a
                  data-type="index:locator" href="#calibre_link-434" class="calibre9">Item 10: Avoid Object Wrapper
                  Types (String, Number, Boolean, Symbol, BigInt)</a>-<a data-type="index:locator"
                  href="#calibre_link-435" class="calibre9">Things to Remember</a></li>
            </ul>
          </div>
          <div data-type="indexdiv" class="praise">
            <h3 class="calibre54">O</h3>
            <ul class="calibre55">
              <li class="calibre11"><span data-type="index-term" class="calibre">object spread operator (…)</span>, <a
                  data-type="index:locator" href="#calibre_link-436" class="calibre9">Item 23: Create Objects All at
                  Once</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">object type</span>, <a
                  data-type="index:locator" href="#calibre_link-437" class="calibre9">Item 42: Use unknown Instead of
                  any for Values with an Unknown Type</a>-<a data-type="index:locator" href="#calibre_link-438"
                  class="calibre9">Things to Remember</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">object wrapper types</span>, <a
                  data-type="index:locator" href="#calibre_link-439" class="calibre9">Item 10: Avoid Object Wrapper
                  Types (String, Number, Boolean, Symbol, BigInt)</a>-<a data-type="index:locator"
                  href="#calibre_link-440" class="calibre9">Things to Remember</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">Object.entries</span>, <a
                  data-type="index:locator" href="#calibre_link-441" class="calibre9">Item 54: Know How to Iterate Over
                  Objects</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">Object.keys</span>, <a
                  data-type="index:locator" href="#calibre_link-442" class="calibre9">Item 4: Get Comfortable with
                  Structural Typing</a>, <a data-type="index:locator" href="#calibre_link-443" class="calibre9">Item 16:
                  Prefer Arrays, Tuples, and ArrayLike to number Index Signatures</a>, <a data-type="index:locator"
                  href="#calibre_link-444" class="calibre9">Item 40: Hide Unsafe Type Assertions in Well-Typed
                  Functions</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">Object.values</span>, <a
                  data-type="index:locator" href="#calibre_link-445" class="calibre9">Item 27: Use Functional Constructs
                  and Libraries to Help Types Flow</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">objects</span>
                <ul class="calibre56">
                  <li class="calibre11"><span data-type="index-term" class="calibre">compact object literals</span>, <a
                      data-type="index:locator" href="#calibre_link-446" class="calibre9">Use Compact Object Literals
                      and Destructuring Assignment</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">creating all at once</span>, <a
                      data-type="index:locator" href="#calibre_link-447" class="calibre9">Item 23: Create Objects All at
                      Once</a>-<a data-type="index:locator" href="#calibre_link-448" class="calibre9">Things to
                      Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">iterating over</span>, <a
                      data-type="index:locator" href="#calibre_link-449" class="calibre9">Item 54: Know How to Iterate
                      Over Objects</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">in JavaScript</span>, <a
                      data-type="index:locator" href="#calibre_link-450" class="calibre9">Item 16: Prefer Arrays,
                      Tuples, and ArrayLike to number Index Signatures</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">type inference and</span>, <a
                      data-type="index:locator" href="#calibre_link-451" class="calibre9">Objects</a></li>
                </ul>
              </li>
              <li class="calibre11"><span data-type="index-term" class="calibre">overloaded declarations</span>, <a
                  data-type="index:locator" href="#calibre_link-452" class="calibre9">Item 50: Prefer Conditional Types
                  to Overloaded Declarations</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">overloading functions</span>, <a
                  data-type="index:locator" href="#calibre_link-453" class="calibre9">You Cannot Overload a Function
                  Based on TypeScript Types</a></li>
            </ul>
          </div>
          <div data-type="indexdiv" class="praise">
            <h3 class="calibre54">P</h3>
            <ul class="calibre55">
              <li class="calibre11"><span data-type="index-term" class="calibre">parameter properties</span>, <a
                  data-type="index:locator" href="#calibre_link-454" class="calibre9">Parameter Properties</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">parameter types</span>, <a
                  data-type="index:locator" href="#calibre_link-455" class="calibre9">Item 29: Be Liberal in What You
                  Accept and Strict in What You Produce</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">Partial type</span>, <a
                  data-type="index:locator" href="#calibre_link-456" class="calibre9">Item 14: Use Type Operations and
                  Generics to Avoid Repeating Yourself</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">Paul, Chris</span>, <a
                  data-type="index:locator" href="#calibre_link-457" class="calibre9">Item 27: Use Functional Constructs
                  and Libraries to Help Types Flow</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">Pick type</span>, <a
                  data-type="index:locator" href="#calibre_link-458" class="calibre9">Item 14: Use Type Operations and
                  Generics to Avoid Repeating Yourself</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">Postel's Law</span>, <a
                  data-type="index:locator" href="#calibre_link-459" class="calibre9">Item 29: Be Liberal in What You
                  Accept and Strict in What You Produce</a>-<a data-type="index:locator" href="#calibre_link-460"
                  class="calibre9">Things to Remember</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">private field modifier</span>, <a
                  data-type="index:locator" href="#calibre_link-461" class="calibre9">Item 56: Don’t Rely on Private to
                  Hide Information</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">Promises</span>, <a
                  data-type="index:locator" href="#calibre_link-462" class="calibre9">Item 25: Use async Functions
                  Instead of Callbacks for Asynchronous Code</a>-<a data-type="index:locator" href="#calibre_link-463"
                  class="calibre9">Things to Remember</a>, <a data-type="index:locator" href="#calibre_link-464"
                  class="calibre9">Item 31: Push Null Values to the Perimeter of Your Types</a>, <a
                  data-type="index:locator" href="#calibre_link-465" class="calibre9">Use async/await Instead of Raw
                  Promises or Callbacks</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">properties</span>
                <ul class="calibre56">
                  <li class="calibre11"><span data-type="index-term" class="calibre">attaching to built-in types</span>,
                    <a data-type="index:locator" href="#calibre_link-466" class="calibre9">Item 43: Prefer Type-Safe
                      Approaches to Monkey Patching</a>
                  </li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">modeling outside of type
                      system</span>, <a data-type="index:locator" href="#calibre_link-467" class="calibre9">Item 37:
                      Consider “Brands” for Nominal Typing</a>-<a data-type="index:locator" href="#calibre_link-468"
                      class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">naming</span>, <a
                      data-type="index:locator" href="#calibre_link-469" class="calibre9">Item 36: Name Types Using the
                      Language of Your Problem Domain</a>-<a data-type="index:locator" href="#calibre_link-470"
                      class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">parameter properties</span>, <a
                      data-type="index:locator" href="#calibre_link-471" class="calibre9">Parameter Properties</a></li>
                </ul>
              </li>
              <li class="calibre11"><span data-type="index-term" class="calibre">property checking</span>, <a
                  data-type="index:locator" href="#calibre_link-472" class="calibre9">Things to Remember</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">protected field modifier</span>, <a
                  data-type="index:locator" href="#calibre_link-473" class="calibre9">Item 56: Don’t Rely on Private to
                  Hide Information</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">prototype pollution</span>, <a
                  data-type="index:locator" href="#calibre_link-474" class="calibre9">Item 54: Know How to Iterate Over
                  Objects</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">prototypes</span>, <a
                  data-type="index:locator" href="#calibre_link-475" class="calibre9">Use Classes Instead of
                  Prototypes</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">public APIs</span>
                <ul class="calibre56">
                  <li class="calibre11"><span data-type="index-term" class="calibre">exporting all types appearing
                      in</span>, <a data-type="index:locator" href="#calibre_link-476" class="calibre9">Item 47: Export
                      All Types That Appear in Public APIs</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">TSDoc for API comments</span>, <a
                      data-type="index:locator" href="#calibre_link-477" class="calibre9">Item 48: Use TSDoc for API
                      Comments</a></li>
                </ul>
              </li>
              <li class="calibre11"><span data-type="index-term" class="calibre">public field modifier</span>, <a
                  data-type="index:locator" href="#calibre_link-478" class="calibre9">Item 56: Don’t Rely on Private to
                  Hide Information</a></li>
            </ul>
          </div>
          <div data-type="indexdiv" class="praise">
            <h3 class="calibre54">R</h3>
            <ul class="calibre55">
              <li class="calibre11"><span data-type="index-term" class="calibre">Ramda library</span>, <a
                  data-type="index:locator" href="#calibre_link-479" class="calibre9">Item 27: Use Functional Constructs
                  and Libraries to Help Types Flow</a>, <a data-type="index:locator" href="#calibre_link-480"
                  class="calibre9">Item 46: Understand the Three Versions Involved in Type Declarations</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">React library</span>
                <ul class="calibre56">
                  <li class="calibre11"><span data-type="index-term" class="calibre">dependencies</span>, <a
                      data-type="index:locator" href="#calibre_link-481" class="calibre9">Item 45: Put TypeScript and
                      @types in devDependencies</a>-<a data-type="index:locator" href="#calibre_link-482"
                      class="calibre9">Item 46: Understand the Three Versions Involved in Type Declarations</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">DOM hierarchy and</span>, <a
                      data-type="index:locator" href="#calibre_link-483" class="calibre9">Item 55: Understand the DOM
                      hierarchy</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">optimizations in</span>, <a
                      data-type="index:locator" href="#calibre_link-484" class="calibre9">Item 18: Use Mapped Types to
                      Keep Values in Sync</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">Person in</span>, <a
                      data-type="index:locator" href="#calibre_link-485" class="calibre9">Item 9: Prefer Type
                      Declarations to Type Assertions</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">useMemo hook</span>, <a
                      data-type="index:locator" href="#calibre_link-486" class="calibre9">Item 40: Hide Unsafe Type
                      Assertions in Well-Typed Functions</a></li>
                </ul>
              </li>
              <li class="calibre11"><span data-type="index-term" class="calibre">readonly</span>, <a
                  data-type="index:locator" href="#calibre_link-487" class="calibre9">Item 17: Use readonly to Avoid
                  Errors Associated with Mutation</a>-<a data-type="index:locator" href="#calibre_link-488"
                  class="calibre9">Things to Remember</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">Records</span>, <a
                  data-type="index:locator" href="#calibre_link-489" class="calibre9">Item 15: Use Index Signatures for
                  Dynamic Data</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">recursive types</span>, <a
                  data-type="index:locator" href="#calibre_link-490" class="calibre9">Item 34: Prefer Incomplete Types
                  to Inaccurate Types</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">repetition, avoiding</span>, <a
                  data-type="index:locator" href="#calibre_link-491" class="calibre9">Item 14: Use Type Operations and
                  Generics to Avoid Repeating Yourself</a>-<a data-type="index:locator" href="#calibre_link-492"
                  class="calibre9">Things to Remember</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">return types</span>, <a
                  data-type="index:locator" href="#calibre_link-493" class="calibre9">Item 29: Be Liberal in What You
                  Accept and Strict in What You Produce</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">ReturnType</span>, <a
                  data-type="index:locator" href="#calibre_link-494" class="calibre9">Item 14: Use Type Operations and
                  Generics to Avoid Repeating Yourself</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">robustness principle</span>, <a
                  data-type="index:locator" href="#calibre_link-495" class="calibre9">Item 29: Be Liberal in What You
                  Accept and Strict in What You Produce</a>-<a data-type="index:locator" href="#calibre_link-496"
                  class="calibre9">Things to Remember</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">Rogers, Ginger</span>, <a
                  data-type="index:locator" href="#calibre_link-497" class="calibre9">Item 14: Use Type Operations and
                  Generics to Avoid Repeating Yourself</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">runtime</span>
                <ul class="calibre56">
                  <li class="calibre11"><span data-type="index-term" class="calibre">effect of TypeScript types on
                      performance</span>, <a data-type="index:locator" href="#calibre_link-498"
                      class="calibre9">TypeScript Types Have No Effect on Runtime Performance</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">inability to check TypeScript
                      at</span>, <a data-type="index:locator" href="#calibre_link-499" class="calibre9">You Cannot Check
                      TypeScript Types at Runtime</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">runtime types versus declared
                      types</span>, <a data-type="index:locator" href="#calibre_link-500" class="calibre9">Runtime Types
                      May Not Be the Same as Declared Types</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">type operations and runtime
                      values</span>, <a data-type="index:locator" href="#calibre_link-501" class="calibre9">Type
                      Operations Cannot Affect Runtime Values</a></li>
                </ul>
              </li>
            </ul>
          </div>
          <div data-type="indexdiv" class="praise">
            <h3 class="calibre54">S</h3>
            <ul class="calibre55">
              <li class="calibre11"><span data-type="index-term" class="calibre">security</span>, <a
                  data-type="index:locator" href="#calibre_link-502" class="calibre9">Item 56: Don’t Rely on Private to
                  Hide Information</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">Shelley, Mary</span>, <a
                  data-type="index:locator" href="#calibre_link-503" class="calibre9">Item 17: Use readonly to Avoid
                  Errors Associated with Mutation</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">source maps</span>, <a
                  data-type="index:locator" href="#calibre_link-504" class="calibre9">Item 57: Use Source Maps to Debug
                  TypeScript</a>-<a data-type="index:locator" href="#calibre_link-505" class="calibre9">Things to
                  Remember</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">statically typed languages</span>, <a
                  data-type="index:locator" href="#calibre_link-506" class="calibre9">Type Inference</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">strict mode</span>, <a
                  data-type="index:locator" href="#calibre_link-507" class="calibre9">Don’t Put use strict in
                  TypeScript</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">strictNullChecks</span>, <a
                  data-type="index:locator" href="#calibre_link-508" class="calibre9">Item 2: Know Which TypeScript
                  Options You’re Using</a>-<a data-type="index:locator" href="#calibre_link-509" class="calibre9">Things
                  to Remember</a>, <a data-type="index:locator" href="#calibre_link-510" class="calibre9">Item 31: Push
                  Null Values to the Perimeter of Your Types</a>-<a data-type="index:locator" href="#calibre_link-511"
                  class="calibre9">Things to Remember</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">string primitives</span>, <a
                  data-type="index:locator" href="#calibre_link-512" class="calibre9">Item 10: Avoid Object Wrapper
                  Types (String, Number, Boolean, Symbol, BigInt)</a>-<a data-type="index:locator"
                  href="#calibre_link-513" class="calibre9">Things to Remember</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">string types, alternatives to</span>,
                <a data-type="index:locator" href="#calibre_link-514" class="calibre9">Item 33: Prefer More Precise
                  Alternatives to String Types</a>-<a data-type="index:locator" href="#calibre_link-515"
                  class="calibre9">Things to Remember</a>
              </li>
              <li class="calibre11"><span data-type="index-term" class="calibre">structural typing</span>, <a
                  data-type="index:locator" href="#calibre_link-516" class="calibre9">Item 4: Get Comfortable with
                  Structural Typing</a>-<a data-type="index:locator" href="#calibre_link-517" class="calibre9">Things to
                  Remember</a>, <a data-type="index:locator" href="#calibre_link-518" class="calibre9">Item 37: Consider
                  “Brands” for Nominal Typing</a>-<a data-type="index:locator" href="#calibre_link-519"
                  class="calibre9">Things to Remember</a>, <a data-type="index:locator" href="#calibre_link-520"
                  class="calibre9">Item 51: Mirror Types to Sever Dependencies</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">subsets</span>, <a
                  data-type="index:locator" href="#calibre_link-521" class="calibre9">Item 7: Think of Types as Sets of
                  Values</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">subtypes</span>, <a
                  data-type="index:locator" href="#calibre_link-522" class="calibre9">Item 7: Think of Types as Sets of
                  Values</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">symbols</span>
                <ul class="calibre56">
                  <li class="calibre11"><span data-type="index-term" class="calibre">symbol primitives</span>, <a
                      data-type="index:locator" href="#calibre_link-523" class="calibre9">Item 10: Avoid Object Wrapper
                      Types (String, Number, Boolean, Symbol, BigInt)</a>-<a data-type="index:locator"
                      href="#calibre_link-524" class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">type space versus value
                      space</span>, <a data-type="index:locator" href="#calibre_link-525" class="calibre9">Item 8: Know
                      How to Tell Whether a Symbol Is in the Type Space or Value Space</a>-<a data-type="index:locator"
                      href="#calibre_link-526" class="calibre9">Things to Remember</a></li>
                </ul>
              </li>
            </ul>
          </div>
          <div data-type="indexdiv" class="praise">
            <h3 class="calibre54">T</h3>
            <ul class="calibre55">
              <li class="calibre11"><span data-type="index-term" class="calibre">tagged unions</span>
                <ul class="calibre56">
                  <li class="calibre11"><span data-type="index-term" class="calibre">example of</span>, <a
                      data-type="index:locator" href="#calibre_link-527" class="calibre9">You Cannot Check TypeScript
                      Types at Runtime</a>, <a data-type="index:locator" href="#calibre_link-528" class="calibre9">Item
                      22: Understand Type Narrowing</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">querying at runtime using</span>,
                    <a data-type="index:locator" href="#calibre_link-529" class="calibre9">Things to Remember</a>
                  </li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">unions of interfaces versus
                      interfaces of unions</span>, <a data-type="index:locator" href="#calibre_link-530"
                      class="calibre9">Item 32: Prefer Unions of Interfaces to Interfaces of Unions</a>-<a
                      data-type="index:locator" href="#calibre_link-531" class="calibre9">Things to Remember</a></li>
                </ul>
              </li>
              <li class="calibre11"><span data-type="index-term" class="calibre">TC39</span>, <a
                  data-type="index:locator" href="#calibre_link-532" class="calibre9">Things to Remember</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">test-driven development (TDD)</span>,
                <a data-type="index:locator" href="#calibre_link-533" class="calibre9">Item 19: Avoid Cluttering Your
                  Code with Inferable Types</a>
              </li>
              <li class="calibre11"><span data-type="index-term" class="calibre">Testing types</span>, <a
                  data-type="index:locator" href="#calibre_link-534" class="calibre9">Item 52: Be Aware of the Pitfalls
                  of Testing Types</a>-<a data-type="index:locator" href="#calibre_link-535" class="calibre9">Things to
                  Remember</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">third-party type declarations</span>,
                <a data-type="index:locator" href="#calibre_link-536" class="calibre9">Item 44: Track Your Type Coverage
                  to Prevent Regressions in Type Safety</a>
              </li>
              <li class="calibre11"><span data-type="index-term" class="calibre">this keyword</span>, <a
                  data-type="index:locator" href="#calibre_link-537" class="calibre9">Item 49: Provide a Type for this
                  in Callbacks</a>, <a data-type="index:locator" href="#calibre_link-538" class="calibre9">Prefer Arrow
                  Functions Over Function Expressions</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">this operator</span>, <a
                  data-type="index:locator" href="#calibre_link-539" class="calibre9">Item 8: Know How to Tell Whether a
                  Symbol Is in the Type Space or Value Space</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">transpiling</span>, <a
                  data-type="index:locator" href="#calibre_link-540" class="calibre9">Item 3: Understand That Code
                  Generation Is Independent of Types</a>
                <ul class="calibre56">
                  <li class="calibre11">(<span data-gentext="see" class="calibre">see also</span> compiling)</li>
                </ul>
              </li>
              <li class="calibre11"><span data-type="index-term" class="calibre">triple-slash imports</span>, <a
                  data-type="index:locator" href="#calibre_link-541" class="calibre9">Namespaces and Triple-Slash
                  Imports</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">Truth, Sojourner</span>, <a
                  data-type="index:locator" href="#calibre_link-542" class="calibre9">Item 19: Avoid Cluttering Your
                  Code with Inferable Types</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">ts-node</span>, <a
                  data-type="index:locator" href="#calibre_link-543" class="calibre9">Use ECMAScript Modules</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">tsconfig.json</span>
                <ul class="calibre56">
                  <li class="calibre11"><span data-type="index-term" class="calibre">experimentalDecorators
                      property</span>, <a data-type="index:locator" href="#calibre_link-544"
                      class="calibre9">Decorators</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">knowing which options you’re
                      using</span>, <a data-type="index:locator" href="#calibre_link-545" class="calibre9">Item 2: Know
                      Which TypeScript Options You’re Using</a>-<a data-type="index:locator" href="#calibre_link-546"
                      class="calibre9">Code with Type Errors Can Produce Output</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">merging and</span>, <a
                      data-type="index:locator" href="#calibre_link-547" class="calibre9">Item 13: Know the Differences
                      Between type and interface</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">noImplicitAny</span>, <a
                      data-type="index:locator" href="#calibre_link-548" class="calibre9">Item 62: Don’t Consider
                      Migration Complete Until You Enable noImplicitAny</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">sourceMap option</span>, <a
                      data-type="index:locator" href="#calibre_link-549" class="calibre9">Item 57: Use Source Maps to
                      Debug TypeScript</a></li>
                </ul>
              </li>
              <li class="calibre11"><span data-type="index-term" class="calibre">TSDoc</span>, <a
                  data-type="index:locator" href="#calibre_link-550" class="calibre9">Item 48: Use TSDoc for API
                  Comments</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">tuple type</span>, <a
                  data-type="index:locator" href="#calibre_link-551" class="calibre9">Item 16: Prefer Arrays, Tuples,
                  and ArrayLike to number Index Signatures</a>, <a data-type="index:locator" href="#calibre_link-552"
                  class="calibre9">Tuple Types</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">Turing, Alan</span>, <a
                  data-type="index:locator" href="#calibre_link-553" class="calibre9">Item 7: Think of Types as Sets of
                  Values</a>, <a data-type="index:locator" href="#calibre_link-554" class="calibre9">Item 32: Prefer
                  Unions of Interfaces to Interfaces of Unions</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">Twain, Mark</span>, <a
                  data-type="index:locator" href="#calibre_link-555" class="calibre9">Item 12: Apply Types to Entire
                  Function Expressions When Possible</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">type annotations</span>
                <ul class="calibre56">
                  <li class="calibre11"><span data-type="index-term" class="calibre">avoiding cluttered code</span>, <a
                      data-type="index:locator" href="#calibre_link-556" class="calibre9">Item 19: Avoid Cluttering Your
                      Code with Inferable Types</a>-<a data-type="index:locator" href="#calibre_link-557"
                      class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">reducing need for</span>, <a
                      data-type="index:locator" href="#calibre_link-558" class="calibre9">Item 27: Use Functional
                      Constructs and Libraries to Help Types Flow</a>-<a data-type="index:locator"
                      href="#calibre_link-559" class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">using explicit with any
                      types</span>, <a data-type="index:locator" href="#calibre_link-560" class="calibre9">Item 38: Use
                      the Narrowest Possible Scope for any Types</a>, <a data-type="index:locator"
                      href="#calibre_link-561" class="calibre9">Item 41: Understand Evolving any</a>-<a
                      data-type="index:locator" href="#calibre_link-562" class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">using more effectively</span>, <a
                      data-type="index:locator" href="#calibre_link-563" class="calibre9">Item 21: Understand Type
                      Widening</a></li>
                </ul>
              </li>
              <li class="calibre11"><span data-type="index-term" class="calibre">type assertion</span>
                <ul class="calibre56">
                  <li class="calibre11"><span data-type="index-term" class="calibre">example of</span>, <a
                      data-type="index:locator" href="#calibre_link-564" class="calibre9">Type Operations Cannot Affect
                      Runtime Values</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">hiding unsafe type
                      assertions</span>, <a data-type="index:locator" href="#calibre_link-565" class="calibre9">Item 40:
                      Hide Unsafe Type Assertions in Well-Typed Functions</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">misuse of</span>, <a
                      data-type="index:locator" href="#calibre_link-566" class="calibre9">Item 5: Limit Use of the any
                      Type</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">versus type declarations</span>, <a
                      data-type="index:locator" href="#calibre_link-567" class="calibre9">Item 9: Prefer Type
                      Declarations to Type Assertions</a>-<a data-type="index:locator" href="#calibre_link-568"
                      class="calibre9">Things to Remember</a></li>
                </ul>
              </li>
              <li class="calibre11"><span data-type="index-term" class="calibre">type checking, versus excess property
                  checking</span>, <a data-type="index:locator" href="#calibre_link-569" class="calibre9">Item 11:
                  Recognize the Limits of Excess Property Checking</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">type construct</span>, <a
                  data-type="index:locator" href="#calibre_link-570" class="calibre9">Item 13: Know the Differences
                  Between type and interface</a>-<a data-type="index:locator" href="#calibre_link-571"
                  class="calibre9">Things to Remember</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">type declaration</span>
                <ul class="calibre56">
                  <li class="calibre11"><span data-type="index-term" class="calibre">conditional types versus overloaded
                      declarations</span>, <a data-type="index:locator" href="#calibre_link-572" class="calibre9">Item
                      50: Prefer Conditional Types to Overloaded Declarations</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">mirroring types to sever
                      dependencies</span>, <a data-type="index:locator" href="#calibre_link-573" class="calibre9">Item
                      51: Mirror Types to Sever Dependencies</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">navigating with language
                      services</span>, <a data-type="index:locator" href="#calibre_link-574" class="calibre9">Item 6:
                      Use Your Editor to Interrogate and Explore the Type System</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">pitfalls of testing types</span>,
                    <a data-type="index:locator" href="#calibre_link-575" class="calibre9">Item 52: Be Aware of the
                      Pitfalls of Testing Types</a>
                  </li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">providing types for this keyword in
                      callbacks</span>, <a data-type="index:locator" href="#calibre_link-576" class="calibre9">Item 49:
                      Provide a Type for this in Callbacks</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">third-party</span>, <a
                      data-type="index:locator" href="#calibre_link-577" class="calibre9">Item 44: Track Your Type
                      Coverage to Prevent Regressions in Type Safety</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">three versions involved in</span>,
                    <a data-type="index:locator" href="#calibre_link-578" class="calibre9">Item 46: Understand the Three
                      Versions Involved in Type Declarations</a>-<a data-type="index:locator" href="#calibre_link-579"
                      class="calibre9">Things to Remember</a>
                  </li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">TSDoc for API comments</span>, <a
                      data-type="index:locator" href="#calibre_link-580" class="calibre9">Item 48: Use TSDoc for API
                      Comments</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">versus type assertion</span>, <a
                      data-type="index:locator" href="#calibre_link-581" class="calibre9">Item 9: Prefer Type
                      Declarations to Type Assertions</a>-<a data-type="index:locator" href="#calibre_link-582"
                      class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">types in public APIs</span>, <a
                      data-type="index:locator" href="#calibre_link-583" class="calibre9">Item 47: Export All Types That
                      Appear in Public APIs</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">TypeScript and @types</span>, <a
                      data-type="index:locator" href="#calibre_link-584" class="calibre9">Item 45: Put TypeScript and
                      @types in devDependencies</a></li>
                </ul>
              </li>
              <li class="calibre11"><span data-type="index-term" class="calibre">type dependencies</span> (<span
                  data-gentext="see" class="calibre">see</span> @types)</li>
              <li class="calibre11"><span data-type="index-term" class="calibre">type design</span>
                <ul class="calibre56">
                  <li class="calibre11"><span data-type="index-term" class="calibre">alternatives to string
                      types</span>, <a data-type="index:locator" href="#calibre_link-585" class="calibre9">Item 33:
                      Prefer More Precise Alternatives to String Types</a>-<a data-type="index:locator"
                      href="#calibre_link-586" class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">any type drawbacks</span>, <a
                      data-type="index:locator" href="#calibre_link-587" class="calibre9">any Hides Your Type Design</a>
                  </li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">generating types from
                      specifications</span>, <a data-type="index:locator" href="#calibre_link-588" class="calibre9">Item
                      35: Generate Types from APIs and Specs, Not Data</a>-<a data-type="index:locator"
                      href="#calibre_link-589" class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">incomplete versus inaccurate
                      types</span>, <a data-type="index:locator" href="#calibre_link-590" class="calibre9">Item 34:
                      Prefer Incomplete Types to Inaccurate Types</a>-<a data-type="index:locator"
                      href="#calibre_link-591" class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">naming types</span>, <a
                      data-type="index:locator" href="#calibre_link-592" class="calibre9">Item 36: Name Types Using the
                      Language of Your Problem Domain</a>-<a data-type="index:locator" href="#calibre_link-593"
                      class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">nominal typing</span>, <a
                      data-type="index:locator" href="#calibre_link-594" class="calibre9">Item 37: Consider “Brands” for
                      Nominal Typing</a>-<a data-type="index:locator" href="#calibre_link-595" class="calibre9">Things
                      to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">null values</span>, <a
                      data-type="index:locator" href="#calibre_link-596" class="calibre9">Item 31: Push Null Values to
                      the Perimeter of Your Types</a>-<a data-type="index:locator" href="#calibre_link-597"
                      class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">robustness principle</span>, <a
                      data-type="index:locator" href="#calibre_link-598" class="calibre9">Item 29: Be Liberal in What
                      You Accept and Strict in What You Produce</a>-<a data-type="index:locator"
                      href="#calibre_link-599" class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">type information in
                      documentation</span>, <a data-type="index:locator" href="#calibre_link-600" class="calibre9">Item
                      30: Don’t Repeat Type Information in Documentation</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">types representing valid versus
                      invalid states</span>, <a data-type="index:locator" href="#calibre_link-601" class="calibre9">Item
                      28: Prefer Types That Always Represent Valid States</a>-<a data-type="index:locator"
                      href="#calibre_link-602" class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">unions of interfaces versus
                      interfaces of unions</span>, <a data-type="index:locator" href="#calibre_link-603"
                      class="calibre9">Item 32: Prefer Unions of Interfaces to Interfaces of Unions</a>-<a
                      data-type="index:locator" href="#calibre_link-604" class="calibre9">Things to Remember</a></li>
                </ul>
              </li>
              <li class="calibre11"><span data-type="index-term" class="calibre">type domains</span>, <a
                  data-type="index:locator" href="#calibre_link-605" class="calibre9">Item 7: Think of Types as Sets of
                  Values</a>-<a data-type="index:locator" href="#calibre_link-606" class="calibre9">Things to
                  Remember</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">type inference</span>
                <ul class="calibre56">
                  <li class="calibre11"><span data-type="index-term" class="calibre">aliases</span>, <a
                      data-type="index:locator" href="#calibre_link-607" class="calibre9">Item 24: Be Consistent in Your
                      Use of Aliases</a>-<a data-type="index:locator" href="#calibre_link-608" class="calibre9">Things
                      to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">asynchronous code</span>, <a
                      data-type="index:locator" href="#calibre_link-609" class="calibre9">Item 25: Use async Functions
                      Instead of Callbacks for Asynchronous Code</a>-<a data-type="index:locator"
                      href="#calibre_link-610" class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">avoiding variable reuse</span>, <a
                      data-type="index:locator" href="#calibre_link-611" class="calibre9">Item 20: Use Different
                      Variables for Different Types</a>-<a data-type="index:locator" href="#calibre_link-612"
                      class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">benefits of inferable types</span>,
                    <a data-type="index:locator" href="#calibre_link-613" class="calibre9">Item 19: Avoid Cluttering
                      Your Code with Inferable Types</a>-<a data-type="index:locator" href="#calibre_link-614"
                      class="calibre9">Things to Remember</a>
                  </li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">context in</span>, <a
                      data-type="index:locator" href="#calibre_link-615" class="calibre9">Item 26: Understand How
                      Context Is Used in Type Inference</a>-<a data-type="index:locator" href="#calibre_link-616"
                      class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">functional constructs and
                      libraries</span>, <a data-type="index:locator" href="#calibre_link-617" class="calibre9">Item 27:
                      Use Functional Constructs and Libraries to Help Types Flow</a>-<a data-type="index:locator"
                      href="#calibre_link-618" class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">object creation</span>, <a
                      data-type="index:locator" href="#calibre_link-619" class="calibre9">Item 23: Create Objects All at
                      Once</a>-<a data-type="index:locator" href="#calibre_link-620" class="calibre9">Things to
                      Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">type narrowing</span>, <a
                      data-type="index:locator" href="#calibre_link-621" class="calibre9">Item 22: Understand Type
                      Narrowing</a>-<a data-type="index:locator" href="#calibre_link-622" class="calibre9">Things to
                      Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">type widening</span>, <a
                      data-type="index:locator" href="#calibre_link-623" class="calibre9">Item 21: Understand Type
                      Widening</a>-<a data-type="index:locator" href="#calibre_link-624" class="calibre9">Things to
                      Remember</a></li>
                </ul>
              </li>
              <li class="calibre11"><span data-type="index-term" class="calibre">type narrowing</span>, <a
                  data-type="index:locator" href="#calibre_link-625" class="calibre9">Item 22: Understand Type
                  Narrowing</a>-<a data-type="index:locator" href="#calibre_link-626" class="calibre9">Things to
                  Remember</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">type refinements</span>, <a
                  data-type="index:locator" href="#calibre_link-627" class="calibre9">Item 24: Be Consistent in Your Use
                  of Aliases</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">type safety</span>
                <ul class="calibre56">
                  <li class="calibre11"><span data-type="index-term" class="calibre">avoid returning any types from
                      functions</span>, <a data-type="index:locator" href="#calibre_link-628" class="calibre9">Item 38:
                      Use the Narrowest Possible Scope for any Types</a>-<a data-type="index:locator"
                      href="#calibre_link-629" class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">ensuring</span>, <a
                      data-type="index:locator" href="#calibre_link-630" class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">hiding unsafe type
                      assertions</span>, <a data-type="index:locator" href="#calibre_link-631" class="calibre9">Item 40:
                      Hide Unsafe Type Assertions in Well-Typed Functions</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">lack of with any types</span>, <a
                      data-type="index:locator" href="#calibre_link-632" class="calibre9">There’s No Type Safety with
                      any Types</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">preventing regressions in</span>,
                    <a data-type="index:locator" href="#calibre_link-633" class="calibre9">Item 44: Track Your Type
                      Coverage to Prevent Regressions in Type Safety</a>
                  </li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">subsets of string and</span>, <a
                      data-type="index:locator" href="#calibre_link-634" class="calibre9">Item 33: Prefer More Precise
                      Alternatives to String Types</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">type-safe approaches versus
                      monkey-patching</span>, <a data-type="index:locator" href="#calibre_link-635"
                      class="calibre9">Item 43: Prefer Type-Safe Approaches to Monkey Patching</a></li>
                </ul>
              </li>
              <li class="calibre11"><span data-type="index-term" class="calibre">type space</span>, <a
                  data-type="index:locator" href="#calibre_link-636" class="calibre9">Item 8: Know How to Tell Whether a
                  Symbol Is in the Type Space or Value Space</a>-<a data-type="index:locator" href="#calibre_link-637"
                  class="calibre9">Things to Remember</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">type system</span>
                <ul class="calibre56">
                  <li class="calibre11"><span data-type="index-term" class="calibre">applying type annotations to
                      function expressions</span>, <a data-type="index:locator" href="#calibre_link-638"
                      class="calibre9">Item 12: Apply Types to Entire Function Expressions When Possible</a>-<a
                      data-type="index:locator" href="#calibre_link-639" class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">arrays, tuples, and
                      ArrayLike</span>, <a data-type="index:locator" href="#calibre_link-640" class="calibre9">Item 16:
                      Prefer Arrays, Tuples, and ArrayLike to number Index Signatures</a>-<a data-type="index:locator"
                      href="#calibre_link-641" class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">avoiding errors associated with
                      mutation</span>, <a data-type="index:locator" href="#calibre_link-642" class="calibre9">Item 17:
                      Use readonly to Avoid Errors Associated with Mutation</a>-<a data-type="index:locator"
                      href="#calibre_link-643" class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">avoiding repetition</span>, <a
                      data-type="index:locator" href="#calibre_link-644" class="calibre9">Item 14: Use Type Operations
                      and Generics to Avoid Repeating Yourself</a>-<a data-type="index:locator" href="#calibre_link-645"
                      class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">excess property checking
                      limits</span>, <a data-type="index:locator" href="#calibre_link-646" class="calibre9">Item 11:
                      Recognize the Limits of Excess Property Checking</a>-<a data-type="index:locator"
                      href="#calibre_link-647" class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">index signatures for dynamic
                      data</span>, <a data-type="index:locator" href="#calibre_link-648" class="calibre9">Item 15: Use
                      Index Signatures for Dynamic Data</a>-<a data-type="index:locator" href="#calibre_link-649"
                      class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">mapped types</span>, <a
                      data-type="index:locator" href="#calibre_link-650" class="calibre9">Item 18: Use Mapped Types to
                      Keep Values in Sync</a>-<a data-type="index:locator" href="#calibre_link-651"
                      class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">object wrapper types</span>, <a
                      data-type="index:locator" href="#calibre_link-652" class="calibre9">Item 10: Avoid Object Wrapper
                      Types (String, Number, Boolean, Symbol, BigInt)</a>-<a data-type="index:locator"
                      href="#calibre_link-653" class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">as optional and gradual</span>, <a
                      data-type="index:locator" href="#calibre_link-654" class="calibre9">Working with any</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">type declarations versus type
                      assertions</span>, <a data-type="index:locator" href="#calibre_link-655" class="calibre9">Item 9:
                      Prefer Type Declarations to Type Assertions</a>-<a data-type="index:locator"
                      href="#calibre_link-656" class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">type space versus value
                      space</span>, <a data-type="index:locator" href="#calibre_link-657" class="calibre9">Item 8: Know
                      How to Tell Whether a Symbol Is in the Type Space or Value Space</a>-<a data-type="index:locator"
                      href="#calibre_link-658" class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">type versus interface</span>, <a
                      data-type="index:locator" href="#calibre_link-659" class="calibre9">Item 13: Know the Differences
                      Between type and interface</a>-<a data-type="index:locator" href="#calibre_link-660"
                      class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">types as set values</span>, <a
                      data-type="index:locator" href="#calibre_link-661" class="calibre9">Item 7: Think of Types as Sets
                      of Values</a>-<a data-type="index:locator" href="#calibre_link-662" class="calibre9">Things to
                      Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">using editors to interrogate and
                      explore</span>, <a data-type="index:locator" href="#calibre_link-663" class="calibre9">Item 6: Use
                      Your Editor to Interrogate and Explore the Type System</a>-<a data-type="index:locator"
                      href="#calibre_link-664" class="calibre9">Things to Remember</a></li>
                </ul>
              </li>
              <li class="calibre11"><span data-type="index-term" class="calibre">type widening</span>, <a
                  data-type="index:locator" href="#calibre_link-665" class="calibre9">Item 21: Understand Type
                  Widening</a>-<a data-type="index:locator" href="#calibre_link-666" class="calibre9">Things to
                  Remember</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">typeof fn</span>, <a
                  data-type="index:locator" href="#calibre_link-667" class="calibre9">Item 12: Apply Types to Entire
                  Function Expressions When Possible</a>-<a data-type="index:locator" href="#calibre_link-668"
                  class="calibre9">Things to Remember</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">typeof operator</span>, <a
                  data-type="index:locator" href="#calibre_link-669" class="calibre9">Item 8: Know How to Tell Whether a
                  Symbol Is in the Type Space or Value Space</a>, <a data-type="index:locator" href="#calibre_link-670"
                  class="calibre9">Item 14: Use Type Operations and Generics to Avoid Repeating Yourself</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">TypeScript</span>
                <ul class="calibre56">
                  <li class="calibre11"><span data-type="index-term" class="calibre">any type drawbacks</span>, <a
                      data-type="index:locator" href="#calibre_link-671" class="calibre9">Item 5: Limit Use of the any
                      Type</a>-<a data-type="index:locator" href="#calibre_link-672" class="calibre9">Things to
                      Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">configuration settings</span>, <a
                      data-type="index:locator" href="#calibre_link-673" class="calibre9">Item 2: Know Which TypeScript
                      Options You’re Using</a>-<a data-type="index:locator" href="#calibre_link-674"
                      class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">experimenting with</span>, <a
                      data-type="index:locator" href="#calibre_link-675" class="calibre9">Item 59: Use @ts-check and
                      JSDoc to Experiment with TypeScript</a>-<a data-type="index:locator" href="#calibre_link-676"
                      class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">function statements versus function
                      expressions</span>, <a data-type="index:locator" href="#calibre_link-677" class="calibre9">Item
                      12: Apply Types to Entire Function Expressions When Possible</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">installing as a
                      devDependency</span>, <a data-type="index:locator" href="#calibre_link-678" class="calibre9">Item
                      45: Put TypeScript and @types in devDependencies</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">migrating to</span>, <a
                      data-type="index:locator" href="#calibre_link-679" class="calibre9">Item 1: Understand the
                      Relationship Between TypeScript and JavaScript</a>, <a data-type="index:locator"
                      href="#calibre_link-680" class="calibre9">Migrating to TypeScript</a>-<a data-type="index:locator"
                      href="#calibre_link-681" class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">mixing with JavaScript</span>, <a
                      data-type="index:locator" href="#calibre_link-682" class="calibre9">Item 60: Use allowJs to Mix
                      TypeScript and JavaScript</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">relationship to JavaScript</span>,
                    <a data-type="index:locator" href="#calibre_link-683" class="calibre9">Item 1: Understand the
                      Relationship Between TypeScript and JavaScript</a>-<a data-type="index:locator"
                      href="#calibre_link-684" class="calibre9">Things to Remember</a>, <a data-type="index:locator"
                      href="#calibre_link-685" class="calibre9">Item 53: Prefer ECMAScript Features to TypeScript
                      Features</a>
                  </li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">release notes</span>, <a
                      data-type="index:locator" href="#calibre_link-686" class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">structural typing</span>, <a
                      data-type="index:locator" href="#calibre_link-687" class="calibre9">Item 4: Get Comfortable with
                      Structural Typing</a>-<a data-type="index:locator" href="#calibre_link-688"
                      class="calibre9">Things to Remember</a>, <a data-type="index:locator" href="#calibre_link-689"
                      class="calibre9">Item 37: Consider “Brands” for Nominal Typing</a>-<a data-type="index:locator"
                      href="#calibre_link-690" class="calibre9">Things to Remember</a>, <a data-type="index:locator"
                      href="#calibre_link-691" class="calibre9">Item 51: Mirror Types to Sever Dependencies</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">terms and set terms</span>, <a
                      data-type="index:locator" href="#calibre_link-692" class="calibre9">Item 7: Think of Types as Sets
                      of Values</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">type inference in</span>, <a
                      data-type="index:locator" href="#calibre_link-693" class="calibre9">Item 19: Avoid Cluttering Your
                      Code with Inferable Types</a>-<a data-type="index:locator" href="#calibre_link-694"
                      class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">writing for browsers</span>, <a
                      data-type="index:locator" href="#calibre_link-695" class="calibre9">Item 55: Understand the DOM
                      hierarchy</a>-<a data-type="index:locator" href="#calibre_link-696" class="calibre9">Things to
                      Remember</a></li>
                </ul>
              </li>
              <li class="calibre11"><span data-type="index-term" class="calibre">TypeScript compiler (tsc)</span>
                <ul class="calibre56">
                  <li class="calibre11"><span data-type="index-term" class="calibre">code generation and type
                      checking</span>, <a data-type="index:locator" href="#calibre_link-697" class="calibre9">Code with
                      Type Errors Can Produce Output</a>-<a data-type="index:locator" href="#calibre_link-698"
                      class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">functions of</span>, <a
                      data-type="index:locator" href="#calibre_link-699" class="calibre9">Item 3: Understand That Code
                      Generation Is Independent of Types</a></li>
                </ul>
              </li>
              <li class="calibre11"><span data-type="index-term" class="calibre">TypeScript Playground</span>, <a
                  data-type="index:locator" href="#calibre_link-700" class="calibre9">Item 8: Know How to Tell Whether a
                  Symbol Is in the Type Space or Value Space</a></li>
            </ul>
          </div>
          <div data-type="indexdiv" class="praise">
            <h3 class="calibre54">U</h3>
            <ul class="calibre55">
              <li class="calibre11"><span data-type="index-term" class="calibre">undeclared globals</span>, <a
                  data-type="index:locator" href="#calibre_link-701" class="calibre9">Undeclared Globals</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">undefined primitive</span>, <a
                  data-type="index:locator" href="#calibre_link-702" class="calibre9">Item 10: Avoid Object Wrapper
                  Types (String, Number, Boolean, Symbol, BigInt)</a>-<a data-type="index:locator"
                  href="#calibre_link-703" class="calibre9">Things to Remember</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">undefined value type</span>, <a
                  data-type="index:locator" href="#calibre_link-704" class="calibre9">Item 15: Use Index Signatures for
                  Dynamic Data</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">Underscore library</span>, <a
                  data-type="index:locator" href="#calibre_link-705" class="calibre9">Item 27: Use Functional Constructs
                  and Libraries to Help Types Flow</a>, <a data-type="index:locator" href="#calibre_link-706"
                  class="calibre9">Item 27: Use Functional Constructs and Libraries to Help Types Flow</a>, <a
                  data-type="index:locator" href="#calibre_link-707" class="calibre9">Item 33: Prefer More Precise
                  Alternatives to String Types</a>, <a data-type="index:locator" href="#calibre_link-708"
                  class="calibre9">Item 52: Be Aware of the Pitfalls of Testing Types</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">union types</span>
                <ul class="calibre56">
                  <li class="calibre11"><span data-type="index-term" class="calibre">difficulty in using</span>, <a
                      data-type="index:locator" href="#calibre_link-709" class="calibre9">Item 29: Be Liberal in What
                      You Accept and Strict in What You Produce</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">extending</span>, <a
                      data-type="index:locator" href="#calibre_link-710" class="calibre9">Item 13: Know the Differences
                      Between type and interface</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">purpose of</span>, <a
                      data-type="index:locator" href="#calibre_link-711" class="calibre9">Item 20: Use Different
                      Variables for Different Types</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">unions of interfaces versus
                      interfaces of unions</span>, <a data-type="index:locator" href="#calibre_link-712"
                      class="calibre9">Item 32: Prefer Unions of Interfaces to Interfaces of Unions</a>-<a
                      data-type="index:locator" href="#calibre_link-713" class="calibre9">Things to Remember</a></li>
                </ul>
              </li>
              <li class="calibre11"><span data-type="index-term" class="calibre">unknown libraries</span>, <a
                  data-type="index:locator" href="#calibre_link-714" class="calibre9">Unknown Libraries</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">unknown types</span>
                <ul class="calibre56">
                  <li class="calibre11"><span data-type="index-term" class="calibre">versus inaccurate models</span>, <a
                      data-type="index:locator" href="#calibre_link-715" class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">unknown versus any types</span>, <a
                      data-type="index:locator" href="#calibre_link-716" class="calibre9">Item 42: Use unknown Instead
                      of any for Values with an Unknown Type</a>-<a data-type="index:locator" href="#calibre_link-717"
                      class="calibre9">Things to Remember</a></li>
                </ul>
              </li>
              <li class="calibre11"><span data-type="index-term" class="calibre">unsafe casts</span>, <a
                  data-type="index:locator" href="#calibre_link-718" class="calibre9">Item 40: Hide Unsafe Type
                  Assertions in Well-Typed Functions</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">use strict</span>, <a
                  data-type="index:locator" href="#calibre_link-719" class="calibre9">Don’t Put use strict in
                  TypeScript</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">user-defined type guards</span>, <a
                  data-type="index:locator" href="#calibre_link-720" class="calibre9">Item 22: Understand Type
                  Narrowing</a></li>
            </ul>
          </div>
          <div data-type="indexdiv" class="praise">
            <h3 class="calibre54">V</h3>
            <ul class="calibre55">
              <li class="calibre11"><span data-type="index-term" class="calibre">valid states</span>, <a
                  data-type="index:locator" href="#calibre_link-721" class="calibre9">Item 28: Prefer Types That Always
                  Represent Valid States</a>-<a data-type="index:locator" href="#calibre_link-722"
                  class="calibre9">Things to Remember</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">value space</span>, <a
                  data-type="index:locator" href="#calibre_link-723" class="calibre9">Item 8: Know How to Tell Whether a
                  Symbol Is in the Type Space or Value Space</a>-<a data-type="index:locator" href="#calibre_link-724"
                  class="calibre9">Things to Remember</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">values</span>
                <ul class="calibre56">
                  <li class="calibre11"><span data-type="index-term" class="calibre">assigning to variables</span>, <a
                      data-type="index:locator" href="#calibre_link-725" class="calibre9">Item 9: Prefer Type
                      Declarations to Type Assertions</a>-<a data-type="index:locator" href="#calibre_link-726"
                      class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">keeping in sync with mapped
                      types</span>, <a data-type="index:locator" href="#calibre_link-727" class="calibre9">Item 18: Use
                      Mapped Types to Keep Values in Sync</a>-<a data-type="index:locator" href="#calibre_link-728"
                      class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">null values versus non-null
                      values</span>, <a data-type="index:locator" href="#calibre_link-729" class="calibre9">Item 31:
                      Push Null Values to the Perimeter of Your Types</a>-<a data-type="index:locator"
                      href="#calibre_link-730" class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">types as set values</span>, <a
                      data-type="index:locator" href="#calibre_link-731" class="calibre9">Item 7: Think of Types as Sets
                      of Values</a>-<a data-type="index:locator" href="#calibre_link-732" class="calibre9">Things to
                      Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">with unknown types</span>, <a
                      data-type="index:locator" href="#calibre_link-733" class="calibre9">Item 42: Use unknown Instead
                      of any for Values with an Unknown Type</a>-<a data-type="index:locator" href="#calibre_link-734"
                      class="calibre9">Things to Remember</a></li>
                </ul>
              </li>
              <li class="calibre11"><span data-type="index-term" class="calibre">var</span>, <a
                  data-type="index:locator" href="#calibre_link-735" class="calibre9">Use let/const Instead of var</a>
              </li>
              <li class="calibre11"><span data-type="index-term" class="calibre">variables</span>
                <ul class="calibre56">
                  <li class="calibre11"><span data-type="index-term" class="calibre">assigning values to</span>, <a
                      data-type="index:locator" href="#calibre_link-736" class="calibre9">Item 9: Prefer Type
                      Declarations to Type Assertions</a>-<a data-type="index:locator" href="#calibre_link-737"
                      class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">avoiding reuse for different
                      types</span>, <a data-type="index:locator" href="#calibre_link-738" class="calibre9">Item 20: Use
                      Different Variables for Different Types</a>-<a data-type="index:locator" href="#calibre_link-739"
                      class="calibre9">Things to Remember</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">including units in variable
                      names</span>, <a data-type="index:locator" href="#calibre_link-740" class="calibre9">Item 30:
                      Don’t Repeat Type Information in Documentation</a></li>
                  <li class="calibre11"><span data-type="index-term" class="calibre">naming</span>, <a
                      data-type="index:locator" href="#calibre_link-741" class="calibre9">Item 36: Name Types Using the
                      Language of Your Problem Domain</a>-<a data-type="index:locator" href="#calibre_link-742"
                      class="calibre9">Things to Remember</a></li>
                </ul>
              </li>
              <li class="calibre11"><span data-type="index-term" class="calibre">versions, managing for type
                  declarations</span>, <a data-type="index:locator" href="#calibre_link-743" class="calibre9">Item 46:
                  Understand the Three Versions Involved in Type Declarations</a>-<a data-type="index:locator"
                  href="#calibre_link-744" class="calibre9">Things to Remember</a></li>
            </ul>
          </div>
          <div data-type="indexdiv" class="praise">
            <h3 class="calibre54">W</h3>
            <ul class="calibre55">
              <li class="calibre11"><span data-type="index-term" class="calibre">webpack</span>, <a
                  data-type="index:locator" href="#calibre_link-745" class="calibre9">Use ECMAScript Modules</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">Westbrook, Russell</span>, <a
                  data-type="index:locator" href="#calibre_link-746" class="calibre9">Item 27: Use Functional Constructs
                  and Libraries to Help Types Flow</a></li>
              <li class="calibre11"><span data-type="index-term" class="calibre">widening</span>, <a
                  data-type="index:locator" href="#calibre_link-747" class="calibre9">Item 21: Understand Type
                  Widening</a>-<a data-type="index:locator" href="#calibre_link-748" class="calibre9">Things to
                  Remember</a></li>
            </ul>
          </div>
          <div data-type="indexdiv" class="praise">
            <h3 class="calibre54">Y</h3>
            <ul class="calibre55">
              <li class="calibre11"><span data-type="index-term" class="calibre">YAML</span>, <a
                  data-type="index:locator" href="#calibre_link-749" class="calibre9">Item 42: Use unknown Instead of
                  any for Values with an Unknown Type</a></li>
            </ul>
          </div>
          <div data-type="indexdiv" class="praise">
            <h3 class="calibre54">Z</h3>
            <ul class="calibre55">
              <li class="calibre11"><span data-type="index-term" class="calibre">zipObject</span>, <a
                  data-type="index:locator" href="#calibre_link-750" class="calibre9">Item 27: Use Functional Constructs
                  and Libraries to Help Types Flow</a></li>
            </ul>
          </div>
        </div>
      </div>
    </section>
  </div>

  <div data-type="book" class="calibre1" id="calibre_link-751">
    <section class="praise" data-pdf-bookmark="About the Author" data-type="colophon" type="colophon">
      <div class="praise" id="calibre_link-999">
        <h1 class="calibre2">About the Author</h1>

        <p class="author1"><strong class="calibre21">Dan Vanderkam</strong> is a principal software engineer at Sidewalk
          Labs. He previously worked on open source genome visualizations at Mount Sinai’s Icahn School of Medicine and
          on Google search features used by billions of people (search for “sunset nyc” or “population of france”). He
          has a long history of building open source projects and is a cofounder of the NYC TypeScript Meetup.</p>

        <p class="author1">When he’s not programming, Dan enjoys climbing rocks and playing bridge. He writes on Medium
          and at <em class="calibre3">danvk.org</em>. He earned his bachelor’s in computer science from Rice University
          in Houston, Texas, and lives in Brooklyn, New York.</p>
      </div>
    </section>
  </div>

  <div data-type="book" class="calibre1" id="calibre_link-805">
    <section data-pdf-bookmark="Colophon" data-type="colophon" type="colophon" class="praise">
      <div class="praise" id="calibre_link-1000">
        <h1 class="calibre2">Colophon</h1>

        <p class="author1">The animal on the cover of <em class="calibre3">Effective TypeScript</em> is a red-billed
          oxpecker (<em class="calibre3">Buphagus erythrorhynchus</em>). These birds inhabit a fragmented range across
          eastern Africa, from Ethiopia and Somalia in the northeast to a few pockets in South Africa; however, these
          birds can be said to inhabit the range of the grazing animals on which they spend almost all their lives.</p>
        <p class="author1">Red-billed oxpeckers are related to starlings and mynahs, though they are of a distinct and
          separate family. About eight inches long, and weighing about two ounces, these birds have a bark-brown head,
          back, and tail, with paler coloring below. Their most striking physical features are their red beaks and red
          eyes set off by bright yellow eyerings.</p>
        <p class="author1">Dominating the life of this bird is where and how it finds its food: red-billed oxpeckers
          feed on ticks and other animal parasites, and they perch on animals as they forage. Their host animals are
          most often antelope (such as kudu and impala) as well as large animals such as zebra, giraffe, buffalo, and
          rhinoceros (elephants do not tolerate them). Red-billed oxpeckers have evolved adaptations to assist them in
          their search for food, such as a flat beak to pierce thick animal hair, and sharp claws and a stiff tail to
          hang on to their host animals. These birds even conduct courtship while perched on a host animal, and only
          leave during nesting season. Parent birds raise three chicks in a nest hole (lined with hair pulled from their
          host) close to the animal herds so that they can feed themselves and their young.</p>
        <p class="author1">The birds’ relationship with their animal hosts was once seen as a clear-cut and classic
          example of mutualism (a mutually beneficial interaction between species). However, recent studies have shown
          that oxpeckers’ feeding habits don’t significantly affect hosts’ parasite loads, and additionally showed that
          oxpeckers actually work to keep animals’ wounds open, so that they can feed on their blood.</p>
        <p class="author1">Red-billed oxpeckers remain common across their range; though pesticide use is a threat,
          their adoption of domestic cattle herds as a food source helps their population remain stable. Many of the
          animals on O’Reilly covers are endangered; all of them are important to the world.</p>

        <p class="author1">The cover illustration is by Jose Marzan, based on a black-and-white engraving from <em
            class="calibre3">Elements of Ornithology</em>. The cover fonts are Gilroy and Guardian Sans. The text font
          is Adobe Minion Pro; the heading font is Adobe Myriad Condensed; and the code font is Dalton Maag’s Ubuntu
          Mono.</p>

      </div>
    </section>
  </div>

  <script src="./script.js"></script>
</body>

</html>